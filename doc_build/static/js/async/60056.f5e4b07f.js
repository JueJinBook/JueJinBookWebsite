"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["60056"],{377858:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var s=r(552676),t=r(740453);let d=r.p+"static/image/d833a4effb8e174b4336175350fd8873.155fb595.webp",c=r.p+"static/image/ba5b63493a869f9b0d5d05e31d720d6b.e9233907.webp",a=r.p+"static/image/554c162eaa8fbc69b9e21173a656eafa.11f891b8.webp",i=r.p+"static/image/acf91511e0d844b2aeac3e7600399b2d.0b7aea57.webp",o=r.p+"static/image/de7f394639c3162697c2fd891d99ed0f.f37efc46.webp",l=r.p+"static/image/2603ab42f36d13f31f7e76b64caba5bb.b7abde3e.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",h3:"h3",strong:"strong",img:"img",blockquote:"blockquote",code:"code",pre:"pre",h4:"h4",ol:"ol"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"29彩蛋篇-rcreduxmodel中间件开发设计",children:["29.彩蛋篇-RcReduxModel中间件开发设计",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29彩蛋篇-rcreduxmodel中间件开发设计",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章节将会给大家分享 ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model",target:"_blank",rel:"noopener noreferrer",children:"re-redux-model"})," 的出现缘由以及设计过程，当然还有核心源码的解读，如果你对本章节内容兴趣不大，可以快速阅读或跳过。"]}),"\n",(0,s.jsx)(n.p,{children:"本文的整体思路："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"为什么要写 rc-redux-model"}),"\n",(0,s.jsx)(n.li,{children:"我期望做成什么样"}),"\n",(0,s.jsx)(n.li,{children:"知识储备"}),"\n",(0,s.jsx)(n.li,{children:"核心源码解读"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"a-为什么要写-rc-redux-model",children:["A. 为什么要写 rc-redux-model",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#a-为什么要写-rc-redux-model",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-出现缘由",children:["1. 出现缘由",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-出现缘由",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["前面给大家不断强调，",(0,s.jsx)(n.strong,{children:"React 是单向数据流的形式"}),"，它不存在数据向上回溯的技能，要么就是向下分发，要么就是自己内部管理。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"在 react 中，有 props 和 state，当我想从父组件给子组件传递数据时，可通过 props 进行数据传递，如果我想在组件内部自行管理状态，那可以选择使用 state。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"很快，我遇到了一个问题，那就是兄弟组件之间如何进行通信？答案是在父组件中管理 state，通过 props 下发给各子组件，子组件通过回调方式，进行通信。"}),"\n",(0,s.jsx)(n.p,{children:"这会存在什么问题？如果你想共享数据，你得把所有需要共享的 state 集中放到组件顶层，然后分发给所有子组件。为此，需要一个库来作为更加牛逼、专业的顶层 state 发给各组件，于是，我引入了 redux。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-体验不佳",children:["2. 体验不佳",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-体验不佳",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/reduxjs/redux",target:"_blank",rel:"noopener noreferrer",children:"redux"})," 可以说是较成熟，生态圈较完善的一个库了，搭配 \xa0",(0,s.jsx)(n.a,{href:"https://github.com/zalmoxisus/redux-devtools-extension",target:"_blank",rel:"noopener noreferrer",children:"redux-devtools-extension"}),"\xa0 这个 chrome 插件，让你开发更加快乐。然，世间万物，皆有利弊。"]}),"\n",(0,s.jsxs)(n.p,{children:["本身我使用 redux 不会有所谓的“痛点”，",(0,s.jsx)(n.strong,{children:"因为 redux 默认只支持同步操作，让使用者自行选择处理异步，对于异步请求 redux 是无能为力的"}),"。这么说吧，它保证自己是纯粹的，脏活累活丢给别人去干。"]}),"\n",(0,s.jsxs)(n.p,{children:["于是我的痛点在于：如何处理异步请求，为此我使用了 redux-saga 去解决异步问题，但是在使用 \xa0",(0,s.jsx)(n.code,{children:"redux"})," + ",(0,s.jsx)(n.code,{children:"redux-saga"})," 中，我发现，这会让我的 ",(0,s.jsx)(n.strong,{children:"[重复性]"})," 工作变多(逐步晋升 CV 工程师)，因为它在我项目中，会存在啰嗦的样板代码。"]}),"\n",(0,s.jsxs)(n.p,{children:["举个例子：异步请求，获取用户信息，我需要创建 \xa0",(0,s.jsx)(n.code,{children:"saga/user.js"}),"、",(0,s.jsx)(n.code,{children:"reducers/user.js"}),"、以及 ",(0,s.jsx)(n.code,{children:"action/user.js"}),"，为了统一管理 const，我可能还会有一个 \xa0",(0,s.jsx)(n.code,{children:"const/user.js"}),"，然后在这些文件之间来回切换。（什么玩意？）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// const/user.js\nconst FETCH_USER_INFO = 'FETCH_USER_INFO';\nconst FETCH_USER_INFO_SUCCESS = 'FETCH_USER_INFO_SUCCESS';\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// actions/user.js\nexport function fetchUserInfo(params, callback) {\n  return {\n    type: FETCH_USER_INFO,\n    params,\n    callback,\n  };\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// sagas/user.js\nfunction* fetchUserInfoSaga({ params, callback }) {\n  const res = yield call(fetch.callAPI, {\n    actionName: FETCH_USER_INFO,\n    params,\n  });\n  if (res.code === 0) {\n    yield put({\n      type: FETCH_USER_INFO_SUCCESS,\n      data: res.data,\n    });\n    callback && callback();\n  } else {\n    throw res.msg;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// reducers/user.js\nfunction userReducer(state, action) {\n  switch (action.type) {\n    case FETCH_USER_INFO_SUCCESS:\n      return Immutable.set(state, 'userInfo', action.data);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这种样板代码，简直就是 CV 操作，只需复制一份，修改一下文件名、参数等，就能实现一个请求流程。对我个人而言，这会让我不够专注，分散管理 const、action、saga、reducer 一套流程，需要不断的跳跃思路。随着文件数量变多，我是真的不喜欢如此",(0,s.jsx)(n.code,{children:"繁琐"}),"的流程，有没有好的框架能帮我把这些事都做完呢？"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-dva-速心丸",children:["3. dva 速心丸？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-dva-速心丸",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["dva，基于 redux 和 redux-saga 的数据流方案，让你在一个 model 文件中写所有的 \xa0",(0,s.jsx)(n.code,{children:"action、state、effect、reducers"}),"等，为了简化开发体验，内置了 react-router 和 fetch**。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我是如何看待 dva 的？从官方声明来看，dva 是基于 \xa0",(0,s.jsx)(n.code,{children:"redux"}),"\xa0+\xa0",(0,s.jsx)(n.code,{children:"redux-saga"}),"\xa0 的方案，只是在你写的时候，都写在一个 model 文件，然后它帮你做一些处理；其次它是一个框架，而不是一个库，是否意味着：我在项目开始之前，我就需要确定项目的架构是不是用 dva，如果开发一半，我想换成 dva 这种状态管理的写法，而去引入 dva ，是否不合理？再或者，我只是做一些 demo、写点个人小项目，但我又想像写 dva 的数据状态管理 model 那种方式，引入 dva 是不是反而变得笨重呢？"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-自己所需",children:["4. 自己所需",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-自己所需",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["出发点为：在于解决繁琐重复的工作，store 文件分散，state 类型和赋值错误的问题，为此，我期望为跟我一样困惑的小伙伴，提供一个写状态管理较为 ",(0,s.jsx)(n.strong,{children:"[舒服]"})," 的书写方式，无缝兼容原有项目，只需要安装这个包，就能引入一套数据管理方案，写起来又舒服简洁。"]}),"\n",(0,s.jsxs)(n.h2,{id:"b-如何实现-rc-redux-model",children:["B. 如何实现 rc-redux-model",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#b-如何实现-rc-redux-model",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"01-初建雏形",children:["01. 初建雏形",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#01-初建雏形",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["由于之前有阅读过 ",(0,s.jsx)(n.code,{children:"redux"})," 的源码，同时也大致阅读过 ",(0,s.jsx)(n.code,{children:"redux-thunk"})," 的源码，并且查阅了一些与 redux 相关文章，在有了一些知识储备之后，开始着手编写相关代码。（下面我会介绍部分知识点）"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["如果你对 redux 源码存在疑惑，你不妨看看这篇 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844904183426973703",target:"_blank",rel:"noopener noreferrer",children:"【KT】轻松搞定 Redux 源码解读与编程艺术"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在参考了 dva 对 model 的参数说明，进行参数定义，由于我没有 redux-saga ，所以是没有 \xa0",(0,s.jsx)(n.code,{children:"effect"}),"\xa0 这个属性的，于是初步得到我的 model 参数"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["下面是一个 ",(0,s.jsx)(n.code,{children:"model"})," 的类型约束"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface RModel {\n  namespace: string; // 命名空间\n  state: {\n    [key: string]: any;\n  };\n  action?: {\n    [key: string]: ({\n      dispatch,\n      getState,\n      currentAction,\n      commit,\n      call,\n    }) => void;\n  };\n  reducers?: {\n    [key: string]: any;\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"按照我的设想，我会存在多个 model 文件，聚集在一起之后，得到的是一个数组 :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// model.js\nimport aModel from './aModel';\nimport bModel from './bModel';\nimport cModel from './cModel';\n\nexport default [aModel, bModel, cModel];\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我所希望的是：通过传入 \xa0",(0,s.jsx)(n.code,{children:"RModel[]"}),"，实例化 ",(0,s.jsx)(n.code,{children:"RcReduxModel"}),"，得到的实例带有经过处理后的 reducers"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["reducers：所有 ",(0,s.jsx)(n.code,{children:"model.reducers"})," 集合，这样我可以无障碍的用在 \xa0",(0,s.jsx)(n.code,{children:"store.combineReducers"}),"中，可以兼容你现有的项目，因为只要你用了 redux， 那么你肯定得通过 \xa0",(0,s.jsx)(n.code,{children:"combineReducers API"}),"\xa0 去集合所有的 reducers"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// createStore.js\n\n// \uD83D\uDC47 导入聚集所有 model，得到的是一个数组\nimport models from './models';\nimport RcReduxModel from 'rc-redux-model';\n\nconst reduxModel = new RcReduxModel(models);\n\nconst reducerList = combineReducers(reduxModel.reducers);\nreturn createStore(reducerList);\n"})}),"\n",(0,s.jsx)(n.p,{children:"因为我想像写 model 那样，所有东西都在一个文件中，自然而然，这个 action 集到 model 里边之后，如何处理异步就成了我需要解决的一个问题"}),"\n",(0,s.jsxs)(n.h3,{id:"02-异步处理",children:["02. 异步处理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#02-异步处理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我可以将 ",(0,s.jsx)(n.code,{children:"redux-thunk"}),"\xa0 或 \xa0",(0,s.jsx)(n.code,{children:"redux-saga"}),"\xa0 集成进去，但感觉没必要。出于对这两个库的学习，以及在使用上带给我的 ",(0,s.jsx)(n.strong,{children:"[体验]"}),"，我在想，能不能自行处理？于是，我去将 \xa0",(0,s.jsx)(n.code,{children:"redux-thunk"}),"\xa0 的源码看了一遍。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"redux-thunk 中判断你的 action 是 function 还是 object，从而判断你的 action 是同步还是异步"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"怎么理解呢？大家肯定都有写过同步 action 或者异步 action"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"同步：通过 dispatch 发起一个 action，去修改 redux 的 state 值"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"异步：通过 dispatch 发起一个 action，由于 redux 没有异步能力，所以借助 redux-thunk 的能力，redux-thunk 发现你发起的 action 并不是一个 object，而是一个 function，它就会去帮你把请求发出，当请求处理完后，得到数据，你再发起一个同步的 action 去修改 redux 的 state 值"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["最后得出了一个解决方案：",(0,s.jsxs)(n.strong,{children:["在 \xa0",(0,s.jsx)(n.code,{children:"rc-redux-model"}),"\xa0 中，每一个 action 都是异步的，也就是你发起的每一个 action，都是函数"]}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aModel = {\n  state: {\n    a: '',\n  },\n  action: {\n    // 这两个 action 都是 function\n    firstAction: ({ getState, dispatch }) => {},\n    secondAction: ({ getState, dispatch }) => {},\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"即使你想要发起一个同步 action，去修改 state 的值，我也会将其作为异步进行处理，也就是你修改 state 值，你需要这么写"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// component.js\n\n// \uD83D\uDC47 1. 发起一个 action 用于修改 state 值\nthis.props.dispatch({\n  type: 'aModel/setStateA',\n  payload: '666',\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// aModel.js\n\naModel = {\n  namespace: 'aModel',\n  state: {\n    a: '111',\n  },\n  action: {\n    // \uD83D\uDC47 2. 这是异步action，在这里你可以做异步请求，也可以做同步处理\n    // 总之，异步或同步，都需要经过这里的“转发”，再去修改 state 值\n    setStateA: ({ currentAction, dispatch }) => {\n      dispatch({\n        type: 'aModel/CHANGE_STATE_A',\n        payload: currentAction.payload,\n      });\n    },\n  },\n  reducers: {\n    ['CHANGE_STATE_A'](state, payload) {\n      return {\n        ...state,\n        a: payload,\n      };\n    },\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"明确了这两点，接下来就只需要开发即可。开发接下来我会讲到，我们继续往下看"}),"\n",(0,s.jsxs)(n.h3,{id:"03-提高体验",children:["03. 提高体验",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#03-提高体验",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"由于每个 action，都需要小伙伴们自己去写，极度麻烦，以下面这个例子说明"}),"\n",(0,s.jsx)(n.p,{children:"我想要修改 state 中的 a 值，需要自己写 action、reducers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// aModel.js\n\naModel = {\n  namespace: 'aModel',\n  state: {\n    a: '111',\n  },\n  action: {\n    // \uD83D\uDC47 2. 这是异步action，在这里你可以做异步请求，也可以做同步处理\n    // 总之，异步或同步，都需要经过这里的“转发”，再去修改 state 值\n    setStateA: ({ currentAction, dispatch }) => {\n      dispatch({\n        type: 'aModel/CHANGE_STATE_A',\n        payload: currentAction.payload,\n      });\n    },\n  },\n  reducers: {\n    ['CHANGE_STATE_A'](state, payload) {\n      return {\n        ...state,\n        a: payload,\n      };\n    },\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["假设我现在有 20 个 state，意味着我得在 model.action 中，写对应的 20 个修改 state 的 action，然后在 model.reducers 中同样写 20 个相对应的 reducer，那么就会使得该文件代码量极大，那跟一开始写 redux 区别在哪？看起来只是将 state、action、reducers 放在一个文件而已。",(0,s.jsx)(n.strong,{children:"并没有真正的解决繁琐重复的工作"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["于是我想到了解决方案：提供一个默认的 action，大家都通过这个 action\n去修改 state 值。但这会有个问题，所有修改 state 的 action，都走同一个 \xa0",(0,s.jsx)(n.code,{children:"action.type"}),"，那么在 \xa0",(0,s.jsx)(n.a,{href:"https://github.com/zalmoxisus/redux-devtools-extension",target:"_blank",rel:"noopener noreferrer",children:"redux-devtools-extension"}),"\xa0 中，是很难发现这个 action 触发，具体是为了修改哪个 state 值。"]}),"\n",(0,s.jsxs)(n.p,{children:["如何解决此问题呢？最终的解决方案就是：",(0,s.jsx)(n.strong,{children:"为每一个 state ，自动注册对应的 action 和 reducer， 同时再提供了一个默认的 action(setStore)"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"✨\xa0 例 : state 有 n 个值，那么最终会自动注册 n+1 个 action，用户只需要记住并调用默认的这个 action(setStore) 即可"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["用户只需要调用默认提供的 \xa0",(0,s.jsx)(n.code,{children:"setStore"}),"\xa0 即可，然后根据 key 进行判断，从而转发到对应到 action 上"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this.props.dispatch({\n  type: '[model.namespace]/setStore',\n  payload: {\n    key: `${model.state.key}`,\n    values: `${your values}`\n  },\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["由于 ",(0,s.jsx)(n.code,{children:"setStore"})," 每次都只能修改一个 state 值，如果在同一时刻，想修改 m 个 state 值，就得发 m 个 action，于是我又添加了一个 ",(0,s.jsx)(n.code,{children:"setStoreList"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this.props.dispatch({\n  type: '[model.namespace]/setStoreList',\n  payload: [\n    {\n      key: `${model.state.key}`,\n      values: `${your values}`\n    },\n    {\n      key: `${model.state.key}`,\n      values: `${your values}`\n    }\n  ]\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"04-数据不可变",children:["04. 数据不可变",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#04-数据不可变",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在函数式编程语言中，数据是不可变的，",(0,s.jsx)(n.a,{href:"http://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-immutability",target:"_blank",rel:"noopener noreferrer",children:"(这也是官方说的)"}),"，所有的数据一旦产生，就不能改变其中的值，如果要改变，那就只能生成一个新的数据。由于现在很多项目都会使用 \xa0",(0,s.jsx)(n.code,{children:"seamless-immutable"}),"，那么在业务中的 ",(0,s.jsx)(n.code,{children:"model.state"})," 中，使用了 Immutable 包裹了 state，然后调用默认提供的 action，最后会报错，懂的都懂 !"]}),"\n",(0,s.jsxs)(n.p,{children:["那么该怎么办呢？内部支持 Immutable ，提供一个配置参数 ",(0,s.jsx)(n.code,{children:"openSeamlessImmutable"}),"，默认为 false，如果你业务中的 state 是 Immutable，而在 model 中不设置此配置，那么会报错。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 使用 seamless-immutable\n\nimport Immutable from 'seamless-immutable';\n\nexport default {\n  namespace: 'appModel',\n  state: Immutable({}),\n  openSeamlessImmutable: true, // 必须开启此配置\n};\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"05-处理类型不一致",children:["05. 处理类型不一致",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#05-处理类型不一致",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这也是我有时候犯的错误，特别是在没有 TypeScript 的情况下，我们有时在 \xa0",(0,s.jsx)(n.code,{children:"model.state"}),"\xa0 中定义好某个值的类型，但在改的时候却将其改为另一个类型，比如"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default {\n  namespace: 'userModel',\n  state: {\n    name: '', // 这里定义 name 为 string 类型\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"但在修改此 state value 时，传递的确是一个非 string 类型的值"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this.props.dispatch({\n  type: 'userModel/setStore',\n  payload: {\n    key: 'name',\n    values: {}, // 这里 name 变成了object\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这其实是不合理的，在 rc-redux-model 中，会针对需要修改的 \xa0",(0,s.jsx)(n.code,{children:"state[key]"}),"\xa0 做类型检测处理"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["同时做 ",(0,s.jsx)(n.code,{children:"state[key]"})," 字段的处理"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default {\n  namespace: 'userModel',\n  state: {\n    name: '', // 这里只定义 state 中存在 name\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时想修改 state 中的另一属性值"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"this.props.dispatch({\n  type: 'userModel/setStore',\n  payload: {\n    key: 'testName',\n    values: '1', // 这里想修改 testName 属性的值\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"极度不合理，因为你在 state 中并没有声明此属性， rc-redux-model 会默认帮你做检测"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"c-核心源码解读",children:["C. 核心源码解读",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#c-核心源码解读",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上诉更多的是对中间件的思考和功能的设计，接下来我们结合代码，来看看一款 redux 中间件该如何开发。在此之前，我希望你能对 redux 有一定的了解，我给你们准备了几篇文章，都是我在开发中间件前看的文章内容，如果你感兴趣，可以点击下方链接查看"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844904183426973703",target:"_blank",rel:"noopener noreferrer",children:"轻松搞定 Redux 源码解读与编程艺术"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://tech.meituan.com/2017/07/14/redux-design-code.html",target:"_blank",rel:"noopener noreferrer",children:"redux 从设计到源码——美团技术团队"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://cloud.tencent.com/developer/news/41333",target:"_blank",rel:"noopener noreferrer",children:"redux 之洋葱模型的源码分析与感悟"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://cloud.tencent.com/developer/news/41333",target:"_blank",rel:"noopener noreferrer",children:"深入浅出 Event Sourcing 和 CQRS"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"http://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts",target:"_blank",rel:"noopener noreferrer",children:"✨ redux 官方教程（推荐）"})}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"最起码上面 Part B 部分中的 action、reducer 等你都得明白吧？你得知道一个 action 是怎样的，reducer 是怎样的，不然下面你理解时会非常困难。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["看完之后，我们需要掌握几个最基础且重要的词汇：",(0,s.jsx)(n.code,{children:"函数式编程"}),"、",(0,s.jsx)(n.code,{children:"compose"}),"、",(0,s.jsx)(n.code,{children:"洋葱模型"}),"，不要急，我们一个个来过知识点。"]}),"\n",(0,s.jsxs)(n.h4,{id:"函数式编程",children:["函数式编程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数式编程",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"函数是第一等公民"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"怎么理解，在 JS 中，函数可以当作是变量传入，也可以赋值给一个变量，甚至于，函数执行的返回结果也可以是函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const func = function () {};\n\n// 1. 当作参数\nfunction demo1(func) {}\n\n// 2. 赋值给另一个变量\nconst copy_func = func;\n\n// 3. 函数执行的返回结果是函数\nfunction demo2() {\n  return func;\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"数据是不可变的(Immutable)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在函数式编程语言中，数据是不可变的，所有的数据一旦产生，就不能改变其中的值，如果要改变，那就只能生成一个新的数据。"}),"\n",(0,s.jsxs)(n.p,{children:["所以我们在 redux 中强调了，不能直接修改 state 的值，",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.a,{href:"http://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-immutability",target:"_blank",rel:"noopener noreferrer",children:"代码必需先复制原来的 object/array，然后更新它的复制体。Redux 期望所有状态更新都是使用不可变的方式"}),"。"]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["额外补充一下，下边的两句话引用来自 ",(0,s.jsx)(n.code,{children:"Dan Abramov"})," 的博客: ",(0,s.jsx)(n.a,{href:"https://overreacted.io/how-are-function-components-different-from-classes/",target:"_blank",rel:"noopener noreferrer",children:"How Are Function Components Different from Classes?"})," 在 react 中，我们从 ",(0,s.jsx)(n.code,{children:"this.props.xxx"})," 中读取数据。为什么我们可以得到最新的实例？其实不是因为 props 改变了，在 react 中，props 是不可变(immutable)的，他们永远不会改变。然而，this 是可变(mutable)的。这就是 react 类组件 this 存在的意义。"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"函数只接受一个参数"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"怎么理解，大伙估计都写了很久的多参数，看到这个懵了啊，我也懵了，但是这就是规矩，无规矩，不成方圆 ～"}),"\n",(0,s.jsxs)(n.p,{children:["所以当你看",(0,s.jsx)(n.strong,{children:"中间件"}),"的代码时，你就不会奇怪了，比如这行代码 ～"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const middleware = (store) => (next) => (action) => {};\n"})}),"\n",(0,s.jsx)(n.p,{children:"换成我们能够理解的形式，那就是 :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const middleware = (store) => {\n  return (next) => {\n    return (action) => {};\n  };\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里有人就疑问了，这不就是依赖了三个参数吗，那能不能这样写啊？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const middleware = (store, next, action) => {};\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以，但这是规矩，是函数式编程就是要求只能有一个参数，懂 ?"}),"\n",(0,s.jsxs)(n.h4,{id:"组合-compose",children:["组合 compose",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组合-compose",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"说说组合 compose，这个是个啥玩意，我们来看一段代码 :"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const compose = (f, g) => {\n  return (x) => {\n    return f(g(x));\n  };\n};\n\nconst add = function (x) {\n  return x + 2;\n};\n\nconst del = function (x) {\n  return x - 1;\n};\n\n// 使用组合函数，\uD83E\uDDEC 基因突变，强强联合\nconst composeFunction = compose(add, del)(100);\n"})}),"\n",(0,s.jsx)(n.p,{children:"猜一下，执行 composeFunction 打印什么？答对的，给自己鼓个掌 \uD83D\uDC4F"}),"\n",(0,s.jsx)(n.p,{children:"好了，我已经把最为强大的忍术：函数式编程术语之 compose 组合函数，教给你了～ 你多看几遍，之后你看 redux 的源码你就有种醍醐灌地的感觉。"}),"\n",(0,s.jsxs)(n.h4,{id:"洋葱模型",children:["洋葱模型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#洋葱模型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"洋葱模型是本质上是一层层的处理逻辑，而在函数式编程世界里，意味着用函数来做处理单元。先不说其他，我们先上一个例子，帮助大家理解～"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let middleware = [];\nmiddleware.push((next) => {\n  console.log('A');\n  next();\n  console.log('A1');\n});\nmiddleware.push((next) => {\n  console.log('B');\n  next();\n  console.log('B1');\n});\nmiddleware.push((next) => {\n  console.log('C');\n});\n\n// 这里的 run 不用 care\nlet func = run(middleware);\nfunc();\n"})}),"\n",(0,s.jsx)(n.p,{children:"猜猜打印顺序是个啥 ？没错，打印结果为 : A -> B -> C -> B1 -> A1"}),"\n",(0,s.jsxs)(n.p,{children:["当程序运行到 ",(0,s.jsx)(n.code,{children:"next()"})," 的时候会暂停当前程序，进入下一个中间件，处理完之后才会仔回过头来继续处理。"]}),"\n",(0,s.jsx)(n.p,{children:"我们看这张图，很有意思，会有两次进入同一个中间件的行为，而且是在所有第一次的中间件执行之后，才依次返回上一个中间件。你品，你细品～"}),"\n",(0,s.jsx)(n.p,{children:"如果你能看懂上面这段中间件的代码，那么我稍微改写一下，你也应该看得懂"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function f1(store) {\n  return function (next) {\n    return function (action) {\n      console.log('step1 中间件1 开始');\n      next(action);\n      console.log('step2 中间件1 结束');\n    };\n  };\n}\n\nfunction f2(store) {\n  return function (next) {\n    return function (action) {\n      console.log('step3 中间件2 开始');\n      next(action);\n      console.log('step4 中间件2 结束');\n    };\n  };\n}\n\nfunction f3(store) {\n  return function (next) {\n    return function (action) {\n      console.log('step5 中间件3 开始');\n      next(action);\n      console.log('step6 中间件3 结束');\n    };\n  };\n}\n\nfunction reducer(state, action) {\n  if (action.type === 'INIT_STORE') {\n    console.log('我是大帅哥');\n  }\n  return {};\n}\n\nvar store = Redux.createStore(reducer, Redux.applyMiddleware(f1, f2, f3));\n\nstore.dispatch({ type: 'INIT_STORE' });\n"})}),"\n",(0,s.jsx)(n.p,{children:"这时候想必大家还是有些难以理解，大概解读一下，在这个示例代码中，洋葱模型运行过程就是："}),"\n",(0,s.jsxs)(n.p,{children:["派发 action → 经过 ",(0,s.jsx)(n.code,{children:"applyMiddleware API"})," 的组合 -> action 传入 f1 副作用 → 打印 step1 → 执行 f1 的 next（这个 next 指向 f2 副作用）→ 打印 step3 → 执行 f2 的 next（这个 next 指向 f3 副作用）→ 打印 step5 → 执行 f3 的 next（这个 next 指向",(0,s.jsx)(n.code,{children:"store.dispatch"}),"）→ 执行完毕 -> 打印我是大帅哥 -> 返回到 f3 副作用打印 step6 → 返回到 f2 打印 step4 → 返回到 f1 副作用打印 step2 -> dispatch 执行完毕。"]}),"\n",(0,s.jsxs)(n.p,{children:["有人就会好奇了，这里的 ",(0,s.jsx)(n.code,{children:"next"})," 到底是什么东西，其实他就是 ",(0,s.jsx)(n.code,{children:"store.dispatch"}),"，有点饶？我们来梳理一下。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果你还不太能理解，请放轻松，先把上边我给的几个链接文章看一看，并且去搜索相关知识，自己补充补充知识。如果你能看懂上面这段中间件的 store 例子，那么请深呼吸一口气，接下来我们再深入一点。看看 ",(0,s.jsx)(n.code,{children:"applyMiddleware"})," 的源码，不要怀疑，这真的是 redux 的源码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export default function applyMiddleware(...middlewares) {\n  return (createStore) =>\n    (reducer, ...args) => {\n      const store = createStore(reducer, ...args);\n      let dispatch: Dispatch = () => {};\n\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (action, ...args) => dispatch(action, ...args),\n      };\n\n      const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n      dispatch = compose(...chain)(store.dispatch);\n\n      return {\n        ...store,\n        dispatch,\n      };\n    };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"短短十几行代码，将我们上边说的知识点都包含了。不要怀疑，这就是源码，先试着理解一下。"}),"\n",(0,s.jsxs)(n.p,{children:["首先，传入了一个中间件数组 ",(0,s.jsx)(n.code,{children:"middlewares"}),"，我们将它进行剥皮，并给中间件 middleware 都以我们定义的 middlewareAPI 作为参数注入，所以我们每一个中间件的上下文是 dispatch 和 getState，为什么？为什么要注入这两个玩意？因为"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"getState：每一层洋葱都可以获取到当前的状态。"}),"\n",(0,s.jsx)(n.li,{children:"dispatch：为了可以将操作传递给下一个洋葱。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"那它是如何给每一个 middleware 注入的呢？看这段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["遍历 middlewares，然后每一个中间件都注入 ",(0,s.jsx)(n.code,{children:"store.getState"})," 和 ",(0,s.jsx)(n.code,{children:"store.dispatch"}),"，那经过这样处理之后，chain 是个什么东西？"]}),"\n",(0,s.jsx)(n.p,{children:"很好理解，上面说过了函数式编程的要点：函数只接受一个参数，再复习一下这段代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const middleware = (store, next, action) => {};\n"})}),"\n",(0,s.jsx)(n.p,{children:"是否有些眼熟，改写成我们熟知的函数式编程，就变成下面这样了"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const middleware = (store) => (next) => (action) => {};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，chain 其实是一个 ",(0,s.jsx)(n.code,{children:"(store) => (next) => (action) => {}"})," 函数的数组，也就是中间件剥开后返回的函数组成的数组。"]}),"\n",(0,s.jsx)(n.p,{children:"我们再看看这行代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"dispatch = compose(...chain)(store.dispatch);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"compose"})," 应该不陌生了，组合函数，这里的代码改成我们常见的样子，就是下面这种形式"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function compose(...chain) {\n  return (store.dispatch) => {\n    return chain.reduce((a, b) => (store.dispatch) => a(b(store.dispatch)))\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们以 store.dispatch 作为参数进行注入～ 通过 compose 对中间件数组内剥出来的高阶函数进行组合形成一个调用链。调用一次，中间件内的所有函数都将被执行。"}),"\n",(0,s.jsx)(n.p,{children:"知识量有点多，如果觉得有点乱，我们再来捋一捋。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["抛出第一个问题？",(0,s.jsx)(n.code,{children:"dispatch 是用来干嘛的？"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"dispatch 是用来分发 action 的`，good，那么，我们可以得到第一个函数"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(store.dispatch) => (action) => {}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"这里抛出第二个问题，为了在每一个中间件中，都需要得到实时的 store 数据，怎么搞？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["那就不需要只传 ",(0,s.jsx)(n.code,{children:"store.dispatch"}),"，再给它传一个 ",(0,s.jsx)(n.code,{children:"store.getState"}),"，那么，我们可以得到修改后的函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(store.dispatch, store.getState) => (action) => {}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第三个问题，为了让下一个中间件，具备 dispatch 的能力，该怎么办？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["那就把 store.dispatch 传给下一个中间件，让它具备 ",(0,s.jsx)(n.code,{children:"dispatch"})," 能力，那么，我们可以得到修改后的函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(store.dispatch, store.getState) => (store.dispatch) => (action) => {}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第四个问题，为了能够让每一个中间件持有最终的 dispatch，如何处理？"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"redux 开发者利用了闭包的特性，将内部的 dispatch 与外部进行强绑定，也就是这段代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 这是我们意yin的代码\nlet dispatch = () => {};\n\nmiddlewares.map((middleware) =>\n  middleware({\n    getState,\n    dispatch() {\n      return dispatch;\n    },\n  })\n);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 映射到 redux 中的真实源码\nlet middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action, ...args) => dispatch(action, ...args),\n};\n\n// 其实你把 middlewareAPI 写到 middleware 里边，就等价于上边那玩意了\nconst chain = middlewares.map((middleware) => middleware(middlewareAPI));\ndispatch = compose(...chain)(store.dispatch);\n"})}),"\n",(0,s.jsx)(n.p,{children:"所以最终我们对一个中间件形式就是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"middleware = (store.dispatch, store.getState) => (store.dispatch) => (action) => {}\n\n// 改一下名称\nmiddleware = (store.dispatch, store.getState) => (next) => (action) => {}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"问题五，dispatch 在这里边扮演了什么角色？"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"绑定了各个中间件的 next，说了 next 实际上就是 store.dispatch"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"暴露一个接口用来接收 action"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"你可以这么理解，中间件其实就是我们自定义了一个 dispatch，然后这个 dispatch 会按照洋葱模型进行 pipe"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"有个疑惑: 为什么在 middlewareAPI 中，dispatch 不是直接写成 store.dispatch, 而是用的匿名函数的闭包引用？"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 为什么不这么写....\nlet middlewareAPI = {\n  getState: store.getState,\n  dispatch: (action) => store.dispatch(action),\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"其实写成匿名函数的闭包引用是为了每一个中间件都取的是最新的 dispatch"}),"，假设我们现在执行某一个中间件 m1，然后 dispatch 了 action1，当此 action1 执行完毕，接着应该执行下一个中间件 m2，在下一个中间件中，dispatch 应当是最新的引用，不然这个 action2 走的是没有经过任何中间件修饰的 store.dispatch，这显然是不行的。所以要写成匿名函数的闭包引用。"]}),"\n",(0,s.jsxs)(n.h3,{id:"结合-rc-redux-model-源码",children:["结合 rc-redux-model 源码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结合-rc-redux-model-源码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上面看完之后，最为重要的是你需要知道，一个中间件的组成"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const middleware = (store.dispatch, store.getState) => (next) => (action) => {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"记住这一点，那么接下来就好办了，因为我们做的是一个 redux 中间件，在使用上是"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport models from './models';\nimport RcReduxModel from 'rc-redux-model';\n\nconst reduxModel = new RcReduxModel(models);\n\n// \uD83D\uDC49 利用 combineReducers 把我们写的 reducers 搞进去\nconst reducerList = combineReducers(reduxModel.reducers);\n// \uD83D\uDC49 利用 applyMiddleware 将我们写的中间件搞进去\nreturn createStore(reducerList, applyMiddleware(reduxModel.thunk));\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们开始写代码"}),"\n",(0,s.jsxs)(n.h4,{id:"d-开始实现-rcreduxmodel-类",children:["D. 开始实现 RcReduxModel 类",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#d-开始实现-rcreduxmodel-类",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"下面这张图是 UML 图，我们可以来看一下，共有 3 个成员变量及 1 个私有方法。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"models：你传进来的 models 经过一系列处理之后的最终 models"}),"\n",(0,s.jsx)(n.li,{children:"reducers：所有 model 下的 reducers，整合在一起，用于 redux.combineReducers"}),"\n",(0,s.jsx)(n.li,{children:"thunk：自己实现的 thunk 中间件，对 dispatch 的增强，用于 redux.applyMiddleware"}),"\n",(0,s.jsxs)(n.li,{children:["start()：主逻辑，该方法下的主要工作为","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"自动为每一个 state 值注册 action"}),"\n",(0,s.jsx)(n.li,{children:"自动注册每一个 model 的 reducers"}),"\n",(0,s.jsx)(n.li,{children:"实现 dispatch 对中间件的增强"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在此之前，我们来看一下一个 model 的类型声明"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface RModel {\n  namespace: string; // 命名空间\n  openSeamlessImmutable?: boolean;\n  state: {\n    [key: string]: any;\n  };\n  action?: {\n    [key: string]: ({\n      dispatch,\n      getState,\n      currentAction,\n      commit,\n      call,\n    }) => void;\n  };\n  reducers?: {\n    [key: string]: any;\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["下面是伪代码，具体请看线上代码：\uD83D\uDC49 ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model/blob/master/core/index.ts",target:"_blank",rel:"noopener noreferrer",children:"index.ts"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class RcReduxModel {\n  public models: {\n    [key: string]: RModel;\n  };\n  public thunk: any;\n  public reducers: any;\n\n  public constructor(models: RModel[]) {\n    this.models = {};\n    this.reducers = {};\n    this.thunk = [];\n    this.start(models);\n  }\n\n  private start(models: RModel[]) {\n    // step1. 自动为每一个 state 都注册一个 action，并且提供默认修改 state 的 action\n    // returns 返回经过处理之后的 model 集合\n    let autoActionAndReducerModel = models.map((model: RModal) => {\n      return registerAutoAction(model);\n    });\n\n    // step2. 每一个 model 中的 reducers 只是一个对象，而在 redux 中，reducer 是一个方法\n    // 该方法的写法为：(state, action) => newState; 所以我们需要改造成符合 redux 的写法\n    // 才能支持 redux.combineReducers 去使用，让我们修改一下\n    autoActionAndReducerModel.forEach((model: RModal) => {\n      this.reducers[model.namespace] = this.registerReducers(model); // 该方法返回的是一个函数\n    });\n\n    // step3. 中间件增强，核心之处：(dispatch, getState) => (next) => (action) => {}\n    // 注入自定义的 callAPI、commit 等功能，具体看下面代码\n    this.thunk = middleware(autoActionAndReducerModel);\n\n    // step4. 检测 model 是否有重复，并将处理之后的 model 赋值给成员变量\n    autoActionAndReducerModel.forEach((model: RModal) => {\n      this.registerModel(model, models);\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面就是整个 ",(0,s.jsx)(n.code,{children:"RcReduxModel"})," 类的核心要点，相比结合注释，大家都能理解，接下来我将一步步带大家实现对应的方法"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"registerAutoAction()：自动为每一个 state 都注册一个 action，并且提供默认修改 state 的 action"}),"\n",(0,s.jsx)(n.li,{children:"registerReducers()：将 model 中的 reducer 对象变为 (state, action) => newState 函数"}),"\n",(0,s.jsx)(n.li,{children:"middleware()：中间件 (dispatch, getState) => (next) => (action) => {}"}),"\n",(0,s.jsx)(n.li,{children:"registerModel()：所有 model 的集合"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"registerautoaction",children:["registerAutoAction()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#registerautoaction",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"该方法接收的是一个 model，上面说了一个 model 都具备什么属性，如果你拿到了一个 model，你期望为每一个 state 提供对应的 action，该如何实现呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 生成自动注册修改 state 的 action.type\nconst generateReducerActionType = (namespace: string, key: string): string => {\n  return `SET_${namespace.toUpperCase()}_${key.toUpperCase()}`;\n};\n\nexport default function (model: RModel): RModel {\n  let nextAction: any = {};\n  let nextReducers: any = {};\n\n  const {\n    namespace,\n    state = {},\n    action = {},\n    reducers = {},\n    openSeamlessImmutable,\n  } = model;\n\n  // step1. 如果没有 state，那就不需要自动注册了\n  if (Object.keys(state).length === 0) return model;\n\n  // step2. 如果存在 state 值，那就遍历 stateKey\n  Object.keys(state).forEach((stateKey: string) => {\n    const actionTypeToReducer = generateReducerActionType(namespace, stateKey);\n\n    // step3. 给每一个 state 都自动生成一个能修改 state 的 action\n    if (!nextAction[`set${stateKey}`]) {\n      nextAction[`set${stateKey}`] = autoAction(actionTypeToReducer);\n    }\n\n    // step4. 注册了 action，对应的 reducer 应该要有一个 action.type 映射，好修改 state 值\n    if (!nextReducers[`${actionTypeToReducer}`]) {\n      nextReducers[`${actionTypeToReducer}`] = autoReducers(\n        stateKey,\n        openSeamlessImmutable\n      );\n    }\n  });\n\n  // step5. 如果有太多的 state，用户记不住注册的 action\n  // 所以这里提供两个默认的 action\n  nextAction['setStore'] = autoSetStoreAction(namespace);\n  nextAction['setStoreList'] = autoSetStoreListAction(namespace);\n\n  // step6. 如果存在重复，以用户定义的为主\n  nextAction = { ...nextAction, ...action };\n  nextReducers = { ...nextReducers, ...reducers };\n  return {\n    ...model,\n    action: nextAction,\n    reducers: nextReducers,\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["自动注册 action 的代码就这么点，但核心在于 ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model/blob/master/core/registerAutoAction.ts#L10",target:"_blank",rel:"noopener noreferrer",children:"autoAction"})," 的实现和 ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model/blob/master/core/registerAutoAction.ts#L25",target:"_blank",rel:"noopener noreferrer",children:"autoReducers"})," 的实现。"]}),"\n",(0,s.jsxs)(n.p,{children:["这边给大家留一个悬念，我怕你们懒得去看源码，所以我这里就不贴代码了，实现也很简单，小伙伴们快",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model/blob/master/core/registerAutoAction.ts",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 点击这里"})," 去看源码啊！"]}),"\n",(0,s.jsxs)(n.h4,{id:"registerreducers",children:["registerReducers()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#registerreducers",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"该方法接收的是一个 model，那么我们如何将 model.reducers 对象，变成我们期望的 (state, action) => newState 呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function registerReducers(model: RModel) {\n  const { namespace, state, reducers } = model;\n\n  invariant(reducers, `model's reducers must be defined, but got undefined`);\n\n  const reducersActionTypes = Object.keys(reducers);\n\n  return (storeState: any, storeAction: any) => {\n    const newState = storeState || state;\n    const reducersActionKeys = storeAction.type.split('/');\n    // step1. 因为我们规定每一个 action type 都必须是 [namespace]/[actionName] 这种格式\n    const reducersActionModelName = reducersActionKeys[0];\n    const reducersActionSelfName = reducersActionKeys[1];\n\n    // step2. 如果命名空间对不上，直接返回数据\n    if (reducersActionModelName !== namespace) return newState;\n\n    // step3. 如果自动注册的 reducer type 存在当前这个 actionName，就会触发执行，将 state 值修改\n    // 其实真正修改的在于上面的 autoReducers 方法，一定要去看这个方法\n    if (reducersActionTypes.includes(reducersActionSelfName)) {\n      return reducers[reducersActionSelfName](newState, storeAction.payload);\n    }\n    return newState;\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"middleware",children:["middleware()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#middleware",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["该方法接收的是一个 model 集合，也就是 ",(0,s.jsx)(n.code,{children:"RModel[]"}),"，接下来我们如何实现一个中间件？"]}),"\n",(0,s.jsxs)(n.p,{children:["中间件的核心之处 ",(0,s.jsx)(n.code,{children:"(dispatch, getState) => (next) => (action) => {}"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const getCurrentModel = (actionModelName: string, models: Array<RModel>) => {\n  if (models.length === 0) return null;\n  const findModel = models.filter(\n    (model: RModel) => model.namespace === actionModelName\n  );\n  if (findModel.length > 0) return findModel[0];\n  return null;\n};\n\nconst actionToReducer = (\n  currentModel: RModal,\n  actionModelName: string,\n  next: any\n) => {\n  return (reducerAction: any) => {\n    if (currentModel && currentModel.reducers) {\n      if (currentModel.reducers[reducerAction.type]) {\n        next({\n          type: `${actionModelName}/${reducerAction.type}`,\n          payload: reducerAction.payload,\n        });\n      }\n    }\n  };\n};\n\nconst callAPI = (dispatch: any) => async (service: any, params: any) => {\n  let result = {};\n  try {\n    result = await service(params);\n  } catch (error) {\n    return Promise.reject(params);\n  }\n\n  return Promise.resolve(result);\n};\n\nexport default function (models: RModel[]) {\n  return ({ dispatch, getState }: any) =>\n    (next: any) =>\n    (action: any) => {\n      // step1. 因为我们规定每一个 action type 都必须是 [namespace]/[actionName] 这种格式\n      const actionKeyTypes = action.type.split('/');\n      invariant(actionKeyTypes.length <= 2, `dispatch action only accept [namespace/actionName], but got ${action.type}`);\n      const actionModelName = actionKeyTypes[0];\n      const actionSelfName = actionKeyTypes[1];\n\n      // step2. 得到当前的 model\n      const currentModel = getCurrentModel(actionModelName, models);\n      if (currentModel) {\n        // step3. 当前这个 action 对象中是否存在当前发的这个 action\n        const currentModelAction = currentModel.action ? currentModel.action[actionSelfName] : null;\n        invariant(currentModelAction, `[${actionSelfName}] does not exist [${actionModelName}]!`);\n\n        // step4. 如果当前这个 action 存在并且是一个函数 （autoAction 返回的是一个 Function，所以一定要去看这个方法）\n        if (currentModelAction && typeof currentModelAction === 'function') {\n          const commitActionToReducer = actionToReducer(currentModel, actionModelName, next);\n          // step5. 发起一个 同步 action，也就是发一个到 reducer 的 action\n          // 当 reducer 接收到 action.type 与我们发过来的一致时，就进行 state 值修改\n          return currentModelAction({\n            dispatch,\n            getState,\n            currentAction: action,\n            commit: commitActionToReducer,\n            call: callAPI(dispatch),\n          });\n        }\n      }\n\n      // step6. 执行下一个中间件，因为 applyMiddleware 可能不仅是集成我们的中间件\n      // 意味着当前这个 action 也许不是我们所期望的 action，我们不这个中间件不处理了\n      return next(action);\n    };\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"registermodel",children:["registerModel()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#registermodel",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"该方法就是检测 model 是否有重复"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function registerModel(model: RModal, models: RModal[]) {\n  invariant(model.namespace, `model's namespace is undefined`);\n  invariant(typeof model.namespace === 'string', `model's namespace should be string, but got ${typeof model.namespace}`);\n  \n  const duplicateModel = models.filter((mod: RModal) => mod.namespace === model.namespace);\n  invariant(duplicateModel.length <= 1, `model's namespace should be unique, but now got the same namespace length = ${duplicateModel.length}, with the same namespace is ${model.namespace}`);\n  \n  if (!this.models[model.namespace]) {\n    this.models[model.namespace] = model;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述就是整个 ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model",target:"_blank",rel:"noopener noreferrer",children:"rc-redux-model"})," 核心代码，实现不难，我还是期望小伙伴们都能去看源码，当然我的代码写的也不一定是最佳的，希望能给你带来一些思路。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果你能捋清楚并且看懂源码，那么我们可以实现一个例如著名的 ",(0,s.jsx)(n.a,{href:"https://github.com/LogRocket/redux-logger",target:"_blank",rel:"noopener noreferrer",children:"redux-logger"}),"，我们练手实现它的简易版本，实现起来大同小异，只需要将未修改前的 redux 和修改之后的 redux 打印出来，再把修改的 action 打印出来，一个最小化的 redux 数据打印中间件就完成了。"]}),"\n",(0,s.jsxs)(n.h2,{id:"最后",children:["最后",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"该篇幅特别长，我很想拆成两篇去写，但最后想想还是算了，这篇文章主要是从我为什么要做一个中间件，到我期望做成怎么样，再到做之前的知识储备，及最终的做成什么样。"}),"\n",(0,s.jsxs)(n.p,{children:["希望我的一些思考和实现能给你带来一些收获。最后如果你觉得该中间件还行，能给你一些帮助，那我不知廉耻的求个小星星 ✨ ",(0,s.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model",target:"_blank",rel:"noopener noreferrer",children:"rc-redux-model"})]})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let u=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F29.%E5%BD%A9%E8%9B%8B%E7%AF%87-RcReduxModel%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"A. 为什么要写 rc-redux-model",id:"a-为什么要写-rc-redux-model",depth:2},{text:"1. 出现缘由",id:"1-出现缘由",depth:3},{text:"2. 体验不佳",id:"2-体验不佳",depth:3},{text:"3. dva 速心丸？",id:"3-dva-速心丸",depth:3},{text:"4. 自己所需",id:"4-自己所需",depth:3},{text:"B. 如何实现 rc-redux-model",id:"b-如何实现-rc-redux-model",depth:2},{text:"01. 初建雏形",id:"01-初建雏形",depth:3},{text:"02. 异步处理",id:"02-异步处理",depth:3},{text:"03. 提高体验",id:"03-提高体验",depth:3},{text:"04. 数据不可变",id:"04-数据不可变",depth:3},{text:"05. 处理类型不一致",id:"05-处理类型不一致",depth:3},{text:"C. 核心源码解读",id:"c-核心源码解读",depth:3},{text:"函数式编程",id:"函数式编程",depth:4},{text:"组合 compose",id:"组合-compose",depth:4},{text:"洋葱模型",id:"洋葱模型",depth:4},{text:"结合 rc-redux-model 源码",id:"结合-rc-redux-model-源码",depth:3},{text:"D. 开始实现 RcReduxModel 类",id:"d-开始实现-rcreduxmodel-类",depth:4},{text:"registerAutoAction()",id:"registerautoaction",depth:4},{text:"registerReducers()",id:"registerreducers",depth:4},{text:"middleware()",id:"middleware",depth:4},{text:"registerModel()",id:"registermodel",depth:4},{text:"总结",id:"总结",depth:4},{text:"最后",id:"最后",depth:2}],title:"29.彩蛋篇-RcReduxModel中间件开发设计",headingTitle:"29.彩蛋篇-RcReduxModel中间件开发设计",frontmatter:{}}}}]);