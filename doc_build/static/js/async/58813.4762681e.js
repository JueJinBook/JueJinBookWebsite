"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58813"],{116882:function(e,n,t){t.r(n),t.d(n,{default:()=>j});var r=t(552676),s=t(740453);let a=t.p+"static/image/707133b8fb2891a2196e202ace4d4792.b578d490.webp",i=t.p+"static/image/bd09eca59375546c597fa02a43946c54.1382ce35.gif",o=t.p+"static/image/121b817dff79909576aecd37495338ae.b578d490.webp",c=t.p+"static/image/9c05aa1e0ebc16a5de3c1da2acfb46ce.1382ce35.gif",d=t.p+"static/image/580802be6015222e80343fcffabf73b9.c03044f5.webp",l=t.p+"static/image/4857d04e4ab598e57dda351fb685779e.d01169fc.gif",h=t.p+"static/image/40eae207cb6a1ac0f254b6416eb4e944.b353cd19.webp",p=t.p+"static/image/91c032b070b1a9deb59851ddf7f71c94.8caf4917.gif";function m(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",img:"img",h4:"h4",strong:"strong",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"41实战篇-_-react-notes-_-笔记搜索",children:["41.实战篇 _ React Notes _ 笔记搜索",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41实战篇-_-react-notes-_-笔记搜索",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本篇我们来实现 React Notes 这个 Demo 的最后一个功能——笔记的搜索功能。"}),"\n",(0,r.jsxs)(n.h2,{id:"utils",children:["utils",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#utils",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["目前我们在多个组件里都使用了 ",(0,r.jsx)(n.code,{children:"sleep"})," 函数，用于模拟长时间请求。为了方便导入和使用，我们将其抽离到 ",(0,r.jsx)(n.code,{children:"/lib/utils.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export const sleep = ms => new Promise(r => setTimeout(r, ms));\n"})}),"\n",(0,r.jsx)(n.p,{children:"想要使用的时候直接导入即可："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import {sleep} from '@/lib/utils'\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"笔记搜索",children:["笔记搜索",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔记搜索",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们想要的效果是当在搜索框输入搜索文字的时候，URL 上添加对应的搜索参数，同时展示搜索后的笔记列表。当页面刷新的时候，如果有搜索参数，也会展示对应搜索后的笔记列表。效果如下："}),"\n",(0,r.jsx)(n.p,{children:"现在让我们来实现吧。"}),"\n",(0,r.jsxs)(n.h3,{id:"搜索输入框",children:["搜索输入框",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#搜索输入框",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先是 ",(0,r.jsx)(n.code,{children:"components/Sidebar.js"}),"导入搜索栏组件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { Suspense } from \'react\'\nimport Link from \'next/link\'\n// 导入组件\nimport SidebarSearchField from \'@/components/SidebarSearchField\';\nimport SidebarNoteList from \'@/components/SidebarNoteList\';\nimport EditButton from \'@/components/EditButton\';\nimport NoteListSkeleton from \'@/components/NoteListSkeleton\';\n\nexport default async function Sidebar() {\n  return (\n    <>\n      <section className="col sidebar">\n        <Link href={\'/\'} className="link--unstyled">\n          <section className="sidebar-header">\n            <img\n              className="logo"\n              src="/logo.svg"\n              width="22px"\n              height="20px"\n              alt=""\n              role="presentation"\n            />\n            <strong>React Notes</strong>\n          </section>\n        </Link>\n        <section className="sidebar-menu" role="menubar">\n          // tia\n          <SidebarSearchField />\n          <EditButton noteId={null}>New</EditButton>\n        </section>\n        <nav>\n          <Suspense fallback={<NoteListSkeleton />}>\n            <SidebarNoteList />\n          </Suspense>\n        </nav>\n      </section>\n    </>\n  )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"components/SidebarSearchField.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"'use client';\n\nimport { usePathname, useRouter } from 'next/navigation'\nimport { useTransition } from 'react'\n\nfunction Spinner({active = true}) {\n  return (\n    <div\n      className={['spinner', active && 'spinner--active'].join(' ')}\n      role=\"progressbar\"\n      aria-busy={active ? 'true' : 'false'}\n    />\n  );\n}\n\nexport default function SidebarSearchField() {\n  const { replace } = useRouter()\n  const pathname = usePathname()\n  const [isPending, startTransition] = useTransition()\n\n  function handleSearch(term) {\n    const params = new URLSearchParams(window.location.search)\n    if (term) {\n      params.set('q', term)\n    } else {\n      params.delete('q')\n    }\n\n    startTransition(() => {\n      replace(`${pathname}?${params.toString()}`)\n    })\n  }\n\n  return (\n    <div className=\"search\" role=\"search\">\n      <label className=\"offscreen\" htmlFor=\"sidebar-search-input\">\n        Search for a note by title\n      </label>\n      <input\n        id=\"sidebar-search-input\"\n        placeholder=\"Search\"\n        type=\"text\"\n        onChange={(e) => handleSearch(e.target.value)}\n      />\n      <Spinner active={isPending} />\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<SidebarSearchField>"})," 是一个客户端组件，因为只有在客户端组件中才能使用 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58",target:"_blank",rel:"noopener noreferrer",children:"useRouter"})," 和 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-54",target:"_blank",rel:"noopener noreferrer",children:"usePathname"}),"。在组件中，我们使用了 React 的 ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/useTransition",target:"_blank",rel:"noopener noreferrer",children:"useTransition"})," hook，非常适合在这种频繁非紧急的更新中使用，有效防止造成阻塞。随着用户的输入，我们会不停的 ",(0,r.jsx)(n.code,{children:"replace"})," 当前的 URL，添加搜索参数。"]}),"\n",(0,r.jsx)(n.p,{children:"此时效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"ReactNotes-搜索.gif"})}),"\n",(0,r.jsxs)(n.h3,{id:"笔记列表渲染",children:["笔记列表渲染",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔记列表渲染",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["左侧的笔记列表需要根据网址上的搜索参数重新渲染，但其实这里并没有必要查询搜索接口，我们直接在客户端使用字符串的 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes",target:"_blank",rel:"noopener noreferrer",children:"includes"})," 方法判断即可。"]}),"\n",(0,r.jsxs)(n.h4,{id:"尝试-1",children:["尝试 1",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尝试-1",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["关键的问题在于获取网址参数。如果要获取参数，我们需要用到 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-68",target:"_blank",rel:"noopener noreferrer",children:"useSearchParams"})," hook，而这个 hook 需要在客户端组件中使用，我们尝试将 ",(0,r.jsx)(n.code,{children:"SidebarNoteList"})," 声明为客户端组件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nimport SidebarNoteItem from '@/components/SidebarNoteItem';\nimport { getAllNotes } from '@/lib/redis';\nimport {sleep} from '@/lib/utils'\nimport { useSearchParams } from 'next/navigation'\n\nexport default async function NoteList() {\n  await sleep(3000);\n  const notes = await getAllNotes()\n\n  // 获取网页搜索参数\n  const searchParams = useSearchParams()\n  const searchText = searchParams.get('q')\n\n  const arr = Object.entries(notes);\n\n  if (arr.length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return <ul className=\"notes-list\">\n    {arr.map(([noteId, note]) => {\n      const noteData = JSON.parse(note);\n      // 判断笔记标题中是否包含搜索字符\n      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {\n        return <li key={noteId}>\n              <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n        </li>\n      }\n      return null\n    })}\n  </ul>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"但是会报模块找不到错误："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"想想也是，毕竟我们在这个组件中用了 ioredis，原本应该在服务端运行，现在却被迫在客户端运行，可不是要罢工嘛……"}),"\n",(0,r.jsxs)(n.h4,{id:"尝试-2",children:["尝试 2",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尝试-2",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["为了避免错误，我们应该再抽离一个客户端组件，数据获取依然放在 ",(0,r.jsx)(n.code,{children:"SidebarNoteList"})," 中，获取参数渲染笔记列表放在子组件中，我们将该组件取名为 ",(0,r.jsx)(n.code,{children:"SidebarNoteListFilter"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"/components/SidebarNoteList.js"}),"代码修改如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import SidebarNoteListFilter from '@/components/SidebarNoteListFilter';\nimport { getAllNotes } from '@/lib/redis';\nimport { sleep } from '@/lib/utils'\n\nexport default async function NoteList() {\n  await sleep(3000);\n  const notes = await getAllNotes()\n\n  if (Object.entries(notes).length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return <SidebarNoteListFilter notes = {notes} />\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"/components/SidebarNoteListFilter.js"}),"代码修改如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nimport SidebarNoteItem from '@/components/SidebarNoteItem';\nimport { useSearchParams } from 'next/navigation';\n\nexport default function SidebarNoteListFilter({notes}) {\n\n  const searchParams = useSearchParams()\n  const searchText = searchParams.get('q')\n\n  return <ul className=\"notes-list\">\n    {Object.entries(notes).map(([noteId, note]) => {\n      const noteData = JSON.parse(note);\n      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {\n        return <li key={noteId}>\n              <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n        </li>\n      }\n      return null\n    })}\n  </ul>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时搜索功能可以正常运行了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"ReactNotes-搜索1.gif"})}),"\n",(0,r.jsxs)(n.h4,{id:"尝试-3",children:["尝试 3",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尝试-3",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"搜索功能看似可以正常运行了，但是有个问题，让我们查看下此时的源代码："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"截屏2023-12-21 下午5.55.33.png"})}),"\n",(0,r.jsxs)(n.p,{children:["你会发现，原本应该服务端渲染的 ",(0,r.jsx)(n.code,{children:"<SidebarNoteItem>"})," 组件、",(0,r.jsx)(n.code,{children:"<SidebarNoteListHeader>"})," 组件此时都变成了客户端组件，而且 ",(0,r.jsx)(n.code,{children:"<SidebarNoteListHeader>"}),"中用到的 ",(0,r.jsx)(n.code,{children:"dayjs"})," 也被打包到客户端 bundle 中。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们在第二篇中辛辛苦苦抽离出 ",(0,r.jsx)(n.code,{children:"SidebarNoteItemContent"})," 组件只为 ",(0,r.jsx)(n.code,{children:"dayjs"})," 不被打包到客户端，现在因为实现搜索功能，都变成了客户端组件，功亏于溃，有什么方法可以避免 ",(0,r.jsx)(n.code,{children:"dayjs"}),"被打包到客户端呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["注：其实 ",(0,r.jsx)(n.code,{children:"dayjs"}),"这个包并不大，打包到 bundle 中也没什么太大影响，但是想想之前的 ",(0,r.jsx)(n.code,{children:"marked"})," 和 ",(0,r.jsx)(n.code,{children:"sanitize-html"}),"，它们却有几百 kB，这里想借这个例子来帮助大家思考如何避免不必要的代码被打包到 bundle 中。"]}),"\n",(0,r.jsxs)(n.p,{children:["让我们分析下问题，",(0,r.jsx)(n.code,{children:"dayjs"})," 为什么被打包到 bundle 中呢？因为 ",(0,r.jsx)(n.code,{children:"SidebarNoteListHeader"}),"被导入到客户端组件中，变成了客户端组件。我们其实应该通过之前讲过的 props 的形式，让 ",(0,r.jsx)(n.code,{children:"SidebarNoteListHeader"})," 在服务端先渲染，然后再传给客户端组件。"]}),"\n",(0,r.jsx)(n.p,{children:"惯用 React 的同学很容易想到使用 render props 的方式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"<SidebarNoteList\n  renderNoteList = {(searchText) => {\n    return Object.entries(notes).map(([noteId, note]) => {\n      const noteData = JSON.parse(note);\n      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {\n        return (\n          <li key={noteId}>\n            <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n          </li>\n        )\n      }\n      return null\n    })\n  }}>\n</SidebarNoteList>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是",(0,r.jsx)(n.strong,{children:"从服务端组件到客户端组件传递的数据需要可序列化"}),"，所以并不支持传入函数，使用这种方式是会报错的。"]}),"\n",(0,r.jsxs)(n.h4,{id:"尝试-4",children:["尝试 4",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尝试-4",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["总的解决思路还是在服务端组件中进行渲染，然后传给客户端组件。我们可以在 ",(0,r.jsx)(n.code,{children:"SidebarNoteList.js"})," 中将所有的笔记列表渲染出来，然后在 ",(0,r.jsx)(n.code,{children:"SidebarNoteListFilter.js"})," 中进行处理。尝试一版，修改 ",(0,r.jsx)(n.code,{children:"/components/SidebarNoteList.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import SidebarNoteListFilter from '@/components/SidebarNoteListFilter';\nimport SidebarNoteItem from '@/components/SidebarNoteItem';\nimport { getAllNotes } from '@/lib/redis';\nimport { sleep } from '@/lib/utils';\n\nexport default async function NoteList() {\n\n  await sleep(2000)\n  const notes = await getAllNotes()\n\n  if (Object.entries(notes).length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return (\n    <SidebarNoteListFilter>\n      {Object.entries(notes).map(([noteId, note]) => {\n        return <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n      })}\n    </SidebarNoteListFilter>\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，",(0,r.jsx)(n.code,{children:"SidebarNoteItem"})," 会在服务端渲染后传给 ",(0,r.jsx)(n.code,{children:"SidebarNoteListFilter"}),"，因为 ",(0,r.jsx)(n.code,{children:"SidebarNoteItem"})," 中引入了 ",(0,r.jsx)(n.code,{children:"SidebarNoteItemHeader"}),"，所以 ",(0,r.jsx)(n.code,{children:"SidebarNoteItemHeader"})," 也会在服务端渲染，这样就避免了客户端打包 ",(0,r.jsx)(n.code,{children:"dayjs"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"/components/SidebarNoteListFilter.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nimport { useSearchParams } from 'next/navigation'\nimport { Children } from 'react';\n\nexport default function SidebarNoteList({ children }) {\n  const searchParams = useSearchParams()\n  const searchText = searchParams.get('q')\n  return (\n    <ul className=\"notes-list\">\n      {Children.map(children, (child, index) => {\n        const title = child.props.title;\n        if (!searchText || (searchText && title.toLowerCase().includes(searchText.toLowerCase()))) {\n          return <li key={index}>{child}</li>\n        }\n        return null\n      })}\n    </ul>\n  )\n}\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们使用了 React 的 ",(0,r.jsx)(n.code,{children:"Children.map"})," 方法，在遍历的时候对标题进行了判断。"]}),"\n",(0,r.jsx)(n.p,{children:"此时功能运行正常："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"ReactNotes-搜索2.gif"})}),"\n",(0,r.jsxs)(n.p,{children:["客户端也不会打包 ",(0,r.jsx)(n.code,{children:"dayjs"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h4,{id:"尝试-5",children:["尝试 5",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尝试-5",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上面的代码还有一个小问题就是 ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/Children",target:"_blank",rel:"noopener noreferrer",children:"Children"})," 方法过时了……"]}),"\n",(0,r.jsxs)(n.p,{children:["React 认为使用 Children 会削弱代码的健壮性，同时 React 也提供了",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/Children#alternatives",target:"_blank",rel:"noopener noreferrer",children:"替代方案"}),"，那就是改为接收对象数组作为 props。"]}),"\n",(0,r.jsxs)(n.p,{children:["想想也确实可以，如果是为了避免打包 dayjs，最核心的是将 dayjs 在服务端运行。我们在 ",(0,r.jsx)(n.code,{children:"SidebarNoteList.js"})," 获取所有数据，然后把 header JSX 渲染好，再一起传给客户端组件",(0,r.jsx)(n.code,{children:"SidebarNoteListFilter.js"}),"，在其中进行具体的判断处理。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"/components/SidebarNoteList.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import SidebarNoteList from '@/components/SidebarNoteList';\nimport { getAllNotes } from '@/lib/redis';\nimport { sleep } from '@/lib/utils';\nimport SidebarNoteItemHeader from '@/components/SidebarNoteItemHeader';\n\nexport default async function NoteList() {\n\n  await sleep(2000)\n  const notes = await getAllNotes()\n\n  if (Object.entries(notes).length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return (\n    <SidebarNoteList notes = {\n      Object.entries(notes).map(([noteId, note]) => {\n        const noteData = JSON.parse(note)\n        return {\n          noteId,\n          note: noteData,\n          header: <SidebarNoteItemHeader title={noteData.title} updateTime={noteData.updateTime} />\n        }\n      })\n    } />\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"/components/SidebarNoteListFilter.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"'use client'\n\nimport { useSearchParams } from 'next/navigation'\nimport SidebarNoteItemContent from '@/components/SidebarNoteItemContent';\n\nexport default function SidebarNoteList({ notes }) {\n  const searchParams = useSearchParams()\n  const searchText = searchParams.get('q')\n  return (\n    <ul className=\"notes-list\">\n      {notes.map(noteItem => {\n        const {noteId, note, header} = noteItem;\n        if (!searchText || (searchText && note.title.toLowerCase().includes(searchText.toLowerCase()))) {\n          return (\n            <SidebarNoteItemContent\n              key={noteId}\n              id={noteId}\n              title={note.title}\n              expandedChildren={\n                <p className=\"sidebar-note-excerpt\">\n                  {note.content.substring(0, 20) || <i>(No content)</i>}\n                </p>\n              }>\n                {header}\n            </SidebarNoteItemContent>\n          )\n        }\n\n        return null\n      })}\n    </ul>\n  )\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时功能运行正常："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"ReactNotes-搜索2.gif"})}),"\n",(0,r.jsxs)(n.p,{children:["客户端也不会打包 ",(0,r.jsx)(n.code,{children:"dayjs"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么今天的内容就结束了，本篇的内容并不多，主要是实现搜索功能。至此，原 React Notes Demo 中的功能我们已经全部实现。"}),"\n",(0,r.jsxs)(n.p,{children:["在 Next.js 中，使用 ",(0,r.jsx)(n.code,{children:"usePathname"}),"、",(0,r.jsx)(n.code,{children:"useRouter"}),"、",(0,r.jsx)(n.code,{children:"useSearchParams"})," 等 hooks 都需要在客户端组件中，这就导致可能会打包不必要的代码到客户端 bundle 中，其解决的关键就是将组件尽可能运行在服务端，先在服务端渲染后再传给客户端组件。"]}),"\n",(0,r.jsxs)(n.p,{children:["本篇的代码我已经上传到",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/main",target:"_blank",rel:"noopener noreferrer",children:"代码仓库"}),"的 Day 5 分支："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["尝试 2 Demo 在 ",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5",target:"_blank",rel:"noopener noreferrer",children:"day5"})," 分支"]}),"\n",(0,r.jsxs)(n.li,{children:["尝试 4 Demo 在 ",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5-1",target:"_blank",rel:"noopener noreferrer",children:"day5-1"})," 分支"]}),"\n",(0,r.jsxs)(n.li,{children:["尝试 5 Demo 在 ",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5-2",target:"_blank",rel:"noopener noreferrer",children:"day5-2"})," 分支"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"直接使用的时候不要忘记在本地开启 Redis。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F41.%E5%AE%9E%E6%88%98%E7%AF%87%20_%20React%20Notes%20_%20%E7%AC%94%E8%AE%B0%E6%90%9C%E7%B4%A2.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"utils",id:"utils",depth:2},{text:"笔记搜索",id:"笔记搜索",depth:2},{text:"搜索输入框",id:"搜索输入框",depth:3},{text:"笔记列表渲染",id:"笔记列表渲染",depth:3},{text:"尝试 1",id:"尝试-1",depth:4},{text:"尝试 2",id:"尝试-2",depth:4},{text:"尝试 3",id:"尝试-3",depth:4},{text:"尝试 4",id:"尝试-4",depth:4},{text:"尝试 5",id:"尝试-5",depth:4},{text:"总结",id:"总结",depth:2}],title:"41.实战篇 _ React Notes _ 笔记搜索",headingTitle:"41.实战篇 _ React Notes _ 笔记搜索",frontmatter:{}}}}]);