"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["82591"],{297762:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var t=r(552676),s=r(740453);let c=r.p+"static/image/f6be25b9ee0640a3a5992f5389908db5.069d03a4.gif",i=r.p+"static/image/7924974978bf2a5968478e43925c5ffb.f75b50c1.webp",a=r.p+"static/image/c4a157444fec725320f02f738de788e9.7f4f67c6.webp",l=r.p+"static/image/6b7cf62f217fabf176a024a656cbbca1.6807f5f8.webp",d=r.p+"static/image/5831ce7c7aaf17129b31b4d392d9480e.5c4c69c1.webp",o=r.p+"static/image/893edfabaab32cea5fe15ab41bdeba06.17abe04b.gif",h=r.p+"static/image/3cba367027ff95f557de3c613666aa27.17abe04b.gif";function p(e){let n=Object.assign({h2:"h2",a:"a",p:"p",img:"img",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3",ol:"ol",strong:"strong",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116033020018697",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 手写 RSC（下）》"}),"中，我们实现了 React RSC，最终的效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"react-rsc-7.gif"})}),"\n",(0,t.jsx)(n.p,{children:"本篇并不会拓展新的功能，而是会在此基础上进行优化，并讲解 RSC 与 Next.js 实现的基本原理。"}),"\n",(0,t.jsx)(n.p,{children:"如果没有实现之前的代码，可以运行："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"# 67.源码篇 _ RSC 实现原理\ngit clone -b react-rsc-8 git@github.com:mqyqingfeng/next-app-demo.git\n# 进入目录并安装依赖项\ncd next-app-demo && npm i\n# 启动\nnpm start\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"优化一解决重复调用",children:["优化一：解决重复调用",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化一解决重复调用",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["查看我们的 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"中的 htmlGenerator 函数代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export async function htmlGenerator(url) {\n  let jsx = <Router url={url} />\n  let html = await renderJSXToHTML(jsx);\n  const clientJSX = await renderJSXToClientJSX(jsx);\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"运行 renderJSXToHTML 时我们递归调用了 Router 和子组件，运行 renderJSXToClientJSX 时，我们又递归调用了 Router 和子组件，这就造成了两次重复调用，如果数据变化（比如 feeds）就会产生问题，所以最好的解决方法是使用 clientJSX 渲染最终的 HTML。修改代码如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export async function htmlGenerator(url) {\n  let jsx = <Router url={url} />\n  const clientJSX = await renderJSXToClientJSX(jsx);\n  let html = await renderJSXToHTML(clientJSX);\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"优化二react-rendertostring",children:["优化二：React renderToString",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化二react-rendertostring",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们自定义的 renderJSXToHTML 其实对应的就是 React 的 renderToString 函数，我们直接修改为使用 renderToString。修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"中的 htmlGenerator 函数代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { renderToString } from 'react-dom/server';\n\nexport async function htmlGenerator(url) {\n  let jsx = <Router url={url} />\n  const clientJSX = await renderJSXToClientJSX(jsx);\n  let html = await renderToString(clientJSX);\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"优化三服务拆分",children:["优化三：服务拆分",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化三服务拆分",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在优化一中，我们已经将组件运行和生成 HTML 解耦："}),"\n",(0,t.jsx)(n.p,{children:"首先，renderJSXToClientJSX 生成客户端 JSX 对象，再调用 renderToString 将客户端 JSX 转换为 HTML。"}),"\n",(0,t.jsx)(n.p,{children:"因为步骤相互独立，所以我们完全可以拆分为两个服务："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"server/rsc.js： 负责生成客户端 JSX 对象"}),"\n",(0,t.jsx)(n.li,{children:"server/ssr.js： 负责渲染 HTML"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"现在让我们开始修改代码吧。"}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"server/rsc.ts"})," 和 ",(0,t.jsx)(n.code,{children:"server.ssr.ts"}),"，为了能够同时运行，我们安装 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/concurrently",target:"_blank",rel:"noopener noreferrer",children:"concurrently"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm i concurrently\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"package.json"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "concurrently \\"npm run start:ssr\\" \\"npm run start:rsc\\"",\n    "start:rsc": "tsx watch ./server/rsc.ts",\n    "start:ssr": "tsx watch ./server/ssr.ts"\n  }\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["其中",(0,t.jsx)(n.code,{children:"server/rsc.ts"}),"代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { jsxGenerator } from "../generator";\n\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const clientJSXString = await jsxGenerator(url);\n  res.setHeader("Content-Type", "application/json");\n  res.end(clientJSXString);\n});\n\napp.listen(3001, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3001`);\n});\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"server/ssr.ts"}),"代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { readFile } from "fs/promises";\nimport { renderToString } from "react-dom/server";\nimport { parseJSX } from "../utils";\n\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n\n  // client.js\n  if (url.pathname === "/client.js") {\n    const content = await readFile("./client.js", "utf8");\n    res.setHeader("Content-Type", "text/javascript");\n    res.end(content);\n    return;\n  }\n\n  // 获取客户端 JSX 对象\n  const response = await fetch("http://127.0.0.1:3001" + url.pathname);\n\n  if (!response.ok) {\n    res.statusCode = response.status;\n    res.end();\n    return;\n  }\n\n  const clientJSXString = await response.text();\n\n  // 获取客户端 JSX 对象\n  if (url.searchParams.has("jsx")) {\n    res.setHeader("Content-Type", "application/json");\n    res.end(clientJSXString);\n  }\n  // 获取 HTML\n  else {\n    const clientJSX = JSON.parse(clientJSXString, parseJSX);\n    let html = renderToString(clientJSX);\n\n    html += `<script>window.__INITIAL_CLIENT_JSX_STRING__ = `;\n    html += JSON.stringify(clientJSXString).replace(/</g, "\\\\u003c");\n    html += `<\/script>`;\n    html += `\n      <script type="importmap">\n        {\n          "imports": {\n            "react": "https://esm.sh/react@18.2.0",\n            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"\n          }\n        }\n      <\/script>\n      <script type="module" src="/client.js"><\/script>\n    `;\n\n    res.setHeader("Content-Type", "text/html");\n    res.end(html);\n  }\n});\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"utils.js"}),"新增 parseJSX 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export function parseJSX(key, value) {\n  if (value === "$RE") {\n    return Symbol.for("react.element");\n  } else if (typeof value === "string" && value.startsWith("$$")) {\n    return value.slice(1);\n  } else {\n    return value;\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["运行 ",(0,t.jsx)(n.code,{children:"npm start"}),"，此时效果应该是不变的："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"react-rsc-7.gif"})}),"\n",(0,t.jsxs)(n.h2,{id:"原理解析",children:["原理解析",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原理解析",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-原理图",children:["1. 原理图",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-原理图",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"现在让我们重新看下实现的原理。当页面初始加载时："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["当用户访问 ",(0,t.jsx)(n.code,{children:"/"})," 的时候，请求首先会到 SSR server 上，然后 SSR server 请求 RSC server，RSC server 返回 ",(0,t.jsx)(n.code,{children:"/"}),"的 React 树，SSR server 获取到 React 树后，会根据 React 树渲染 HTML，最后将 HMTL 返回给用户。"]}),"\n",(0,t.jsx)(n.p,{children:"当后续发生导航时："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["当用户发生导航行为时，客户端会拦截浏览器的默认跳转，改为客户端请求目标路径的数据。请求首先会到 SSR server，SSR server 根据其中的 ?jsx 参数判断出是获取客户端 JSX 对象，然后请求 RSC server，SC server 返回 ",(0,t.jsx)(n.code,{children:"/"}),"的 React 树，SSR server 获取到 React 树后，将 React 树返回给客户端，客户端根据 React 树修改 DOM。"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-理解-nextjs-组件渲染原理",children:["2. 理解 Next.js 组件渲染原理",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-理解-nextjs-组件渲染原理",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["理解这个过程，有助于我们学习 Next.js。比如我们在 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-12",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | 服务端组件和客户端组件》"}),"讲到组件的渲染原理时："]}),"\n",(0,t.jsx)(n.p,{children:"在服务端："}),"\n",(0,t.jsx)(n.p,{children:"Next.js 使用 React API 编排渲染，渲染工作会根据路由和 Suspense 拆分成多个块（chunks），每个块分两步进行渲染："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["React 将服务端组件渲染成一个特殊的数据格式称为 ",(0,t.jsx)(n.strong,{children:"React Server Component Payload (RSC Payload)"})]}),"\n",(0,t.jsx)(n.li,{children:"Next.js 使用 RSC Payload 和客户端组件代码在服务端渲染 HTML"}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"RSC payload 中包含如下这些信息："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"服务端组件的渲染结果"}),"\n",(0,t.jsx)(n.li,{children:"客户端组件占位符和引用文件"}),"\n",(0,t.jsx)(n.li,{children:"从服务端组件传给客户端组件的数据"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"在客户端："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"加载渲染的 HTML 快速展示一个非交互界面（Non-interactive UI）"}),"\n",(0,t.jsx)(n.li,{children:"RSC Payload 会被用于协调（reconcile）客户端和服务端组件树，并更新 DOM"}),"\n",(0,t.jsx)(n.li,{children:"JavaScript 代码被用于水合客户端组件，使应用程序具有交互性（Interactive UI）"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"你会发现，这个架构设计其实十分类似。不过目前客户端组件的实现还没有讲到，但单看服务端组件的部分，是不是对 Next.js 的实现有了更多的理解了？"}),"\n",(0,t.jsxs)(n.h3,{id:"3-理解-nextjs-缓存机制",children:["3. 理解 Next.js 缓存机制",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-理解-nextjs-缓存机制",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["此外，我们在",(0,t.jsx)(n.a,{href:"https://juejin.cn/editor/book/7307859898316881957/section/7309077169735958565",target:"_blank",rel:"noopener noreferrer",children:"《缓存篇 | Caching（上）》"}),"时讲到 Next.js 中的四种缓存机制："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"现在再看其中的 RenderToPayload 和 RenderToHTML 是不是似曾相识？"}),"\n",(0,t.jsx)(n.p,{children:"按照我们目前的实现方式，所谓“全路由缓存”，就是在服务端缓存目标路由的客户端 JSX 对象和 HTML。"}),"\n",(0,t.jsx)(n.p,{children:"在后续导航的时候，目标路由的客户端 JSX 对象会发送给客户端，客户端根据这个客户端 JSX 对象进行更新，所谓“路由缓存”，其实就是将返回的客户端 JSX 对象缓存在浏览器中。"}),"\n",(0,t.jsxs)(n.p,{children:["现在让我们顺手实现一下“路由缓存”。修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { hydrateRoot } from 'react-dom/client';\n\nlet currentPathname = window.location.pathname;\nconst root = hydrateRoot(document, getInitialClientJSX());\n\n// 客户端路由缓存\nlet clientJSXCache = {}\nclientJSXCache[currentPathname] = getInitialClientJSX()\n\nfunction getInitialClientJSX() {\n  const clientJSX = JSON.parse(window.__INITIAL_CLIENT_JSX_STRING__, parseJSX);\n  return clientJSX;\n}\n\nasync function navigate(pathname) {\n  currentPathname = pathname;\n\n  if (clientJSXCache[pathname]) {\n    root.render(clientJSXCache[pathname])\n    return\n  } else {\n    const clientJSX = await fetchClientJSX(pathname);\n    clientJSXCache[pathname] = clientJSX\n    if (pathname === currentPathname) {\n      root.render(clientJSX);\n    }\n  }\n}\n\n// 其他保持不变\n"})}),"\n",(0,t.jsx)(n.p,{children:"实现并不复杂。页面初始加载的时候，将页面的客户端 JSX 对象保存在缓存中。导航的时候，如果没有命中缓存，则触发请求，然后将返回的结果保存在缓存中，如果命中缓存，则直接缓存中的数据。"}),"\n",(0,t.jsx)(n.p,{children:"效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"react-rsc-12.gif"})}),"\n",(0,t.jsxs)(n.p,{children:["因为有了客户端路由缓存，所以只会触发一次 ",(0,t.jsx)(n.code,{children:"earth?jsx"}),"和 ",(0,t.jsx)(n.code,{children:"hello?jsx"}),"请求，后续点击的时候，使用的都是缓存中的数据。"]}),"\n",(0,t.jsx)(n.p,{children:"现在是不是对 Next.js 的缓存有了更加深入的理解了？"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：优化了 RSC 实现和实现客户端路由缓存"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-9",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-9"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F67.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20RSC%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"优化一：解决重复调用",id:"优化一解决重复调用",depth:2},{text:"优化二：React renderToString",id:"优化二react-rendertostring",depth:2},{text:"优化三：服务拆分",id:"优化三服务拆分",depth:2},{text:"原理解析",id:"原理解析",depth:2},{text:"1. 原理图",id:"1-原理图",depth:3},{text:"2. 理解 Next.js 组件渲染原理",id:"2-理解-nextjs-组件渲染原理",depth:3},{text:"3. 理解 Next.js 缓存机制",id:"3-理解-nextjs-缓存机制",depth:3}],title:"",headingTitle:"",frontmatter:{}}}}]);