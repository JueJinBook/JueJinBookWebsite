"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10449"],{718485:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var i=s(552676),r=s(740453);let c=s.p+"static/image/b66bdeb7cf2e489ebb93be35c9516872.ed7d8d36.webp",d=s.p+"static/image/ad1dd60da5f2416a55c112dc222cd373.2e471a16.webp",l=s.p+"static/image/c65eb92def5b68db8a683e28fa7a49bb.374d5b24.webp",t=s.p+"static/image/8cf1c0b59c8b7514e77e8a6bf3646e2e.8f26d466.webp",o=s.p+"static/image/1b234e6424513fc34daf48829a727f3b.9625c145.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",h3:"h3",img:"img",ul:"ul",h4:"h4",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"4样式方案在-vite-中接入现代化的-css-工程化方案",children:["4.样式方案：在 Vite 中接入现代化的 CSS 工程化方案",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4样式方案在-vite-中接入现代化的-css-工程化方案",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"上一小节，我们使用 Vite 初始化了一个 Web 项目，迈出了使用 Vite 的第一步。但在实际工作中，仅用 Vite 官方的脚手架项目是不够的，往往还需要考虑诸多的工程化因素，借助 Vite 本身的配置以及业界的各种生态，才能搭建一个名副其实的脚手架工程。"}),"\n",(0,i.jsxs)(n.p,{children:["那在接下来的几个小节内容中，我们将以",(0,i.jsx)(n.code,{children:"实战"}),"的方式逐个击破项目工程化的要素。你可以跟着我一起进行编码，从0搭建一个完整的 Vite 项目架构。不仅如此，在实战的过程中，你也会对 Vite 本身的功能有全面了解，能够熟练地将它应用到实际项目。"]}),"\n",(0,i.jsx)(n.p,{children:"样式方案是前端工程化离不开的一个话题，也是本节要具体探讨的内容。在最原始的开发阶段大家都是手写原生的 CSS，但原生 CSS 存在着诸多问题。本小节，我们通过引入现代的各种 CSS 样式方案，一起动手实践，让你学会如何在 Vite 中落地这些样式方案。"}),"\n",(0,i.jsxs)(n.h2,{id:"样式方案的意义",children:["样式方案的意义",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#样式方案的意义",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"对初学者来说，谈到开发前端的样式，首先想到的便是直接写原生 CSS。但时间一长，难免会发现原生 CSS 开发的各种问题。那么，如果我们不用任何 CSS 工程方案，又会出现哪些问题呢？"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"开发体验"}),"欠佳。比如原生 CSS 不支持选择器的嵌套:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"// 选择器只能平铺，不能嵌套\n.container .header .nav .title .text {\n  color: blue;\n}\n\n.container .header .nav .box {\n  color: blue;\n  border: 1px solid grey;\n}\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"样式污染"}),"问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染。"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// a.css\n.container {\n  color: red;\n}\n\n// b.css\n// 很有可能覆盖 a.css 的样式！\n.container {\n  color: blue;\n}\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"浏览器兼容"}),"问题。为了兼容不同的浏览器，我们需要对一些属性(如",(0,i.jsx)(n.code,{children:"transition"}),")加上不同的浏览器前缀，比如 ",(0,i.jsx)(n.code,{children:"-webkit-"}),"、",(0,i.jsx)(n.code,{children:"-moz-"}),"、",(0,i.jsx)(n.code,{children:"-ms-"}),"、",(0,i.jsx)(n.code,{children:"-o-"}),"，意味着开发者要针对同一个样式属性写很多的冗余代码。"]}),"\n",(0,i.jsxs)(n.li,{children:["打包后的",(0,i.jsx)(n.strong,{children:"代码体积"}),"问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类。"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CSS 预处理器"}),"：主流的包括",(0,i.jsx)(n.code,{children:"Sass/Scss"}),"、",(0,i.jsx)(n.code,{children:"Less"}),"和",(0,i.jsx)(n.code,{children:"Stylus"}),"。这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的",(0,i.jsx)(n.strong,{children:"开发体验问题"}),"。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CSS Modules"}),"：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下",(0,i.jsx)(n.strong,{children:"样式污染"}),"的问题。"]}),"\n",(0,i.jsxs)(n.li,{children:["CSS 后处理器",(0,i.jsx)(n.code,{children:"PostCSS"}),"，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 ",(0,i.jsx)(n.code,{children:"px"})," 转换为 ",(0,i.jsx)(n.code,{children:"rem"}),"、根据目标浏览器情况自动加上类似于",(0,i.jsx)(n.code,{children:"--moz--"}),"、",(0,i.jsx)(n.code,{children:"-o-"}),"的属性前缀等等。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CSS in JS"})," 方案，主流的包括",(0,i.jsx)(n.code,{children:"emotion"}),"、",(0,i.jsx)(n.code,{children:"styled-components"}),"等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含",(0,i.jsx)(n.code,{children:"CSS 预处理器"}),"和 ",(0,i.jsx)(n.code,{children:"CSS Modules"})," 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题。"]}),"\n",(0,i.jsxs)(n.li,{children:["CSS 原子化框架，如",(0,i.jsx)(n.code,{children:"Tailwind CSS"}),"、",(0,i.jsx)(n.code,{children:"Windi CSS"}),"，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS ",(0,i.jsx)(n.strong,{children:"开发体验"}),"的问题。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"不过，各种方案没有孰优孰劣，各自解决的方案有重叠的部分，但也有一定的差异，大家可以根据自己项目的痛点来引入。接下来，我们进入实战阶段，在 Vite 中应用上述常见的 CSS 方案。"}),"\n",(0,i.jsxs)(n.h3,{id:"css-预处理器",children:["CSS 预处理器",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-预处理器",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Vite 本身对 CSS 各种预处理器语言(",(0,i.jsx)(n.code,{children:"Sass/Scss"}),"、",(0,i.jsx)(n.code,{children:"Less"}),"和",(0,i.jsx)(n.code,{children:"Stylus"}),")做了内置支持。也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。我们以 ",(0,i.jsx)(n.code,{children:"Sass/Scss"})," 为例，来具体感受一下 Vite 的",(0,i.jsx)(n.code,{children:"零配置"}),"给我们带来的便利。"]}),"\n",(0,i.jsx)(n.p,{children:"由于 Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装。因此，我们首先安装 Sass 的官方库，安装命令如下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pnpm i sass -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后，在上一节初始化后的项目中新建 ",(0,i.jsx)(n.code,{children:"src/components/Header"})," 目录，并且分别新建",(0,i.jsx)(n.code,{children:"index.tsx"})," 和 ",(0,i.jsx)(n.code,{children:"index.scss"}),"文件，代码如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// index.tsx\nimport './index.scss';\nexport function Header() {\n  return <p className=\"header\">This is Header</p>\n};\n\n// index.scss\n.header {\n  color: red;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样就完成了一个最简单的 demo 组件。接着我们在 ",(0,i.jsx)(n.code,{children:"App.tsx"})," 应用这个组件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { Header } from "./components/Header";\n\nfunction App() {\n  return (\n    <div>\n      <Header />\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["现在你可以执行",(0,i.jsx)(n.code,{children:"pnpm run dev"}),"，然后到浏览器上查看效果:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["内容比较简单，如果页面出现红色的文字部分，就说明 ",(0,i.jsx)(n.code,{children:"scss"})," 文件中的样式已经成功生效。好，现在我们封装一个全局的主题色，新建",(0,i.jsx)(n.code,{children:"src/variable.scss"}),"文件，内容如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scss",children:"// variable.scss\n$theme-color: red;\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后，我们在原来 Header 组件的样式中应用这个变量:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scss",children:'@import "../../variable";\n\n.header {\n  color: $theme-color;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["回到浏览器访问页面，可以看到样式依然生效。你可能会注意到，每次要使用",(0,i.jsx)(n.code,{children:"$theme-color"}),"属性的时候我们都需要手动引入",(0,i.jsx)(n.code,{children:"variable.scss"}),"文件，那有没有自动引入的方案呢？这就需要在 Vite 中进行一些自定义配置了，在配置文件中增加如下的内容:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport { normalizePath } from 'vite';\n// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D\nimport path from 'path';\n\n// 全局 scss 文件的路径\n// 用 normalizePath 解决 window 下的路径问题\nconst variablePath = normalizePath(path.resolve('./src/variable.scss'));\n\n\nexport default defineConfig({\n  // css 相关的配置\n  css: {\n    preprocessorOptions: {\n      scss: {\n        // additionalData 的内容会在每个 scss 文件的开头自动注入\n        additionalData: `@import \"${variablePath}\";`\n      }\n    }\n  }\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在你可以直接在文件中使用全局文件的变量，相当于之前手动引入的方式显然方便了许多:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scss",children:".header {\n  color: $theme-color;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["同样的，你可以对 ",(0,i.jsx)(n.code,{children:"less"}),"和",(0,i.jsx)(n.code,{children:"stylus"}),"进行一些能力的配置，如果有需要你可以去下面的官方文档中查阅更多的配置项:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://sass-lang.com/documentation/js-api/modules#render",target:"_blank",rel:"noopener noreferrer",children:"Sass"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://lesscss.org/usage/#less-options",target:"_blank",rel:"noopener noreferrer",children:"Less"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://stylus-lang.com/docs/js.html",target:"_blank",rel:"noopener noreferrer",children:"Stylus"})}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"css-modules",children:["CSS Modules",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-modules",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有",(0,i.jsx)(n.code,{children:".module"}),"的样式文件自动应用 CSS Modules。接下来我们通过一个简单的例子来使用这个功能。"]}),"\n",(0,i.jsxs)(n.p,{children:["首先，将 Header 组件中的",(0,i.jsx)(n.code,{children:"index.scss"}),"更名为",(0,i.jsx)(n.code,{children:"index.module.scss"}),"，然后稍微改动一下",(0,i.jsx)(n.code,{children:"index.tsx"}),"的内容，如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// index.tsx\nimport styles from './index.module.scss';\nexport function Header() {\n  return <p className={styles.header}>This is Header</p>\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在打开浏览器，可以看见 p 标签的类名已经被处理成了哈希值的形式:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["说明现在 CSS Modules 已经正式生效了！同样的，你也可以在配置文件中的",(0,i.jsx)(n.code,{children:"css.modules"}),"选项来配置 CSS Modules 的功能，比如下面这个例子:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// vite.config.ts\nexport default {\n  css: {\n    modules: {\n      // 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义\n      // 其中，name 表示当前文件名，local 表示类名\n      generateScopedName: "[name]__[local]___[hash:base64:5]"\n    },\n    preprocessorOptions: {\n      // 省略预处理器配置\n    }\n\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"再次访问页面，我们可以发现刚才的类名已经变成了我们自定义的形式:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["这是一个 CSS Modules 中很常见的配置，对开发时的调试非常有用。其它的一些配置项不太常用，大家可以去这个",(0,i.jsx)(n.a,{href:"https://github.com/madyankin/postcss-modules",target:"_blank",rel:"noopener noreferrer",children:"地址"}),"进行查阅。"]}),"\n",(0,i.jsxs)(n.h3,{id:"postcss",children:["PostCSS",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#postcss",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["一般你可以通过 ",(0,i.jsx)(n.code,{children:"postcss.config.js"})," 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口，我们可以直接在 Vite 配置文件中进行操作。"]}),"\n",(0,i.jsxs)(n.p,{children:["首先，我们来安装一个常用的 PostCSS 插件——",(0,i.jsx)(n.code,{children:"autoprefixer"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pnpm i autoprefixer -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"这个插件主要用来自动为不同的目标浏览器添加样式前缀，解决的是浏览器兼容性的问题。接下来让我们在 Vite 中接入这个插件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts 增加如下的配置\nimport autoprefixer from 'autoprefixer';\n\nexport default {\n  css: {\n    // 进行 PostCSS 配置\n    postcss: {\n      plugins: [\n        autoprefixer({\n          // 指定目标浏览器\n          overrideBrowserslist: ['Chrome > 40', 'ff > 31', 'ie 11']\n        })\n      ]\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"配置完成后，我们回到 Header 组件的样式文件中添加一个新的 CSS 属性:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".header {\n  \x3c!-- 前面的样式省略 --\x3e\n  text-decoration: dashed;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["你可以执行",(0,i.jsx)(n.code,{children:"pnpm run build"}),"命令进行打包，可以看到产物中自动补上了浏览器前缀，如:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"._header_kcvt0_1 {\n  \x3c!-- 前面的样式省略 --\x3e\n  -webkit-text-decoration: dashed;\n  -moz-text-decoration: dashed;\n  text-decoration: dashed;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["由于有 CSS 代码的 AST (抽象语法树)解析能力，PostCSS 可以做的事情非常多，甚至能实现 CSS 预处理器语法和 CSS Modules，社区当中也有不少的 PostCSS 插件，除了刚刚提到的",(0,i.jsx)(n.code,{children:"autoprefixer"}),"插件，常见的插件还包括:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/cuth/postcss-pxtorem",target:"_blank",rel:"noopener noreferrer",children:"postcss-pxtorem"}),"： 用来将 px 转换为 rem 单位，在适配移动端的场景下很常用。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/csstools/postcss-preset-env",target:"_blank",rel:"noopener noreferrer",children:"postcss-preset-env"}),": 通过它，你可以编写最新的 CSS 语法，不用担心兼容性问题。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/cssnano/cssnano",target:"_blank",rel:"noopener noreferrer",children:"cssnano"}),": 主要用来压缩 CSS 代码，跟常规的代码压缩工具不一样，它能做得更加智能，比如提取一些公共样式进行复用、缩短一些常见的属性值等等。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["关于 PostCSS 插件，这里还给大家推荐一个站点：",(0,i.jsx)(n.a,{href:"https://www.postcss.parts/",target:"_blank",rel:"noopener noreferrer",children:"https://www.postcss.parts/"})," ，你可以去里面探索更多的内容。"]}),"\n",(0,i.jsxs)(n.h3,{id:"css-in-js",children:["CSS In JS",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-in-js",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["社区中有两款主流的",(0,i.jsx)(n.code,{children:"CSS In JS"})," 方案: ",(0,i.jsx)(n.code,{children:"styled-components"}),"和",(0,i.jsx)(n.code,{children:"emotion"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["对于 CSS In JS 方案，在构建侧我们需要考虑",(0,i.jsx)(n.code,{children:"选择器命名问题"}),"、",(0,i.jsx)(n.code,{children:"DCE"}),"(Dead Code Elimination 即无用代码删除)、",(0,i.jsx)(n.code,{children:"代码压缩"}),"、",(0,i.jsx)(n.code,{children:"生成 SourceMap"}),"、",(0,i.jsx)(n.code,{children:"服务端渲染(SSR)"}),"等问题，而",(0,i.jsx)(n.code,{children:"styled-components"}),"和",(0,i.jsx)(n.code,{children:"emotion"}),"已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件。"]}),"\n",(0,i.jsx)(n.p,{children:"具体来说，上述的两种主流 CSS in JS 方案在 Vite 中集成方式如下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// vite.config.ts\nimport { defineConfig } from \'vite\'\nimport react from \'@vitejs/plugin-react\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        // 加入 babel 插件\n        // 以下插件包都需要提前安装\n        // 当然，通过这个配置你也可以添加其它的 Babel 插件\n        plugins: [\n          // 适配 styled-component\n          "babel-plugin-styled-components"\n          // 适配 emotion\n          "@emotion/babel-plugin"\n        ]\n      },\n      // 注意: 对于 emotion，需要单独加上这个配置\n      // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法\n      jsxImportSource: "@emotion/react"\n    })\n  ]\n})\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"css-原子化框架",children:["CSS 原子化框架",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-原子化框架",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在目前的社区当中，CSS 原子化框架主要包括",(0,i.jsx)(n.code,{children:"Tailwind CSS"})," 和 ",(0,i.jsx)(n.code,{children:"Windi CSS"}),"。Windi CSS 作为前者的替换方案，实现了按需生成 CSS 类名的功能，开发环境下的 CSS 产物体积大大减少，速度上比",(0,i.jsx)(n.code,{children:"Tailwind CSS v2"}),"快 20~100 倍！当然，Tailwind CSS 在 v3 版本也引入 ",(0,i.jsx)(n.a,{href:"https://v2.tailwindcss.com/docs/just-in-time-mode",target:"_blank",rel:"noopener noreferrer",children:"JIT(即时编译)"})," 的功能，解决了开发环境下 CSS 产物体积庞大的问题。接下来我们将这两个方案分别接入到 Vite 中，在实际的项目中你只需要使用其中一种就可以了。我个人比较喜欢 Windi CSS 本身的",(0,i.jsx)(n.code,{children:"attributify"}),"、",(0,i.jsx)(n.code,{children:"shortcuts"}),"等独有的特性，因此首先从 windicss 开始说起。"]}),"\n",(0,i.jsxs)(n.h4,{id:"1-windi-css-接入",children:["1. Windi CSS 接入",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-windi-css-接入",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["首先安装 ",(0,i.jsx)(n.code,{children:"windicss"})," 及对应的 Vite 插件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"pnpm i windicss vite-plugin-windicss -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"随后我们在配置文件中来使用它:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// vite.config.ts\nimport windi from "vite-plugin-windicss";\n\nexport default {\n  plugins: [\n    // 省略其它插件\n    windi()\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["接着要注意在",(0,i.jsx)(n.code,{children:"src/main.tsx"}),"中引入一个必需的 import 语句:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// main.tsx\n// 用来注入 Windi CSS 所需的样式，一定要加上！\nimport "virtual:windi.css";\n'})}),"\n",(0,i.jsx)(n.p,{children:"这样我们就完成了 Windi CSS 在 Vite 中的接入，接下来我们在 Header 组件中来测试，组件代码修改如下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'// src/components/Header/index.tsx\nimport { devDependencies } from "../../../package.json";\n\nexport function Header() {\n  return (\n    <div className="p-20px text-center">\n      <h1 className="font-bold text-2xl mb-2">\n        vite version: {devDependencies.vite}\n      </h1>\n    </div>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"启动项目可以看到如下的效果，说明样式已经正常生效:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["除了本身的原子化 CSS 能力，Windi CSS 还有一些非常好用的高级功能，在此我给大家推荐自己常用的两个能力: ",(0,i.jsx)(n.strong,{children:"attributify"})," 和 ",(0,i.jsx)(n.strong,{children:"shortcuts"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["要开启这两个功能，我们需要在项目根目录新建",(0,i.jsx)(n.code,{children:"windi.config.ts"}),"，配置如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { defineConfig } from "vite-plugin-windicss";\n\nexport default defineConfig({\n  // 开启 attributify\n  attributify: true,\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["首先我们来看看",(0,i.jsx)(n.code,{children:"attributify"}),"，翻译过来就是",(0,i.jsx)(n.code,{children:"属性化"}),"，也就是说我们可以用 props 的方式去定义样式属性，如下所示:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<button \n  bg="blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600"\n  text="sm white"\n  font="mono light"\n  p="y-2 x-4"\n  border="2 rounded blue-200"\n>\n  Button\n</button>\n'})}),"\n",(0,i.jsx)(n.p,{children:"这样的开发方式不仅省去了繁琐的 className 内容，还加强了语义化，让代码更易维护，大大提升了开发体验。"}),"\n",(0,i.jsxs)(n.p,{children:["不过使用",(0,i.jsx)(n.code,{children:"attributify"}),"的时候需要注意类型问题，你需要添加",(0,i.jsx)(n.code,{children:"types/shim.d.ts"}),"来增加类型声明，以防类型报错:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { AttributifyAttributes } from 'windicss/types/jsx';\n\ndeclare module 'react' {\n  type HTMLAttributes<T> = AttributifyAttributes;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"shortcuts"})," 用来封装一系列的原子化能力，尤其是一些常见的类名集合，我们在 ",(0,i.jsx)(n.code,{children:"windi.config.ts"}),"来配置它:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'//windi.config.ts\nimport { defineConfig } from "vite-plugin-windicss";\n\nexport default defineConfig({\n  attributify: true,\n  shortcuts: {\n    "flex-c": "flex justify-center items-center",\n  }\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["比如这里封装了",(0,i.jsx)(n.code,{children:"flex-c"}),"的类名，接下来我们可以在业务代码直接使用这个类名:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-HTML",children:'<div className="flex-c"></div>\n\x3c!-- 等同于下面这段 --\x3e\n<div className="flex justify-center items-center"></div>\n'})}),"\n",(0,i.jsx)(n.p,{children:"如果你也有过 Windi CSS 的开发经历，欢迎把你用到的高级功能分享到评论区，让大家一起来见识见识。"}),"\n",(0,i.jsxs)(n.h4,{id:"2-tailwind-css",children:["2. Tailwind CSS",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-tailwind-css",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来我们来接入 Tailwind CSS 方案，为了避免和之前的 Windi CSS 混淆，这里我建议你新起一个 Vite 项目。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["小册中对应的 GitHub ",(0,i.jsx)(n.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/other/tailwind-demo",target:"_blank",rel:"noopener noreferrer",children:"代码地址"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["首先安装 ",(0,i.jsx)(n.code,{children:"tailwindcss"})," 及其必要的依赖:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm install -D tailwindcss postcss autoprefixer\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后新建两个配置文件",(0,i.jsx)(n.code,{children:"tailwind.config.js"}),"和",(0,i.jsx)(n.code,{children:"postcss.config.js"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// tailwind.config.js\nmodule.exports = {\n  content: [\n    "./index.html",\n    "./src/**/*.{vue,js,ts,jsx,tsx}",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n// postcss.config.js\n// 从中你可以看到，Tailwind CSS 的编译能力是通过 PostCSS 插件实现的\n// 而 Vite 本身内置了 PostCSS，因此可以通过 PostCSS 配置接入 Tailwind CSS \n// 注意: Vite 配置文件中如果有 PostCSS 配置的情况下会覆盖掉 post.config.js 的内容!\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"接着在项目的入口 CSS 中引入必要的样板代码:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在，你就可以在项目中安心地使用 Tailwind 样式了，如下所示:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// App.tsx\n\nimport logo from "./logo.svg";\nimport "./App.css";\n\nfunction App() {\n  return (\n    <div>\n      <header className="App-header">\n        <img src={logo} className="w-20" alt="logo" />\n        <p className="bg-red-400">Hello Vite + React!</p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,i.jsx)(n.p,{children:"当你启动项目之后可以看到 Tailwind CSS 的样式已经正常生效:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["OK，本小节的内容到这里就结束了。这一节我们完成了脚手架项目样式部分的搭建，你需要重点掌握前端工程中各种样式方案在 Vite 的接入方法。这些样式方案包括，包括",(0,i.jsx)(n.code,{children:"CSS 预处理器"}),"、",(0,i.jsx)(n.code,{children:"CSS Modules"}),"、",(0,i.jsx)(n.code,{children:"PostCSS"}),"、",(0,i.jsx)(n.code,{children:"CSS In JS"}),"和 ",(0,i.jsx)(n.code,{children:"CSS 原子化框架(Windi CSS)"}),"。与此同时，你应该明白了各种样式方案的含义以及背后所解决的问题。接下来，我们将会进入项目规范搭建的部分，让我们下一节再见！"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F4.%E6%A0%B7%E5%BC%8F%E6%96%B9%E6%A1%88%EF%BC%9A%E5%9C%A8%20Vite%20%E4%B8%AD%E6%8E%A5%E5%85%A5%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%20CSS%20%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%96%B9%E6%A1%88.md"]={toc:[{text:"样式方案的意义",id:"样式方案的意义",depth:2},{text:"CSS 预处理器",id:"css-预处理器",depth:3},{text:"CSS Modules",id:"css-modules",depth:3},{text:"PostCSS",id:"postcss",depth:3},{text:"CSS In JS",id:"css-in-js",depth:3},{text:"CSS 原子化框架",id:"css-原子化框架",depth:3},{text:"1. Windi CSS 接入",id:"1-windi-css-接入",depth:4},{text:"2. Tailwind CSS",id:"2-tailwind-css",depth:4},{text:"小结",id:"小结",depth:2}],title:"4.样式方案：在 Vite 中接入现代化的 CSS 工程化方案",headingTitle:"4.样式方案：在 Vite 中接入现代化的 CSS 工程化方案",frontmatter:{}}}}]);