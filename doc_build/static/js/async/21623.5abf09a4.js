"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21623"],{474189:function(n,e,c){c.r(e),c.d(e,{default:()=>u});var r=c(552676),i=c(740453);let s=c.p+"static/image/5402fa02d2c64f3753aada694aeb3d2b.50a14daa.webp",l=c.p+"static/image/0830e256825f8db877f1a8882d902c50.0f0b94e3.webp",a=c.p+"static/image/f2255f44df8c7a7e4a0df83a729b76a7.51b53c0a.webp",h=c.p+"static/image/867c2da554aa2b062323fba5351d94d5.085ca94f.webp",d=c.p+"static/image/285c9a209171bad17daf1a641a267e83.da29d619.webp",t=c.p+"static/image/e14145029af9c9476766ecf1085c4ac3.efab2a93.webp",x=c.p+"static/image/a896a1b20ceecaa93fcd1a1601ab3eb2.dd711f52.webp",j=c.p+"static/image/5dc2a52bf7150e7c82bce42dacc423f0.e2822f7f.webp",p=c.p+"static/image/77f22a63d63f55a6c9a13077fe990aaf.e0bb67f0.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",em:"em",h2:"h2",blockquote:"blockquote",pre:"pre",code:"code",img:"img",ul:"ul",li:"li"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"17性能保障如何对官网应用进行上线前压力测试",children:["17.性能保障：如何对官网应用进行上线前压力测试？",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17性能保障如何对官网应用进行上线前压力测试",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在实际的开发中，我们会用一些集群服务器进行服务的部署，在不同的公司，这些环境可能被称为预发布环境或是泳道等。"}),"\n",(0,r.jsx)(e.p,{children:"通常在上线前，我们会对这些小流量环境进行预估流量的压测，来预估目前的小流量集群服务器能否承载对应的流量，进而评估一下，我们使用多少服务器集群部署服务，才能足够承载流量，又不至于浪费服务器资源。"}),"\n",(0,r.jsx)(e.p,{children:"在字节内部，我们有一套闭环的压测链路解决方案，来保证整个流程的维稳，但是有一些小公司或是个体团队的同学可能并没有压测等平台，也没有专业的测开同学可以协助进行分析集群分析，有没有什么 MVP 的方案可以进行简单快捷的方式进行压测，又可以得到我们需要的数据呢？"}),"\n",(0,r.jsx)(e.p,{children:"通常针对并发的压测，业内推荐的方案大部分是 Jmeter，它是一款基于 Java 实现，支持接口并发、模拟协议请求等能力的测试工具。不过本节课我们不使用 Jmeter 来进行压测，一方面它安装上不够轻量，因为基于 Java 实现，所以我们需要配置 Java 的环境变量；另一方面，Jmeter 提供了很多额外的能力，包括功能测试和回归测试等，我们这节课的核心需求是对官网应用“并发量”进行判定，这些功能我们都是用不上的。"}),"\n",(0,r.jsxs)(e.p,{children:["我们来对比一下三个常见的开源方案，都是比较轻量且适合开发使用的压测工具，需要注意的是，本节课的压测是基于本地服务压测，",(0,r.jsx)(e.strong,{children:"对于实际上线，需要先部署在测试服务器，然后对测试环境内网域名进行压测，进而判断能否承受预估的QPS，从而对服务集群进行扩容等操作。"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.em,{children:(0,r.jsxs)(e.strong,{children:["Ps：不清楚怎么部署的同学可以移步到",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7137945369635192836/section/7141558366945411083",target:"_blank",rel:"noopener noreferrer",children:"20 | 应用上线: 从官网服务域名的申请备案到服务部署"})]})})," ",(0,r.jsx)(e.em,{children:(0,r.jsx)(e.strong,{children:"进行学习。"})})]}),"\n",(0,r.jsxs)(e.h2,{id:"webbench",children:["WebBench",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#webbench",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/EZLippi/WebBench",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/EZLippi/WebBench"})}),"\n",(0,r.jsx)(e.p,{children:"Webbench是一个在 Linux 下使用的非常简单的网站压测工具。它使用 fork() 模拟多个客户端同时访问我们设定的 URL，测试网站在压力下工作的性能，最多可以模拟 3 万个并发连接去测试网站的负载能力。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"WebBench 不能支持 Windows，只能在 Linux 等类 UNIX 系统下使用，我们以 macOS 系统为例安装试试。"}),"\n",(0,r.jsx)(e.p,{children:"首先我们需要安装一下 brew，这是一个针对 macOS 和 Linux 的包管理工具，终端里直接执行下面的命令就好，很多使用 mac 系统的同学可能已经装过这个了，安装完在终端里直接输入 brew 看下有没有正常输出即可。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"\n'})}),"\n",(0,r.jsx)(e.p,{children:"然后我们装一下 wget，它是 Linux 下的一个安装文件的工具，对应的安装包我们可以通过它下载下来。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"brew install wget\n"})}),"\n",(0,r.jsx)(e.p,{children:"最后我们来装一下 WebBench。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"wget http://www.ha97.com/code/webbench-1.5.tar.gz\ntar zxvf webbench-1.5.tar.gz // 解压\ncd webbench-1.5\nmake\nmake install\n"})}),"\n",(0,r.jsx)(e.p,{children:"安装完以后，我们可以在终端中输入 WebBench 验证一下。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"我们需要关注的参数有两个："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-c: 并发量；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-t: 运行时间。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我们对我们的服务简单压测试验下看看。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到 200 并发，咱们本地服务是 hold 住的， 2000 并发就会出现大规模请求异常的情况，不过这个结果算比较简陋的，加上对环境和安装步骤上相对苛刻一些，所以我并不推荐大家使用这个方案。"}),"\n",(0,r.jsxs)(e.h2,{id:"wrk",children:["wrk",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#wrk",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/wg/wrk",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/wg/wrk"})}),"\n",(0,r.jsx)(e.p,{children:"wrk 是一款针对 HTTP 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll、kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"wrk 是一款轻量级的性能测试工具，支持大多数类 UNIX 系统，不支持 Windows。不同的类 UNIX 系统安装方式也略有差异，下面以 macOS 系统为例。"}),"\n",(0,r.jsx)(e.p,{children:"我们来装一下 wrk。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"brew install wrk\n"})}),"\n",(0,r.jsxs)(e.p,{children:["装完可以在终端执行一下 ",(0,r.jsx)(e.code,{children:"wrk -v"}),"验证一下。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"上面执行完以后我们可以看到它列出了 wrk相关的参数，其中我们常用到的有三个参数："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-c: 保持打开状态的 HTTP 连接总数；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-d: 测试时长；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-t: 使用线程。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"其中连接数（c）会平分给每个线程，比如设置 -c200 -t8，那么将启用 8 个线程，每个线程处理 200/8 个请求，我们可以对 bing 搜索简单试验一下，具体参数其实大部分都是一样的，我们在 autocannon 的部分统一介绍。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"其实，这个方案更多是给后端同学测吞吐率用的，包括线程等参数，具体的值不好衡量，对前端不算那么友好，感兴趣的同学可以下来试试看。"}),"\n",(0,r.jsxs)(e.h2,{id:"autocannon",children:["autocannon",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#autocannon",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/mcollina/autocannon",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mcollina/autocannon"})}),"\n",(0,r.jsx)(e.p,{children:"一个用 Node 编写的 HTTP/1.1 基准测试工具，受到 wrk 和 wrk2 的极大启发，支持 HTTP 管道和 HTTPS。autocannon 可以产生比 wrk 和 wrk2 更多的负载。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"autocannon 是用 Node 编写的 HTTP/1.1 基准测试工具，它可以同时支持 Windows、 Mac 和 Linux 的 环境，而且作为 一个 npm 包，使用上比较符合前端的开发习惯，安装更为方便，使用方式也很轻量，很推荐大家使用这种方式。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"npm i autocannon -g\n"})}),"\n",(0,r.jsx)(e.p,{children:"Autocannon 有提供一些参数来对应不同压测指数，我们常用的有 3 个："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-c: 要使用的并发连接数。默认值：10 ；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-p: 使用流水线请求的数量。默认值：1 ；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"-d: 运行秒数。默认值：10 。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"同样，我们来对我们的服务做一个简单尝试，首先测试一下默认值的效果。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"autocannon http://127.0.0.1:3000\n"})}),"\n",(0,r.jsx)(e.p,{children:"在这个 10s 的执行过程，我们如果切回 nextjs-demo 是可以看到我们的服务在飞快请求的。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"dffa36a3-bfcb-422f-8de4-8cebab33d848.gif"})}),"\n",(0,r.jsx)(e.p,{children:"最后我们可以得到这样一个数据。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"这个表格怎么看呢，我给大家介绍一下每个指标对应啥，我们先看每列的指标："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"2.5% / 50% / 97.5% / 99%：整个过程百分比所对应的值；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Avg: 平均值；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Stdev: 标准差；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Max: 最大值。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"对于每行的指标含义是这样的："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Latency: 耗时(毫秒)；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Req/Sec: QPS，吞吐量，每秒请求数；"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Bytes/Sec: 每秒请求字节数。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这些指标通常在对具体接口或是页面 case by case 的性能分析中会有使用，服务器资源判定我们只需要关注请求时间是否过长，或是是否存在大面积报错即可，这里我们可以看到大部分数值是正常的，也没有报错等信息。"}),"\n",(0,r.jsx)(e.p,{children:"接下来我们把并发量提高到 200， 再来看下效果，可以看到我们的服务仍然是可以 hold 住的。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"autocannon -c 200 http://127.0.0.1:3000\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们把并发量提高到 2000，再看看会得到怎样的结果。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"从数据上看，我们发现所有的数据都清 0 了，说明在这个并发量下单服务器的计算支撑不下去，最下面的请求数据中也有显示 3k 个错误， 2k 个超时。"}),"\n",(0,r.jsx)(e.p,{children:"这时候我们切回 nextjs-demo 的终端可以看到，我们的服务已经崩掉了，没办法承载 2000 的并发量，如果业务需要，这时候就需要考虑给服务器集群进行扩容操作了。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"这节课我们学习了怎么对官网应用进行上线前压测，通常大公司可能会有自己的一套压测解决方案，对于没有压测资源的同学可以采用一些轻量的开源工具来对服务进行压力测试。"}),"\n",(0,r.jsx)(e.p,{children:"我们对比了 WebBench、 wrk、 autocannon 三种开源方案，其中 WebBench 和 wrk 只能用于 Linux 环境，而且压测的信息和配置不够轻量，相比之下，我更推荐大家使用 autocannon 的方案，它基于 nodejs 开发，具备更符合我们开发习惯的配置和使用方式。"}),"\n",(0,r.jsx)(e.p,{children:"我们通过 autocannon 对服务进行了多个并发量的压测对比，分析出在 2000 并发下，我们的服务是支撑不住的，需要通过集群扩容等方式支持。"}),"\n",(0,r.jsx)(e.p,{children:"目前我们还只是对本地服务进行测试，正常的上线流程中，大家需要先去申请测试服务器的资源，在测试服务器上压测评估后再部署线上服务器。"}),"\n",(0,r.jsx)(e.p,{children:"我们的官网在上线后，常常需要取用户操作的数据进行 pv 等相关分析，这时候我们就需要进行一些基础的数据埋点，并且进行统计分析，下节课我们就来学习如何对用户的数据进行上报分析。"})]})}function b(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(o,{...n})}):o(n)}let u=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["SSR%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%98%E7%BD%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F17.%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AF%B9%E5%AE%98%E7%BD%91%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E4%B8%8A%E7%BA%BF%E5%89%8D%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%EF%BC%9F.md"]={toc:[{text:"WebBench",id:"webbench",depth:2},{text:"wrk",id:"wrk",depth:2},{text:"autocannon",id:"autocannon",depth:2},{text:"小结",id:"小结",depth:2}],title:"17.性能保障：如何对官网应用进行上线前压力测试？",headingTitle:"17.性能保障：如何对官网应用进行上线前压力测试？",frontmatter:{}}}}]);