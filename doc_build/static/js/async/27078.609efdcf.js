"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27078"],{695291:function(n,e,i){i.r(e),i.d(e,{default:()=>c});var r=i(552676),s=i(740453);let l=i.p+"static/image/d00d875072b0fd5678e6bb0fc4d352f7.3d8b04d3.png";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"3方案了解引言",children:["3.方案了解：引言",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3方案了解引言",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在上节课程中我们讲过，微前端的本质是降低大型复杂应用的开发、升级、维护和团队协作成本。假设在团队协作的过程中，各个团队使用了不同的技术栈进行应用开发，如果不进行应用拆分解耦，势必需要通过迁移和改造来兼容整个单体应用。"}),"\n",(0,r.jsx)(e.p,{children:"如果能实现应用拆分，就可以使得各个团队的应用保持独立自治，不会互相依赖彼此，也不需要在单体应用中进行技术栈的迁移和改造，极大的减少各个团队的开发、升级和维护成本。那么如何实现应用拆分呢？"}),"\n",(0,r.jsxs)(e.h2,{id:"微前端的特性",children:["微前端的特性",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#微前端的特性",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为了使整个单体应用可以根据不同的业务进行解耦，微前端会将单个应用拆分成多个聚合在一起的小型应用，这些应用具备独立开发、独立部署和独立运行的特性。"}),"\n",(0,r.jsx)(e.p,{children:"在聚合的过程中需要一个容器应用（在微前端里称作主应用），主应用通过设计导航将各个拆分的小型应用（在微前端里称作微应用）聚合在一起，可以根据导航进行微应用的切换。具体如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"主应用的导航可以是前端框架（React 或 Vue 框架）的路由，也可以是后端服务路由，还可以是前端自己设计的切换逻辑："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如果主应用是 SPA 应用，此时导航是路由跳转，根据前端路由进行微应用切换；"}),"\n",(0,r.jsx)(e.li,{children:"如果主应用是 MPA 应用，此时导航是链接跳转，根据后端路由进行微应用切换；"}),"\n",(0,r.jsx)(e.li,{children:"SPA 和 MPA 应用都可以通过其他方式来切换微应用，例如动态切换微应用的 Script"}),"\n",(0,r.jsx)(e.li,{children:"除此之外，复杂的业务场景还可以是上述几种方案的结合体"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["拆分的微应用需要具备",(0,r.jsx)(e.strong,{children:"独立开发、独立部署和独立运行的特性："})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["微应用可以采用不同的技术栈，支持",(0,r.jsx)(e.strong,{children:"独立开发；"})]}),"\n",(0,r.jsxs)(e.li,{children:["微应用可以单独部署到不同的服务器上，支持",(0,r.jsx)(e.strong,{children:"独立部署；"})]}),"\n",(0,r.jsxs)(e.li,{children:["微应用的运行可以不依赖其他微应用，支持",(0,r.jsx)(e.strong,{children:"独立运行。"})]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"微前端的方案有哪些",children:["微前端的方案有哪些？",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#微前端的方案有哪些",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在了解了微前端能解决哪些业务场景以及特性之后，我们可以根据项目的实际情况出发，选择合适的微前端方案。在实际开发项目的过程中，如果项目本身采用 SPA 模式进行开发，则可以通过以下方案进行微前端改造："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"基于 NPM 包的微前端：将微应用打包成独立的 NPM 包，然后在主应用中安装和使用；"}),"\n",(0,r.jsx)(e.li,{children:"基于代码分割的微前端：在主应用中使用懒加载技术，在运行时动态加载不同的微应用；"}),"\n",(0,r.jsx)(e.li,{children:"基于 Web Components 的微前端：将微应用封装成自定义组件，在主应用中注册使用；"}),"\n",(0,r.jsx)(e.li,{children:"基于 Module Federation 的微前端：借助 Webpack 5 的 Module Federation 实现微前端；"}),"\n",(0,r.jsx)(e.li,{children:"基于动态 Script 的微前端：在主应用中动态切换微应用的 Script 脚本来实现微前端；"}),"\n",(0,r.jsx)(e.li,{children:"基于 iframe 的微前端：在主应用中使用 iframe 标签来加载不同的微应用；"}),"\n",(0,r.jsx)(e.li,{children:"基于框架（JavaScript SDK）的微前端：使用 single-spa、qiankun、wujie 等通用框架。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"部分方案会要求微应用在主应用的构建时进行聚合，无法使微应用具备运行时的动态化能力（主应用具备线上动态新增、删除和修改微应用的能力），例如基于 NPM 包、代码分割、 传统 Web Components 和构建工具的微前端方案。而基于动态 Script 、iframe 和框架的微前端方案则可以在运行时做到动态化，例如上节课程讲解的安防管理后台系统采用的是 iframe 的方式来实现微应用聚合。"}),"\n",(0,r.jsx)(e.p,{children:"当然，一些方案还可以组合使用，例如在上节课中讲解的低代码管理后台案例，低代码的脚本可能难以在微前端框架中进行集成，因此可以采用基于框架和动态 Script 结合的微前端设计方案。"}),"\n",(0,r.jsx)(e.p,{children:"如果项目是在 MPA 的模式下，则前端应用可以天然做到小型应用的拆分，各自部署在相应的服务下，在主应用中通过服务端的路由来请求和渲染不同的微应用。当然服务端的设计方案非常多，如何实现微应用之间的通信和数据共享是需要考虑的一个重要问题。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：MPA 模式下后端的技术栈方案非常多，可以是单个服务框架，可以是多个不同的服务框架，还可以是微服务框架。不同路由的 HTTP 请求将被分发到对应的服务上，这些服务可能是 Niginx 反向代理后的服务、Nginx 部署的静态资源服务、CDN 服务以及对象存储服务等。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"采用 MPA 的模式设计微前端可以使前后端采用不同的技术框架来实现，从而解决更加宽泛的团队协作问题。同时这种方式对于整体框架的设计更加灵活多变，可以很好解决不同技术栈之间因为差异大而难以进行迁移和兼容的问题，是微前端架构中采用最多且也是最容易实现的方案。需要注意目前社区常见的微前端框架基本上都是倾向于使用 SPA 模式进行开发，主要解决的是前端应用自身的解耦问题，这个解耦的过程本身可能不涉及服务端的任何更改。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本小节主要讲解了微前端的特性，使大家对于微前端有一个感性的认知，同时粗略的介绍了实施微前端的几种方案，当然这些方案各自都有优缺点，需要根据实际项目出发去选择合适项目的设计方案，有时候甚至会因为项目过于复杂，需要组合使用其中的几种方案。在接下来的几个小节，会简单讲解几种微前端方案的实现原理和特点，从而帮助大家加深对于微前端的理解。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}let c=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F3.%E6%96%B9%E6%A1%88%E4%BA%86%E8%A7%A3%EF%BC%9A%E5%BC%95%E8%A8%80.md"]={toc:[{text:"微前端的特性",id:"微前端的特性",depth:2},{text:"微前端的方案有哪些？",id:"微前端的方案有哪些",depth:2},{text:"小结",id:"小结",depth:2}],title:"3.方案了解：引言",headingTitle:"3.方案了解：引言",frontmatter:{}}}}]);