"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["15156"],{161600:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var i=s(552676),c=s(740453);let d=s.p+"static/image/17fd122162f950edaffb25e5c76b6f2c.0c285776.webp",l=s.p+"static/image/c542b97073445f2f2bc95c65b093d672.f4c9dfe1.webp",r=s.p+"static/image/3a3d3e2ecf1eb3dab2fdbc5ceb92a73d.8f016b62.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",ol:"ol",li:"li",ul:"ul"},(0,c.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"7-基础6样式与布局bem的应用跨端兼容",children:["7 基础6：样式与布局、BEM的应用、跨端兼容",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-基础6样式与布局bem的应用跨端兼容",children:"#"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"测评不会撒谎，但测评的人会。—— Anonymous"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"这一章主要讲解 css 命名规范与 html 结构相结合的关系，并使用条件编译对应不同平台。"}),"\n",(0,i.jsx)(n.p,{children:"开始先讲一下 css 命名弊端。"}),"\n",(0,i.jsxs)(n.h2,{id:"css-命名弊端",children:["css 命名弊端",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-命名弊端",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"你是否有见过这样的代码？"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".top--left .left1-block_nav-liItem > li a{\n	\n}\n.gy-theme .bar-header .hy-nav .order-search .pull-down.active .select-drop {\n    display: block\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上面的代码风格各异的使用了 ",(0,i.jsx)(n.code,{children:"- "})," , ",(0,i.jsx)(n.code,{children:"_"}),"，驼峰等风格而且嵌套深，CSS 引擎查找样式从右到左进行匹配，遍历页面上每个 li a 元素并确定其父元素。"]}),"\n",(0,i.jsx)(n.p,{children:"每个人的代码都有自己的风格在，对于个人来说作者本人也会对自己写的代码会比较熟悉，但是放在多人开发上就显得另类了。协同开发的小伙伴可能根本不知道你写的是什么，甚至跟你写的代码冲突覆盖。或者会反感你写的代码，因为他会为此多敲几次键盘，为了少敲几次键盘，他可能会“友好的问候”你。"}),"\n",(0,i.jsx)(n.p,{children:"为了让你不被小伙伴孤立，那么这次的讲解可能会对你有大好之处。这次也是为了让你少敲几次键盘。:)"}),"\n",(0,i.jsx)(n.p,{children:"我们先了解一下 css 中命名规范中的 BEM。"}),"\n",(0,i.jsxs)(n.h2,{id:"什么叫bem",children:["什么叫BEM？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么叫bem",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"BEM 是 BlockElementModifier 的简称，其实是块（block）、元素（element）、修饰符（modifier）的简称，是 CSS 中的一种命名规范。这种巧妙的命名方法让你的 CSS 类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。"}),"\n",(0,i.jsx)(n.p,{children:"BEM 的关键是光凭名字就可以告诉其他开发者某个标记是用来干什么的。通过浏览HTML代码中的class属性，你就能够明白模块之间是如何关联的：有一些仅仅是组件，有一些则是这些组件的子孙或者是元素，还有一些是组件的其他形态或者是修饰符。"}),"\n",(0,i.jsx)(n.p,{children:"可能你还是不太理解什么是BEM，没关系，我们看一下下面这个大家比较熟悉的哆啦A梦吧，看看这之间有什么相似之处。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"上面的哆啦A梦如果用进行分块，可以分为头部（脸部），手部，脚部这三大块。其中我们把脸部拿出来细分：眼睛、嘴巴、鼻子，用关系图表示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"我们用 BEM 规范来表达一下哆啦A梦的结构："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<template>\n	<view>\n		<view class="doraemon">\n			<view class="doraemon__face">\n				<view class="doraemon__face-eye "></view>\n				<view class="doraemon__face-mouth"></view>\n				<view class="doraemon__face-nose"></view>\n			</view>\n			<view class="doraemon__hand">\n				<view class="doraemon__hand-finger"></view>\n			</view>\n			<view class="doraemon__footer">\n				<view class="doraemon__footer-toe"></view>\n			</view>\n		</view>\n	</view>\n</template>	\n<style lang="scss">\n	.doraemon{\n		.doraemon-face{\n			.doraemon-face_eye{}\n			.doraemon-face_mouth{}\n			.doraemon-face_nose{}\n		}\n		/* 或者使用 @root */\n		@at-root #{&}-face {\n			@at-root #{&}_eye{}\n		}\n		.doraemon-hand{\n			.doraemon-hand_finger{}\n		}\n		.doraemon-footer{\n			.doraemon-footer_toe{}\n		}\n	}\n</style>	\n'})}),"\n",(0,i.jsx)(n.p,{children:"上面使用 BEM 规范块和元素之间用 -- 连接，元素和修饰符之间用 _ 连接 （b--e_m），来命名 CSS（用代码组织哆啦A梦），组织 HTML 元素结构，一一对应 CSS 代码，使得代码结构更清晰。"}),"\n",(0,i.jsx)(n.p,{children:"看起来是不是好像有些少了点意思，为什么？因为名字还是长呀。"}),"\n",(0,i.jsx)(n.p,{children:"接着看下一步吧！"}),"\n",(0,i.jsxs)(n.h2,{id:"页面布局--bem--scss",children:["页面布局 + BEM + scss",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#页面布局--bem--scss",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["使用 BEM 的方式，还是混淆使用 ",(0,i.jsx)(n.code,{children:"-"}),"，",(0,i.jsx)(n.code,{children:"_"}),"，而且命名方式长，就命名这一个会让你举手投降。平常利用 BEM 的规范思想，我自己有一套命名规范。比如上面的代码我们已经在外层指定了 doraemon ，那 doraemon 包含的元素就是属于 doraemon 的了，没有必要再加上 doraemon 了，因此我们可以这么去做："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<template>\n	<view>\n		<view class="doraemon">\n			<view class="face">\n				<view class="eye"></view>\n				<view class="mouth"></view>\n				<view class="nose"></view>\n			</view>\n			<view class="hand">\n				<view class="finger"></view>\n			</view>\n			<view class="footer">\n				<view class="toe"></view>\n			</view>\n		</view>\n	</view>\n</template>	\n<style lang="scss">\n	.doraemon{\n		.face{\n			.eye{}\n			.mouth{}\n			.nose{}\n		}\n		.hand{\n			.finger{}\n		}\n		.footer{\n			.toe{}\n		}\n	}\n</style>	\n'})}),"\n",(0,i.jsx)(n.p,{children:"每一层的作用域已经被上一层父级包含住了，因此没必要再去指定当前这一层的父级名字。当然每个团队的规范不一样，为了更容易阅读和理解，更容易协作，更容易控制，你需要服从团队的意识再去以开发效率去考虑，让团队甚至是你个人都能够更加容易地维护代码，如果你做到了，那么你自己也有了规范。"}),"\n",(0,i.jsx)(n.p,{children:"当我们自己将不同的规范柔和在一起以形成我自己的行为准则时，需要考虑："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"修改元素 class 的时候会不会干扰到其他地方的样式，导致其他引用这个样式的地方错乱；"}),"\n",(0,i.jsx)(n.li,{children:"class 名称是否足够简洁，不会让人烧脑；"}),"\n",(0,i.jsx)(n.li,{children:"样式的引用在哪里存放，是否会以 class 命名存放，然后修改 style；"}),"\n",(0,i.jsx)(n.li,{children:"H5 中 class 命名的元素有没有绑定事件，修改会不会导致事件失效。"}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"全局样式与局部样式",children:["全局样式与局部样式",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局样式与局部样式",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"每个页面可覆盖全局样式"}),"\n",(0,i.jsx)(n.p,{children:"定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。"}),"\n",(0,i.jsxs)(n.p,{children:["注意：\nApp.vue 中通过 ",(0,i.jsx)(n.code,{children:"@import"})," 语句可以导入外联样式，一样作用于每一个页面。"]}),"\n",(0,i.jsx)(n.p,{children:"这样我们可以在 common 的文件夹添加一个 common.scss 引入到app.vue中作为基础样式"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"\x3c!-- App.vue --\x3e\n<style lang=\"scss\">\n    @import './common/css/common.scss';\n</style>\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"样式的条件编译",children:["样式的条件编译",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#样式的条件编译",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"如果有个需求是 元素在 H5 的情况下渲染红色，在小程序下渲染绿色，你会想到怎么做？"}),"\n",(0,i.jsx)(n.p,{children:"判断平台，判断设备？其实你用 Uniapp 就不用考虑的那么复杂了，Uniapp 直接做了条件编译。条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。"}),"\n",(0,i.jsx)(n.p,{children:"条件编译写法：以 #ifdef 或 #ifndef 加 “平台名称” 开头，以 #endif 结尾。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"#ifdef：if defined 仅在某平台存在"}),"\n",(0,i.jsx)(n.li,{children:"#ifndef：if not defined 除了某平台均存在"}),"\n",(0,i.jsx)(n.li,{children:"%PLATFORM%：平台名称"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"平台名称参数对应："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 // 注释、css 使用 /* 注释 */。"}),"\n",(0,i.jsx)(n.p,{children:"那么就可以这么实现:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/* #ifdef MP-WEIXIN */\n.wx-clor{\n    color: green;\n}\n/* #endif */\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"使用良好的命名规范更容易阅读和理解，更容易协作，更容易控制，能让你的团队开发效率提升一大截；"}),"\n",(0,i.jsx)(n.li,{children:"局部样式就是每个 vue 页面的样式，它的权重比全局样式要高；"}),"\n",(0,i.jsx)(n.li,{children:"Uniapp 的条件编译是开发者编写一套代码发布多端项目的利器。"}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}let o=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Uniapp%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%2F7%20%E5%9F%BA%E7%A1%806%EF%BC%9A%E6%A0%B7%E5%BC%8F%E4%B8%8E%E5%B8%83%E5%B1%80%E3%80%81BEM%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%81%E8%B7%A8%E7%AB%AF%E5%85%BC%E5%AE%B9.md"]={toc:[{text:"css 命名弊端",id:"css-命名弊端",depth:2},{text:"什么叫BEM？",id:"什么叫bem",depth:2},{text:"页面布局 + BEM + scss",id:"页面布局--bem--scss",depth:2},{text:"全局样式与局部样式",id:"全局样式与局部样式",depth:2},{text:"样式的条件编译",id:"样式的条件编译",depth:2},{text:"小结",id:"小结",depth:2}],title:"7 基础6：样式与布局、BEM的应用、跨端兼容",headingTitle:"7 基础6：样式与布局、BEM的应用、跨端兼容",frontmatter:{}}}}]);