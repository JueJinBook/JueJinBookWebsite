"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17232"],{434509:function(e,n,c){c.r(n),c.d(n,{default:()=>I});var s=c(552676),i=c(740453);let r=c.p+"static/image/d432cf62876450dd7371bb9a2d5bfcab.bfd52a78.webp",d=c.p+"static/image/4e6417069542a327030d340b1d3fae56.dde85d80.webp",a=c.p+"static/image/1cb3a04616f8b9d4360b4c38efeb8bd1.7b44897c.webp",p=c.p+"static/image/6da3dc8b859d3d234c96157bd699e0cb.0554240a.webp",l=c.p+"static/image/3ddf683caf8875d612efe46a1cc63474.7efbc5dc.webp",t=c.p+"static/image/c91a557c658895b83157c1be71a89c8e.039341ef.webp",j=c.p+"static/image/e459455f1020884953238d2ff2482a41.3a2f627d.webp",x=c.p+"static/image/9c12af3044a9db50def3602ee956705d.25e9c6de.webp",h=c.p+"static/image/2c32765af75076c3713034b138eb58cd.694a8a87.webp",g=c.p+"static/image/b76a2c908c157a00474477c0230ca3bc.1a093ac5.webp",b=c.p+"static/image/eb579612392becd5877ccc1a3794fe1e.2a331ba1.webp",y=c.p+"static/image/fef180091d26003ebd62a89746013a3c.c86cb75f.webp",f=c.p+"static/image/9f6750d1b6711717f3e8d036ab4477a7.1d5400cd.webp",A=c.p+"static/image/48b56749512baadb472783b50c480acf.ede7dd68.webp",o=c.p+"static/image/5159fc40be84e45482f2065743046774.901edd29.webp",m=c.p+"static/image/3ca6ecdf8dadebfcb10776556da18a22.b17bd051.webp",E=c.p+"static/image/31daa41cce7c4782b049c9884ea56ef9.2f8838b7.webp",B=c.p+"static/image/8aff5a055ddaa9afdfabf08aea854835.68abcf94.webp",w=c.p+"static/image/421ceeefc9e69a429cc372885fcc3507.4db95caa.webp",K=c.p+"static/image/47d6584d8bdf95551137e7daeffd3fe0.439152de.webp",k=c.p+"static/image/4e6d61810d35e74fa71ba20f20ba8d99.b51a9a60.webp",u=c.p+"static/image/e04d921ac09ec99fbde5632e75b6378b.98562af8.webp",D=c.p+"static/image/ff85244330c57c9d6ec4d55d2f461aac.c9dba92e.webp",Q=c.p+"static/image/f8bc068dac6fc7aa3893acdf05e7e501.8b69cd9e.webp";function R(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"26加餐项目中-2-个真实的类型编程案例",children:["26.加餐：项目中 2 个真实的类型编程案例",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26加餐项目中-2-个真实的类型编程案例",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最近有两个同学问了我项目中遇到的 ts 问题，这俩问题都是典型的可以用类型编程来解决的。"}),"\n",(0,s.jsx)(n.p,{children:"这俩都是项目中真实遇到的 TS 类型问题，我们一起看一下吧："}),"\n",(0,s.jsx)(n.p,{children:"第一个问题是这样的，项目中定义了接口返回的数据的类型，比如这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Q,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那么填充数据的时候就要根据类型的定义来写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是呢，如果你想扩展一些属性就报错了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但现在想每层都能灵活扩展一些属性，怎么做呢？"}),"\n",(0,s.jsx)(n.p,{children:"简化一下就是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如何能让这个索引类型可以灵活添加一些额外的索引呢？"}),"\n",(0,s.jsx)(n.p,{children:"可以这样，添加一个可索引签名"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:K,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"能满足这个索引签名的额外索引都可以添加。"}),"\n",(0,s.jsx)(n.p,{children:"也可以这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"和 Record<string, any> 取交叉类型。"}),"\n",(0,s.jsx)(n.p,{children:"这个 Record 是一个内置的高级类型，作用是根据传入的 key 和 value 的类型生成索引类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这种生成索引类型的语法叫做映射类型。"}),"\n",(0,s.jsx)(n.p,{children:"所以，Record<string, any> 就是这样的，也是一个有可索引签名的索引类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"普通的对象我们知道怎么处理了，那多层的呢？"}),"\n",(0,s.jsx)(n.p,{children:"这样任意层数的索引类型，怎么给每一层都加上 Record<string, any> 呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这时候就要用到递归了，可以这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepRecord<Obj extends Record<string, any>> = {\n    [Key in keyof Obj]: \n        Obj[Key] extends Record<string, any>\n            ? DeepRecord<Obj[Key]> & Record<string, any>\n            : Obj[Key]\n} & Record<string, any>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"定义一个 DeepRecord 的高级类型，传入的类型参数 Obj 为一个索引类型，通过 Record<string, any> 约束。"}),"\n",(0,s.jsx)(n.p,{children:"然后通过映射类型的语法构造一个新的索引类型。"}),"\n",(0,s.jsx)(n.p,{children:"Key 来自之前的索引类型的 Key，也就是 Key in keyof Obj。"}),"\n",(0,s.jsx)(n.p,{children:"Value 要判断是不是索引类型，如果依然是 Record<string, any>，那就递归处理它的值 Obj[Key]，否则直接返回 Obj[Key]。"}),"\n",(0,s.jsx)(n.p,{children:"每一层都要和 Record<string, any> 取交叉类型。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了递归让 Obj 的每一层都变得可扩展的目的。"}),"\n",(0,s.jsx)(n.p,{children:"我们测试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，处理过后的类型确实是每一层都加上了 Record<string, any>。"}),"\n",(0,s.jsx)(n.p,{children:"也确实每一层都可以扩展了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"并且有类型定义的索引也会做类型检查："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["小结一下：",(0,s.jsx)(n.strong,{children:"可索引签名可以让索引类型扩展任意数量的符合签名的索引，如果想给任意层级的索引每层都加上可索引签名就要递归处理了。"})]}),"\n",(0,s.jsx)(n.p,{children:"那如果不用类型编程呢？"}),"\n",(0,s.jsx)(n.p,{children:"那你就要原封不动的写一个新的索引类型，然后手动给每一层都加上可索引签名，那就麻烦太多了，而且也不通用。"}),"\n",(0,s.jsx)(n.p,{children:"这就是类型编程的意义之一，可以根据需要修改类型。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAIghsOUC8UDeAoK2pzwLigDsBXAWwCMIAnAbixwqcMxzagGMvDTKb72OACYjCAZ2DUAlkQDmAnAF8ANA2wQNLNewBme8ZJnztbEUJ7kqdbYoy3QkWBrAAlCBwD21IQB4A8hQAVlAQAB7AEERCYlBunt4+EtJyyrhEIAB8GSjo2gDaANIQIFAyUADWxR46UAGBALqEJjh1hcX1IeGR0bHuXr5JRqlw6RnNggD8ThCufQmtRSD12QBkvfEDhilpmePshAvtdlBrcf2JW7LDo-QYDtDUEDGoMM5nCfCIGbeeRBJQQgQcEInyQqFYODwwKgAEZVGwmBQtIJsFwOIQ4XszIQAORQnE2eE4DQQZEovQ6XGInFEwTYqAAJhsdiAA",target:"_blank",rel:"noopener noreferrer",children:"案例一的 ts playground 地址"})}),"\n",(0,s.jsx)(n.p,{children:"再来看第二个问题："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也就是当一个索引为 'desc' | 'asc' 的时候，其他索引都是 false。"}),"\n",(0,s.jsx)(n.p,{children:"这种类型怎么写呢？"}),"\n",(0,s.jsx)(n.p,{children:"有的同学说，这个就是枚举所有的情况呀，比如这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这确实能解决问题："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到类型检查是符合我们的需求的。"}),"\n",(0,s.jsx)(n.p,{children:"但如果我再加几个属性呢？"}),"\n",(0,s.jsx)(n.p,{children:"是不是可能的类型又多了几种？"}),"\n",(0,s.jsx)(n.p,{children:"手动维护也太麻烦了！"}),"\n",(0,s.jsx)(n.p,{children:"这时候就可以用类型编程动态生成了。"}),"\n",(0,s.jsx)(n.p,{children:"比如我定义这样一个高级类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type GenerateType<Keys extends string> = {\n    [Key in Keys]: {\n        [Key2 in Key]: 'desc' | 'asc'\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"它生成的类型是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个还是很容易理解的，映射类型就是用来生成索引类型的。"}),"\n",(0,s.jsx)(n.p,{children:"我们可以取它的值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"结果就是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在就只差那些为 false 的索引了。"}),"\n",(0,s.jsx)(n.p,{children:"Keys 是一个联合类型，从中去掉 Key 的类型，可以用 Exclude，也就是 Exclude<Keys, Key>。"}),"\n",(0,s.jsx)(n.p,{children:"那么这个类型就可以这么写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type GenerateType<Keys extends string> = {\n    [Key in Keys]: {\n        [Key2 in Key]: 'desc' | 'asc'\n    } & {\n        [Key3 in Exclude<Keys, Key>]: false\n    }\n}[Keys]\n"})}),"\n",(0,s.jsx)(n.p,{children:"结果就是我们要的类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"任意多个索引都可以动态生成复合需求的联合类型。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"上面这个高级类型还可以做一些优化，把 key 的约束换成 keyof any："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"keyof any 的结果就是索引的类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但有个配置项叫做 keyofStringsOnly"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"开启之后就只能是 string 作为 key 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"keyof any 就可以动态获取 key 的可能类型，比写死更好。"}),"\n",(0,s.jsx)(n.p,{children:"这个高级类型最终就是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type GenerateType<Keys extends keyof any> = {\n    [Key in Keys]: {\n        [Key2 in Key]: 'desc' | 'asc'\n    } & {\n        [Key3 in Exclude<Keys, Key>]: false\n    }\n}[Keys]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["小结一下：",(0,s.jsx)(n.strong,{children:"当需要枚举很多种类型的可能性的时候，可以用类型编程动态生成。"})]}),"\n",(0,s.jsx)(n.p,{children:"那如果不用类型编程呢？"}),"\n",(0,s.jsx)(n.p,{children:"那你就得手动维护所有的可能类型了。"}),"\n",(0,s.jsx)(n.p,{children:"这就是类型编程的第二个意义，可以动态生成类型。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hB2EBOBDYEAq4IB4DSEIAzlBAB7rwAmJA1oQPYBmUK8IAfFALxQDeAKCjCoAbQIgoAS3hQJRALoAufkJHrxhAEzTZE5VADkVCEQDGhqAB8jKc4bXCAvlABkq9RokBmXVACiZGYANgCuJviERAA0coQcBkwowUQQjlBOAk6axAoA3AICoJBQSKY8sAjIaJjYOIYojZY2hgBG7c1GZt2GHAUCZgzwRMCsSmUkvILqjSgqDfbR6e2tKkkpEEvq3WZryalZhYPDo6ul5VPps3sbWyIr8yaL6Ts3B5kDQyNQu+eTHiJrrZnuoHkYnhY7sJXlB1u8BEA",target:"_blank",rel:"noopener noreferrer",children:"案例二的 ts playground 地址"})}),"\n",(0,s.jsx)(n.p,{children:"通过这两个真实的案例，不知道你是否体会到类型编程解决了什么问题呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"当你需要修改已有的类型，或者动态生成类型，都可以用类型编程。"})}),"\n",(0,s.jsx)(n.p,{children:"第一个案例，我们递归给每一层加上了可索引签名，不需要手动一层层改。"}),"\n",(0,s.jsx)(n.p,{children:"第二个案例，我们动态生成了所有的可能类型，不需要手动枚举。"}),"\n",(0,s.jsx)(n.p,{children:"类型编程的意义，你感受到了么？"})]})}function C(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(R,{...e})}):R(e)}let I=C;C.__RSPRESS_PAGE_META={},C.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F26.%E5%8A%A0%E9%A4%90%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%B8%AD%202%20%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B.md"]={toc:[],title:"26.加餐：项目中 2 个真实的类型编程案例",headingTitle:"26.加餐：项目中 2 个真实的类型编程案例",frontmatter:{}}}}]);