"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["35518"],{948084:function(n,e,r){n.exports=r.p+"static/image/c594c33342120a40c432cb6c1de42fbe.7dffa350.webp"},665126:function(n,e,r){r.r(e),r.d(e,{default:()=>g});var s=r(552676),t=r(740453);let i=r.p+"static/image/38077eadc0a954364486c26fbdb8657b.ef4552d8.webp",o=r.p+"static/image/22708bf2ce3d93f94fe10bbc18066da1.49793d71.webp",l=r.p+"static/image/9af700d9e79d62c969e55519c02e456b.14764a7d.webp",d=r.p+"static/image/e6c80f6d80765b82519810bc09c3f8a9.8a3b1bcb.webp",c=r.p+"static/image/99554f9e81746a357525acd76ec98f7e.3ccec62a.webp",a=r.p+"static/image/a4c859e67420834c3b8d7c43c0504886.51f6129e.webp",p=r.p+"static/image/79bb1ebbc8dfa1b9ef6e4f633ece69ae.d570cb73.webp",u=r.p+"static/image/88379837b4781b18193f98f070ce59f5.e2067ca1.webp";var m=r(948084);function x(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ol:"ol",li:"li",code:"code",img:"img",blockquote:"blockquote",pre:"pre",ul:"ul",h3:"h3",strong:"strong"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"24手写-vite_-实现-no-bundle-开发服务上",children:["24.手写 Vite_ 实现 no-bundle 开发服务(上)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24手写-vite_-实现-no-bundle-开发服务上",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在上一章中，我们一起系统学习了 Vite 的实现源码，从配置解析、依赖预构建、插件流水线和 HMR 这几个方面带你完整的梳理了 Vite 的底层原理，那么，在本小节中，我们将进一步，用实际的代码来写一个迷你版的 Vite，主要实现 Vite 最核心的 no-bundle 构建服务。在学完本节之后，你不仅能够复习之前所介绍的各种原理，也能深入地理解代码层面的实现细节，拥有独立开发一个 no-bundle 构建工具的能力。"}),"\n",(0,s.jsxs)(e.h2,{id:"实战概览",children:["实战概览",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战概览",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"相较于前面的小节，本小节(以及下一小节)的内容会比较难，手写的代码量也比较多(总共近一千行)。因此，在开始代码实战之前，我先给大家梳理一下需要完成的模块和功能，让大家有一个整体的认知:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"首先，我们会进行开发环境的搭建，安装必要的依赖，并搭建项目的构建脚本，同时完成 cli 工具的初始化代码。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["然后我们正式开始实现",(0,s.jsx)(e.code,{children:"依赖预构建"}),"的功能，通过 Esbuild 实现依赖扫描和依赖构建的功能。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["接着开始搭建 Vite 的插件机制，也就是开发 ",(0,s.jsx)(e.code,{children:"PluginContainer"})," 和 ",(0,s.jsx)(e.code,{children:"PluginContext"})," 两个主要的对象。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"搭建完插件机制之后，我们将会开发一系列的插件来实现 no-bundle 服务的编译构建能力，包括入口 HTML 处理、 TS/TSX/JS/TSX 编译、CSS 编译和静态资源处理。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"最后，我们会实现一套系统化的模块热更新的能力，从搭建模块依赖图开始，逐步实现 HMR 服务端和客户端的开发。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h2,{id:"搭建开发环境",children:["搭建开发环境",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#搭建开发环境",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["注: 手写 Vite 项目的所有代码，我已经放到了小册的 Github 仓库中，",(0,s.jsx)(e.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite",target:"_blank",rel:"noopener noreferrer",children:"点击查看"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["首先，你可以执行",(0,s.jsx)(e.code,{children:"pnpm init -y"}),"来初始化项目，然后安装一些必要的依赖，执行命令如下:"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"对于各个依赖的具体作用，大家先不用纠结，我将会在后面使用到依赖的时候介绍。"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// 运行时依赖\npnpm i cac chokidar connect debug es-module-lexer esbuild fs-extra magic-string picocolors resolve rollup sirv ws -S\n\n// 开发环境依赖\npnpm i @types/connect @types/debug @types/fs-extra @types/resolve @types/ws tsup\n"})}),"\n",(0,s.jsx)(e.p,{children:"Vite 本身使用的是 Rollup 进行自身的打包，但之前给大家介绍的 tsup 也能够实现库打包的功能，并且内置 esbuild 进行提速，性能上更加强悍，因此在这里我们使用 tsup 进行项目的构建。"}),"\n",(0,s.jsx)(e.p,{children:"为了接入 tsup 打包功能，你需要在 package.json 中加入这些命令:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'"scripts": {\n    "start": "tsup --watch",\n    "build": "tsup --minify"\n},\n'})}),"\n",(0,s.jsxs)(e.p,{children:["同时，你需要在项目根目录新建",(0,s.jsx)(e.code,{children:"tsconfig.json"}),"和",(0,s.jsx)(e.code,{children:"tsup.config.ts"}),"这两份配置文件，内容分别如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// tsconfig.json\n{\n  "compilerOptions": {\n    // 支持 commonjs 模块的 default import，如 import path from \'path\'\n    // 否则只能通过 import * as path from \'path\' 进行导入\n    "esModuleInterop": true,\n    "target": "ES2020",\n    "moduleResolution": "node",\n    "module": "ES2020",\n    "strict": true\n  }\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// tsup.config.ts\nimport { defineConfig } from "tsup";\n\nexport default defineConfig({\n  // 后续会增加 entry\n  entry: {\n    index: "src/node/cli.ts",\n  },\n  // 产物格式，包含 esm 和 cjs 格式\n  format: ["esm", "cjs"],\n  // 目标语法\n  target: "es2020",\n  // 生成 sourcemap\n  sourcemap: true,\n  // 没有拆包的需求，关闭拆包能力\n  splitting: false,\n});\n'})}),"\n",(0,s.jsxs)(e.p,{children:["接着新建 ",(0,s.jsx)(e.code,{children:"src/node/cli.ts"}),"文件，我们进行 cli 的初始化:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/cli.ts\nimport cac from "cac";\n\nconst cli = cac();\n\n// [] 中的内容为可选参数，也就是说仅输入 `vite` 命令下会执行下面的逻辑\ncli\n  .command("[root]", "Run the development server")\n  .alias("serve")\n  .alias("dev")\n  .action(async () => {\n    console.log(\'测试 cli~\');\n  });\n\ncli.help();\n\ncli.parse();\n'})}),"\n",(0,s.jsxs)(e.p,{children:["现在你可以执行 ",(0,s.jsx)(e.code,{children:"pnpm start"})," 来编译这个",(0,s.jsx)(e.code,{children:"mini-vite"}),"项目，tsup 会生成产物目录",(0,s.jsx)(e.code,{children:"dist"}),"，然后你可以新建",(0,s.jsx)(e.code,{children:"bin/mini-vite"}),"文件来引用产物:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'#!/usr/bin/env node\n\nrequire("../dist/index.js");\n'})}),"\n",(0,s.jsxs)(e.p,{children:["同时，你需要在 package.json 中注册",(0,s.jsx)(e.code,{children:"mini-vite"}),"命令，配置如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'{\n  "bin": {\n    "mini-vite": "bin/mini-vite"\n  }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["如此一来，我们就可以在业务项目中使用 ",(0,s.jsx)(e.code,{children:"mini-vite"})," 这个命令了。在小册的 Github 仓库中我为你准备了一个示例的 ",(0,s.jsx)(e.code,{children:"playground"})," 项目，你可以拿来进行测试，",(0,s.jsx)(e.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite/playground",target:"_blank",rel:"noopener noreferrer",children:"点击查看项目"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["将 ",(0,s.jsx)(e.code,{children:"playground"})," 项目放在 ",(0,s.jsx)(e.code,{children:"mini-vite"})," 目录中，然后执行 ",(0,s.jsx)(e.code,{children:"pnpm i"}),"，由于项目的",(0,s.jsx)(e.code,{children:"dependencies"}),"中已经声明了",(0,s.jsx)(e.code,{children:"mini-vite"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'{\n  "devDependencies": {\n    "mini-vite": \'../\'\n  }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["那么",(0,s.jsx)(e.code,{children:"mini-vite"}),"命令会自动安装到测试项目的",(0,s.jsx)(e.code,{children:"node_modules/.bin"}),"目录中:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["接着我们在",(0,s.jsx)(e.code,{children:"playground"}),"项目中执行",(0,s.jsx)(e.code,{children:"pnpm dev"}),"命令(内部执行",(0,s.jsx)(e.code,{children:"mini-vite"}),")，可以看到如下的 log 信息:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"测试 cli~\n"})}),"\n",(0,s.jsxs)(e.p,{children:["接着，我们把",(0,s.jsx)(e.code,{children:"console.log"}),"语句换成服务启动的逻辑:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:'import cac from "cac";\n+ import { startDevServer } from "./server";\n\nconst cli = cac();\n\ncli\n  .command("[root]", "Run the development server")\n  .alias("serve")\n  .alias("dev")\n  .action(async () => {\n-    console.log(\'测试 cli~\');\n+    await startDevServer();\n  });\n'})}),"\n",(0,s.jsxs)(e.p,{children:["现在你需要新建",(0,s.jsx)(e.code,{children:"src/node/server/index.ts"}),"，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// connect 是一个具有中间件机制的轻量级 Node.js 框架。\n// 既可以单独作为服务器，也可以接入到任何具有中间件机制的框架中，如 Koa、Express\nimport connect from "connect";\n// picocolors 是一个用来在命令行显示不同颜色文本的工具\nimport { blue, green } from "picocolors";\n\nexport async function startDevServer() {\n  const app = connect();\n  const root = process.cwd();\n  const startTime = Date.now();\n  app.listen(3000, async () => {\n    console.log(\n      green("\uD83D\uDE80 No-Bundle 服务已经成功启动!"),\n      `耗时: ${Date.now() - startTime}ms`\n    );\n    console.log(`> 本地访问路径: ${blue("http://localhost:3000")}`);\n  });\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["再次执行",(0,s.jsx)(e.code,{children:"pnpm dev"}),"，你可以发现终端出现如下的启动日志:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["OK，",(0,s.jsx)(e.code,{children:"mini-vite"})," 的 cli 功能和服务启动的逻辑目前就已经成功搭建起来了。"]}),"\n",(0,s.jsxs)(e.h2,{id:"依赖预构建",children:["依赖预构建",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖预构建",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"现在我们来进入依赖预构建阶段的开发。"}),"\n",(0,s.jsxs)(e.p,{children:["首先我们新建",(0,s.jsx)(e.code,{children:"src/node/optimizer/index.ts"}),"来存放依赖预构建的逻辑:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export async function optimize(root: string) {\n  // 1. 确定入口\n  // 2. 从入口处扫描依赖\n  // 3. 预构建依赖\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"然后在服务入口中引入预构建的逻辑:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",meta:"ts",children:'// src/node/server/index.ts\nimport connect from "connect";\nimport { blue, green } from "picocolors";\n+ import { optimize } from "../optimizer/index";\n\nexport async function startDevServer() {\n  const app = connect();\n  const root = process.cwd();\n  const startTime = Date.now();\n  app.listen(3000, async () => {\n+   await optimize(root);\n\n    console.log(\n      green("\uD83D\uDE80 No-Bundle 服务已经成功启动!"),\n      `耗时: ${Date.now() - startTime}ms`\n    );\n    console.log(`> 本地访问路径: ${blue("http://localhost:3000")}`);\n  });\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"接着我们来开发依赖预构建的功能，从上面的代码注释你也可以看出，我们需要完成三部分的逻辑:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"确定预构建入口"}),"\n",(0,s.jsx)(e.li,{children:"从入口开始扫描出用到的依赖"}),"\n",(0,s.jsx)(e.li,{children:"对依赖进行预构建"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["首先是确定入口，为了方便理解，这里我直接约定为 src 目录下的",(0,s.jsx)(e.code,{children:"main.tsx"}),"文件:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// 需要引入的依赖\nimport path from "path";\n\n// 1. 确定入口\nconst entry = path.resolve(root, "src/main.tsx");\n'})}),"\n",(0,s.jsx)(e.p,{children:"第二步是扫描依赖:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// 需要引入的依赖 \nimport { build } from "esbuild";\nimport { green } from "picocolors";\nimport { scanPlugin } from "./scanPlugin";\n\n// 2. 从入口处扫描依赖\nconst deps = new Set<string>();\nawait build({\n  entryPoints: [entry],\n  bundle: true,\n  write: false,\n  plugins: [scanPlugin(deps)],\n});\nconsole.log(\n`${green("需要预构建的依赖")}:\\n${[...deps]\n  .map(green)\n  .map((item) => `  ${item}`)\n  .join("\\n")}`\n);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["依赖扫描需要我们借助 Esbuild 插件来完成，最后会记录到 deps 这个集合中。接下来我们来着眼于 Esbuild 依赖扫描插件的开发，你需要在",(0,s.jsx)(e.code,{children:"optimzier"}),"目录中新建",(0,s.jsx)(e.code,{children:"scanPlguin.ts"}),"文件，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/optimizer/scanPlugin.ts\nimport { Plugin } from "esbuild";\nimport { BARE_IMPORT_RE, EXTERNAL_TYPES } from "../constants";\n\nexport function scanPlugin(deps: Set<string>): Plugin {\n  return {\n    name: "esbuild:scan-deps",\n    setup(build) {\n      // 忽略的文件类型\n      build.onResolve(\n        { filter: new RegExp(`\\\\.(${EXTERNAL_TYPES.join("|")})$`) },\n        (resolveInfo) => {\n          return {\n            path: resolveInfo.path,\n            // 打上 external 标记\n            external: true,\n          };\n        }\n      );\n      // 记录依赖\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        (resolveInfo) => {\n          const { path: id } = resolveInfo;\n          // 推入 deps 集合中\n          deps.add(id);\n          return {\n            path: id,\n            external: true,\n          };\n        }\n      );\n    },\n  };\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["需要说明的是，文件中用到了一些常量，在",(0,s.jsx)(e.code,{children:"src/node/constants.ts"}),"中定义，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'export const EXTERNAL_TYPES = [\n  "css",\n  "less",\n  "sass",\n  "scss",\n  "styl",\n  "stylus",\n  "pcss",\n  "postcss",\n  "vue",\n  "svelte",\n  "marko",\n  "astro",\n  "png",\n  "jpe?g",\n  "gif",\n  "svg",\n  "ico",\n  "webp",\n  "avif",\n];\n\nexport const BARE_IMPORT_RE = /^[\\w@][^:]/;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["插件的逻辑非常简单，即把一些无关的资源进行 external，不让 esbuild 处理，防止 Esbuild 报错，同时将",(0,s.jsx)(e.code,{children:"bare import"}),"的路径视作第三方包，推入 deps 集合中。"]}),"\n",(0,s.jsxs)(e.p,{children:["现在，我们在",(0,s.jsx)(e.code,{children:"playground"}),"项目根路径中执行",(0,s.jsx)(e.code,{children:"pnpm dev"}),"，可以发现依赖扫描已经成功执行:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"当我们收集到所有的依赖信息之后，就可以对每个依赖进行打包，完成依赖预构建了:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/optimizer/index.ts\n// 需要引入的依赖\nimport { preBundlePlugin } from "./preBundlePlugin";\nimport { PRE_BUNDLE_DIR } from "../constants";\n\n// 3. 预构建依赖\nawait build({\n  entryPoints: [...deps],\n  write: true,\n  bundle: true,\n  format: "esm",\n  splitting: true,\n  outdir: path.resolve(root, PRE_BUNDLE_DIR),\n  plugins: [preBundlePlugin(deps)],\n});\n'})}),"\n",(0,s.jsxs)(e.p,{children:["在此，我们引入了一个新的常量",(0,s.jsx)(e.code,{children:"PRE_BUNDLE_DIR"}),"，定义如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/constants.ts\n// 增加如下代码\nimport path from "path";\n\n// 预构建产物默认存放在 node_modules 中的 .m-vite 目录中\nexport const PRE_BUNDLE_DIR = path.join("node_modules", ".m-vite");\n'})}),"\n",(0,s.jsx)(e.p,{children:"接着，我们继续开发预构建的 Esbuild 插件。首先，考虑到兼容 Windows 系统，我们先加入一段工具函数的代码:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/utils.ts\nimport os from "os";\n\nexport function slash(p: string): string {\n  return p.replace(/\\\\/g, "/");\n}\n\nexport const isWindows = os.platform() === "win32";\n\n\nexport function normalizePath(id: string): string {\n  return path.posix.normalize(isWindows ? slash(id) : id);\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后完善预构建的代码:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { Loader, Plugin } from "esbuild";\nimport { BARE_IMPORT_RE } from "../constants";\n// 用来分析 es 模块 import/export 语句的库\nimport { init, parse } from "es-module-lexer";\nimport path from "path";\n// 一个实现了 node 路径解析算法的库\nimport resolve from "resolve";\n// 一个更加好用的文件操作库\nimport fs from "fs-extra";\n// 用来开发打印 debug 日志的库\nimport createDebug from "debug";\nimport { normalizePath } from "../utils";\n\nconst debug = createDebug("dev");\n\nexport function preBundlePlugin(deps: Set<string>): Plugin {\n  return {\n    name: "esbuild:pre-bundle",\n    setup(build) {\n      build.onResolve(\n        {\n          filter: BARE_IMPORT_RE,\n        },\n        (resolveInfo) => {\n          const { path: id, importer } = resolveInfo;\n          const isEntry = !importer;\n          // 命中需要预编译的依赖\n          if (deps.has(id)) {\n            // 若为入口，则标记 dep 的 namespace\n            return isEntry\n              ? {\n                  path: id,\n                  namespace: "dep",\n                }\n              : {\n                  // 因为走到 onResolve 了，所以这里的 path 就是绝对路径了\n                  path: resolve.sync(id, { basedir: process.cwd() }),\n                };\n          }\n        }\n      );\n\n      // 拿到标记后的依赖，构造代理模块，交给 esbuild 打包\n      build.onLoad(\n        {\n          filter: /.*/,\n          namespace: "dep",\n        },\n        async (loadInfo) => {\n          await init;\n          const id = loadInfo.path;\n          const root = process.cwd();\n          const entryPath = normalizePath(resolve.sync(id, { basedir: root }));\n          const code = await fs.readFile(entryPath, "utf-8");\n          const [imports, exports] = await parse(code);\n          let proxyModule = [];\n          // cjs\n          if (!imports.length && !exports.length) {\n            // 构造代理模块\n            // 下面的代码后面会解释\n            const res = require(entryPath);\n            const specifiers = Object.keys(res);\n            proxyModule.push(\n              `export { ${specifiers.join(",")} } from "${entryPath}"`,\n              `export default require("${entryPath}")`\n            );\n          } else {\n            // esm 格式比较好处理，export * 或者 export default 即可\n            if (exports.includes("default")) {\n              proxyModule.push(`import d from "${entryPath}";export default d`);\n            }\n            proxyModule.push(`export * from "${entryPath}"`);\n          }\n          debug("代理模块内容: %o", proxyModule.join("\\n"));\n          const loader = path.extname(entryPath).slice(1);\n          return {\n            loader: loader as Loader,\n            contents: proxyModule.join("\\n"),\n            resolveDir: root,\n          };\n        }\n      );\n    },\n  };\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["值得一提的是，对于 CommonJS 格式的依赖，单纯用 ",(0,s.jsx)(e.code,{children:"export default require('入口路径')"})," 是有局限性的，比如对于 React 而言，用这样的方式生成的产物最后只有 default 导出:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// esbuild 的打包产物\n// 省略大部分代码\nexport default react_default;\n"})}),"\n",(0,s.jsx)(e.p,{children:"那么用户在使用这个依赖的时候，必须这么使用:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// ✅ 正确\nimport React from 'react';\n\nconst { useState } = React;\n\n// ❌ 报错\nimport { useState } from 'react';\n"})}),"\n",(0,s.jsx)(e.p,{children:"那为什么上述会报错的语法在 Vite 是可以正常使用的呢？原因是 Vite 在做 import 语句分析的时候，自动将你的代码进行改写了:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// 原来的写法\nimport { useState } from 'react';\n\n// Vite 的 importAnalysis 插件转换后的写法类似下面这样\nimport react_default from '/node_modules/.vite/react.js';\n\nconst { useState } = react_default;\n"})}),"\n",(0,s.jsx)(e.p,{children:"那么，还有没有别的方案来解决这个问题？没错，上述的插件代码中已经用另一个方案解决了这个问题，我们不妨把目光集中在下面这段代码中:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'  if (!imports.length && !exports.length) {\n    // 构造代理模块\n    // 通过 require 拿到模块的导出对象\n    const res = require(entryPath);\n    // 用 Object.keys 拿到所有的具名导出\n    const specifiers = Object.keys(res);\n    // 构造 export 语句交给 Esbuild 打包\n    proxyModule.push(\n      `export { ${specifiers.join(",")} } from "${entryPath}"`,\n      `export default require("${entryPath}")`\n    );\n  }\n'})}),"\n",(0,s.jsx)(e.p,{children:"如此一来，Esbuild 预构建的产物中便会包含 CommonJS 模块中所有的导出信息:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// 预构建产物导出代码\nexport {\n  react_default as default,\n  useState,\n  useEffect,\n  // 省略其它导出\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["OK，接下来让我们来测试一下预构建整体的功能。在 ",(0,s.jsx)(e.code,{children:"playground"})," 项目中执行 ",(0,s.jsx)(e.code,{children:"pnpm dev"}),"，接着去项目的 ",(0,s.jsx)(e.code,{children:"node_modules"})," 目录中，可以发现新增了",(0,s.jsx)(e.code,{children:".m-vite"})," 目录及",(0,s.jsx)(e.code,{children:"react"}),"、",(0,s.jsx)(e.code,{children:"react-dom"}),"的预构建产物:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h2,{id:"插件机制开发",children:["插件机制开发",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插件机制开发",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在完成了依赖预构建的功能之后，我们开始搭建 Vite 的插件机制，实现插件容器和插件上下文对象。"}),"\n",(0,s.jsxs)(e.p,{children:["首先，你可以新建",(0,s.jsx)(e.code,{children:"src/node/pluginContainer.ts"}),"文件，增加如下的类型定义:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import type {\n  LoadResult,\n  PartialResolvedId,\n  SourceDescription,\n  PluginContext as RollupPluginContext,\n  ResolvedId,\n} from "rollup";\n\nexport interface PluginContainer {\n  resolveId(id: string, importer?: string): Promise<PartialResolvedId | null>;\n  load(id: string): Promise<LoadResult | null>;\n  transform(code: string, id: string): Promise<SourceDescription | null>;\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["另外，由于插件容器需要接收 Vite 插件作为初始化参数，因此我们需要提前声明插件的类型，你可以继续新建",(0,s.jsx)(e.code,{children:"src/node/plugin.ts"}),"来声明如下的插件类型:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { LoadResult, PartialResolvedId, SourceDescription } from "rollup";\nimport { ServerContext } from "./server";\n\nexport type ServerHook = (\n  server: ServerContext\n) => (() => void) | void | Promise<(() => void) | void>;\n\n// 只实现以下这几个钩子\nexport interface Plugin {\n  name: string;\n  configureServer?: ServerHook;\n  resolveId?: (\n    id: string,\n    importer?: string\n  ) => Promise<PartialResolvedId | null> | PartialResolvedId | null;\n  load?: (id: string) => Promise<LoadResult | null> | LoadResult | null;\n  transform?: (\n    code: string,\n    id: string\n  ) => Promise<SourceDescription | null> | SourceDescription | null;\n  transformIndexHtml?: (raw: string) => Promise<string> | string;\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["对于其中的 ServerContext，你暂时不用过于关心，只需要在",(0,s.jsx)(e.code,{children:"server/index.ts"}),"中简单声明一下类型即可:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// src/node/server/index.ts\n// 增加如下类型声明\nexport interface ServerContext {}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["接着，我们来实现插件机制的具体逻辑，主要集中在",(0,s.jsx)(e.code,{children:"createPluginContainer"}),"函数中:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/pluginContainer.ts\n// 模拟 Rollup 的插件机制\nexport const createPluginContainer = (plugins: Plugin[]): PluginContainer => {\n  // 插件上下文对象\n  // @ts-ignore 这里仅实现上下文对象的 resolve 方法\n  class Context implements RollupPluginContext {\n    async resolve(id: string, importer?: string) {\n      let out = await pluginContainer.resolveId(id, importer);\n      if (typeof out === "string") out = { id: out };\n      return out as ResolvedId | null;\n    }\n  }\n  // 插件容器\n  const pluginContainer: PluginContainer = {\n    async resolveId(id: string, importer?: string) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.resolveId) {\n          const newId = await plugin.resolveId.call(ctx as any, id, importer);\n          if (newId) {\n            id = typeof newId === "string" ? newId : newId.id;\n            return { id };\n          }\n        }\n      }\n      return null;\n    },\n    async load(id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.load) {\n          const result = await plugin.load.call(ctx, id);\n          if (result) {\n            return result;\n          }\n        }\n      }\n      return null;\n    },\n    async transform(code, id) {\n      const ctx = new Context() as any;\n      for (const plugin of plugins) {\n        if (plugin.transform) {\n          const result = await plugin.transform.call(ctx, code, id);\n          if (!result) continue;\n          if (typeof result === "string") {\n            code = result;\n          } else if (result.code) {\n            code = result.code;\n          }\n        }\n      }\n      return { code };\n    },\n  };\n\n  return pluginContainer;\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"上面的代码比较容易理解，并且关于插件钩子的执行原理和插件上下文对象的作用，在小册第 22 节中也有详细的分析，这里就不再赘述了。"}),"\n",(0,s.jsx)(e.p,{children:"接着，我们来完善一下之前的服务器逻辑:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:'// src/node/server/index.ts\nimport connect from "connect";\nimport { blue, green } from "picocolors";\nimport { optimize } from "../optimizer/index";\n+ import { resolvePlugins } from "../plugins";\n+ import { createPluginContainer, PluginContainer } from "../pluginContainer";\n\nexport interface ServerContext {\n+  root: string;\n+  pluginContainer: PluginContainer;\n+  app: connect.Server;\n+  plugins: Plugin[];\n}\n\nexport async function startDevServer() {\n  const app = connect();\n  const root = process.cwd();\n  const startTime = Date.now();\n+  const plugins = resolvePlugins();\n+  const pluginContainer = createPluginContainer(plugins);\n\n+  const serverContext: ServerContext = {\n+    root: process.cwd(),\n+    app,\n+    pluginContainer,\n+    plugins,\n+  };\n\n+  for (const plugin of plugins) {\n+    if (plugin.configureServer) {\n+      await plugin.configureServer(serverContext);\n+    }\n+  }\n\n  app.listen(3000, async () => {\n    await optimize(root);\n    console.log(\n      green("\uD83D\uDE80 No-Bundle 服务已经成功启动!"),\n      `耗时: ${Date.now() - startTime}ms`\n    );\n    console.log(`> 本地访问路径: ${blue("http://localhost:3000")}`);\n  });\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["其中 ",(0,s.jsx)(e.code,{children:"resolvePlugins"})," 方法我们还未定义，你可以新建",(0,s.jsx)(e.code,{children:"src/node/plugins/index.ts"})," 文件，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { Plugin } from "../plugin";\n\nexport function resolvePlugins(): Plugin[] {\n  // 下一部分会逐个补充插件逻辑\n  return [];\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"入口-html-加载",children:["入口 HTML 加载",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#入口-html-加载",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"现在我们基于如上的插件机制，来实现 Vite 的核心编译能力。"}),"\n",(0,s.jsxs)(e.p,{children:["首先要考虑的就是入口 HTML 如何编译和加载的问题，这里我们可以通过一个服务中间件，配合插件机制来实现。具体而言，你可以新建",(0,s.jsx)(e.code,{children:"src/node/server/middlewares/indexHtml.ts"}),"，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { NextHandleFunction } from "connect";\nimport { ServerContext } from "../index";\nimport path from "path";\nimport { pathExists, readFile } from "fs-extra";\n\nexport function indexHtmlMiddware(\n  serverContext: ServerContext\n): NextHandleFunction {\n  return async (req, res, next) => {\n    if (req.url === "/") {\n      const { root } = serverContext;\n      // 默认使用项目根目录下的 index.html\n      const indexHtmlPath = path.join(root, "index.html");\n      if (await pathExists(indexHtmlPath)) {\n        const rawHtml = await readFile(indexHtmlPath, "utf8");\n        let html = rawHtml;\n        // 通过执行插件的 transformIndexHtml 方法来对 HTML 进行自定义的修改\n        for (const plugin of serverContext.plugins) {\n          if (plugin.transformIndexHtml) {\n            html = await plugin.transformIndexHtml(html);\n          }\n        }\n\n        res.statusCode = 200;\n        res.setHeader("Content-Type", "text/html");\n        return res.end(html);\n      }\n    }\n    return next();\n  };\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后在服务中应用这个中间件:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/server/index.ts\n// 需要增加的引入语句\nimport { indexHtmlMiddware } from "./middlewares/indexHtml";\n\n// 省略中间的代码\n\n// 处理入口 HTML 资源\napp.use(indexHtmlMiddware(serverContext));\n\napp.listen(3000, async () => {\n  // 省略\n});\n'})}),"\n",(0,s.jsxs)(e.p,{children:["接下来通过",(0,s.jsx)(e.code,{children:"pnpm dev"}),"启动项目，然后访问",(0,s.jsx)(e.code,{children:"http://localhost:3000"}),"，从网络面板中你可以查看到 HTML 的内容已经成功返回:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"不过当前的页面并没有任何内容，因为 HTML 中引入的 TSX 文件并没有被正确编译。接下来，我们就来处理 TSX 文件的编译工作。"}),"\n",(0,s.jsxs)(e.h2,{id:"jstsjsxtsx-编译能力",children:["JS/TS/JSX/TSX 编译能力",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#jstsjsxtsx-编译能力",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先新增一个中间件",(0,s.jsx)(e.code,{children:"src/node/server/middlewares/transform.ts"}),"，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { NextHandleFunction } from "connect";\nimport {\n  isJSRequest,\n  cleanUrl,\n} from "../../utils";\nimport { ServerContext } from "../index";\nimport createDebug from "debug";\n\nconst debug = createDebug("dev");\n\nexport async function transformRequest(\n  url: string,\n  serverContext: ServerContext\n) {\n  const { pluginContainer } = serverContext;\n  url = cleanUrl(url);\n  // 简单来说，就是依次调用插件容器的 resolveId、load、transform 方法\n  const resolvedResult = await pluginContainer.resolveId(url);\n  let transformResult;\n  if (resolvedResult?.id) {\n    let code = await pluginContainer.load(resolvedResult.id);\n    if (typeof code === "object" && code !== null) {\n      code = code.code;\n    }\n    if (code) {\n      transformResult = await pluginContainer.transform(\n        code as string,\n        resolvedResult?.id\n      );\n    }\n  }\n  return transformResult;\n}\n\nexport function transformMiddleware(\n  serverContext: ServerContext\n): NextHandleFunction {\n  return async (req, res, next) => {\n    if (req.method !== "GET" || !req.url) {\n      return next();\n    }\n    const url = req.url;\n    debug("transformMiddleware: %s", url);\n    // transform JS request\n    if (isJSRequest(url)) {\n      // 核心编译函数\n      let result = await transformRequest(url, serverContext);\n      if (!result) {\n        return next();\n      }\n      if (result && typeof result !== "string") {\n        result = result.code;\n      }\n      // 编译完成，返回响应给浏览器\n      res.statusCode = 200;\n      res.setHeader("Content-Type", "application/javascript");\n      return res.end(result);\n    }\n\n    next();\n  };\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"同时，我们也需要补充如下的工具函数和常量定义:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/utils.ts\nimport { JS_TYPES_RE } from \'./constants.ts\'\n\nexport const isJSRequest = (id: string): boolean => {\n  id = cleanUrl(id);\n  if (JS_TYPES_RE.test(id)) {\n    return true;\n  }\n  if (!path.extname(id) && !id.endsWith("/")) {\n    return true;\n  }\n  return false;\n};\n\nexport const cleanUrl = (url: string): string =>\n  url.replace(HASH_RE, "").replace(QEURY_RE, "");\n  \n// src/node/constants.ts\nexport const JS_TYPES_RE = /\\.(?:j|t)sx?$|\\.mjs$/;\nexport const QEURY_RE = /\\?.*$/s;\nexport const HASH_RE = /#.*$/s;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["从如上的核心编译函数",(0,s.jsx)(e.code,{children:"transformRequest"}),"可以看出，Vite 对于 JS/TS/JSX/TSX 文件的编译流程主要是依次调用插件容器的如下方法:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"resolveId"}),"\n",(0,s.jsx)(e.li,{children:"load"}),"\n",(0,s.jsx)(e.li,{children:"transform"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"其中会经历众多插件的处理逻辑，那么，对于 TSX 文件的编译逻辑，也分散到了各个插件当中，具体来说主要包含以下的插件:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"路径解析插件"}),"\n",(0,s.jsx)(e.li,{children:"Esbuild 语法编译插件"}),"\n",(0,s.jsx)(e.li,{children:"import 分析插件"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"接下来，我们就开始依次实现这些插件。"}),"\n",(0,s.jsxs)(e.h3,{id:"1-路径解析插件",children:["1. 路径解析插件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-路径解析插件",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"当浏览器解析到如下的标签时:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",children:'<script type="module" src="/src/main.tsx"><\/script>\n'})}),"\n",(0,s.jsxs)(e.p,{children:["会自动发送一个路径为",(0,s.jsx)(e.code,{children:"/src/main.tsx"}),"的请求，但如果服务端不做任何处理，是无法定位到源文件的，随之会返回 404 状态码:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["因此，我们需要开发一个路径解析插件，对请求的路径进行处理，使之能转换真实文件系统中的路径。你可以新建文件",(0,s.jsx)(e.code,{children:"src/node/plugins/resolve.ts"}),"，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import resolve from "resolve";\nimport { Plugin } from "../plugin";\nimport { ServerContext } from "../server/index";\nimport path from "path";\nimport { pathExists } from "fs-extra";\nimport { DEFAULT_EXTERSIONS } from "../constants";\nimport { cleanUrl, normalizePath } from "../utils";\n\nexport function resolvePlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: "m-vite:resolve",\n    configureServer(s) {\n      // 保存服务端上下文\n      serverContext = s;\n    },\n    async resolveId(id: string, importer?: string) {\n      // 1. 绝对路径\n      if (path.isAbsolute(id)) {\n        if (await pathExists(id)) {\n          return { id };\n        }\n        // 加上 root 路径前缀，处理 /src/main.tsx 的情况\n        id = path.join(serverContext.root, id);\n        if (await pathExists(id)) {\n          return { id };\n        }\n      }\n      // 2. 相对路径\n      else if (id.startsWith(".")) {\n        if (!importer) {\n          throw new Error("`importer` should not be undefined");\n        }\n        const hasExtension = path.extname(id).length > 1;\n        let resolvedId: string;\n        // 2.1 包含文件名后缀\n        // 如 ./App.tsx\n        if (hasExtension) {\n          resolvedId = normalizePath(resolve.sync(id, { basedir: path.dirname(importer) }));\n          if (await pathExists(resolvedId)) {\n            return { id: resolvedId };\n          }\n        } \n        // 2.2 不包含文件名后缀\n        // 如 ./App\n        else {\n          // ./App -> ./App.tsx\n          for (const extname of DEFAULT_EXTERSIONS) {\n            try {\n              const withExtension = `${id}${extname}`;\n              resolvedId = normalizePath(resolve.sync(withExtension, {\n                basedir: path.dirname(importer),\n              }));\n              if (await pathExists(resolvedId)) {\n                return { id: resolvedId };\n              }\n            } catch (e) {\n              continue;\n            }\n          }\n        }\n      }\n      return null;\n    },\n  };\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["这样对于 ",(0,s.jsx)(e.code,{children:"/src/main.tsx"}),"，在插件中会转换为文件系统中的真实路径，从而让模块在 load 钩子中能够正常加载(加载逻辑在 Esbuild 语法编译插件实现)。"]}),"\n",(0,s.jsx)(e.p,{children:"接着我们来补充一下目前缺少的常量:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/constants.ts\nexport const DEFAULT_EXTERSIONS = [".tsx", ".ts", ".jsx", "js"];\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"2-esbuild-语法编译插件",children:["2. Esbuild 语法编译插件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-esbuild-语法编译插件",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["这个插件的作用比较好理解，就是将 JS/TS/JSX/TSX 编译成浏览器可以识别的 JS 语法，可以利用 Esbuild 的 Transform API 来实现。你可以新建",(0,s.jsx)(e.code,{children:"src/node/plugins/esbuild.ts"}),"文件，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { readFile } from "fs-extra";\nimport { Plugin } from "../plugin";\nimport { isJSRequest } from "../utils";\nimport esbuild from "esbuild";\nimport path from "path";\n\nexport function esbuildTransformPlugin(): Plugin {\n  return {\n    name: "m-vite:esbuild-transform",\n    // 加载模块\n    async load(id) {\n      if (isJSRequest(id)) {\n        try {\n          const code = await readFile(id, "utf-8");\n          return code;\n        } catch (e) {\n          return null;\n        }\n      }\n    },\n    async transform(code, id) {\n      if (isJSRequest(id)) {\n        const extname = path.extname(id).slice(1);\n        const { code: transformedCode, map } = await esbuild.transform(code, {\n          target: "esnext",\n          format: "esm",\n          sourcemap: true,\n          loader: extname as "js" | "ts" | "jsx" | "tsx",\n        });\n        return {\n          code: transformedCode,\n          map,\n        };\n      }\n      return null;\n    },\n  };\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"3-import-分析插件",children:["3. import 分析插件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-import-分析插件",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在将 TSX 转换为浏览器可以识别的语法之后，是不是就可以直接返回给浏览器执行了呢？"}),"\n",(0,s.jsx)(e.p,{children:"显然不是，我们还考虑如下的一些问题:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"对于第三方依赖路径(bare import)，需要重写为预构建产物路径；"}),"\n",(0,s.jsx)(e.li,{children:"对于绝对路径和相对路径，需要借助之前的路径解析插件进行解析。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"好，接下来，我们就在 import 分析插件中一一解决这些问题:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// 新建 src/node/plugins/importAnalysis.ts\nimport { init, parse } from "es-module-lexer";\nimport {\n  BARE_IMPORT_RE,\n  DEFAULT_EXTERSIONS,\n  PRE_BUNDLE_DIR,\n} from "../constants";\nimport {\n  cleanUrl,\n  isJSRequest,\n  normalizePath\n} from "../utils";\n// magic-string 用来作字符串编辑\nimport MagicString from "magic-string";\nimport path from "path";\nimport { Plugin } from "../plugin";\nimport { ServerContext } from "../server/index";\nimport { pathExists } from "fs-extra";\nimport resolve from "resolve";\n\nexport function importAnalysisPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: "m-vite:import-analysis",\n    configureServer(s) {\n      // 保存服务端上下文\n      serverContext = s;\n    },\n    async transform(code: string, id: string) {\n      // 只处理 JS 相关的请求\n      if (!isJSRequest(id)) {\n        return null;\n      }\n      await init;\n      // 解析 import 语句\n      const [imports] = parse(code);\n      const ms = new MagicString(code);\n      // 对每一个 import 语句依次进行分析\n      for (const importInfo of imports) {\n        // 举例说明: const str = `import React from \'react\'`\n        // str.slice(s, e) => \'react\'\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource) continue;\n        // 第三方库: 路径重写到预构建产物的路径\n        if (BARE_IMPORT_RE.test(modSource)) {\n           const bundlePath = normalizePath(\n            path.join(\'/\', PRE_BUNDLE_DIR, `${modSource}.js`)\n          );\n          ms.overwrite(modStart, modEnd, bundlePath);\n        } else if (modSource.startsWith(".") || modSource.startsWith("/")) {\n          // 直接调用插件上下文的 resolve 方法，会自动经过路径解析插件的处理\n          const resolved = await this.resolve(modSource, id);\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved.id);\n          }\n        }\n      }\n\n      return {\n        code: ms.toString(),\n        // 生成 SourceMap\n        map: ms.generateMap(),\n      };\n    },\n  };\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"现在，我们便完成了 JS 代码的 import 分析工作。接下来，我们把上面实现的三个插件进行注册:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// src/node/plugin/index.ts\nimport { esbuildTransformPlugin } from "./esbuild";\nimport { importAnalysisPlugin } from "./importAnalysis";\nimport { resolvePlugin } from "./resolve";\nimport { Plugin } from "../plugin";\n\nexport function resolvePlugins(): Plugin[] {\n  return [resolvePlugin(), esbuildTransformPlugin(), importAnalysisPlugin()];\n}\n\n'})}),"\n",(0,s.jsxs)(e.p,{children:["当然，我们需要注册 transformMiddleware 中间件，在",(0,s.jsx)(e.code,{children:"src/node/server/index.ts"}),"中增加代码如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"app.use(transformMiddleware(serverContext));\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后在",(0,s.jsx)(e.code,{children:"playground"}),"项目下执行",(0,s.jsx)(e.code,{children:"pnpm dev"}),"，在浏览器里面访问",(0,s.jsx)(e.code,{children:"http://localhost:3000"}),"，你可以在网络面板中发现 ",(0,s.jsx)(e.code,{children:"main.tsx"})," 的内容以及被编译为下面这样:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"同时，页面内容也能被渲染出来了:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"OK，目前为止我们就基本上完成 JS/TS/JSX/TSX 文件的编译。"}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["本小节的内容就到这里，相信你如果能一直跟着做到这里，也已经收获满满了。我们最后来回顾和小结一下，这一节我们主要来手写 Vite 的 no-bundle 服务，完成了",(0,s.jsx)(e.strong,{children:"开发环境搭建"}),"、",(0,s.jsx)(e.strong,{children:"预构建功能的开发"}),"、",(0,s.jsx)(e.strong,{children:"插件机制的搭建"}),"、",(0,s.jsx)(e.strong,{children:"入口 HTML 加载"}),"和 ",(0,s.jsx)(e.strong,{children:"JS/TS/JSX/TSX 的编译功能"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"在下一小节，我们将继续完善当前的 no-bundle 服务器，完成 CSS 编译、静态资源加载和 HMR 系统的实现，让我们下一节再见\uD83D\uDC4B\uD83C\uDFFB"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(x,{...n})}):x(n)}let g=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F24.%E6%89%8B%E5%86%99%20Vite_%20%E5%AE%9E%E7%8E%B0%20no-bundle%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1(%E4%B8%8A).md"]={toc:[{text:"实战概览",id:"实战概览",depth:2},{text:"搭建开发环境",id:"搭建开发环境",depth:2},{text:"依赖预构建",id:"依赖预构建",depth:2},{text:"插件机制开发",id:"插件机制开发",depth:2},{text:"入口 HTML 加载",id:"入口-html-加载",depth:2},{text:"JS/TS/JSX/TSX 编译能力",id:"jstsjsxtsx-编译能力",depth:2},{text:"1. 路径解析插件",id:"1-路径解析插件",depth:3},{text:"2. Esbuild 语法编译插件",id:"2-esbuild-语法编译插件",depth:3},{text:"3. import 分析插件",id:"3-import-分析插件",depth:3},{text:"小结",id:"小结",depth:2}],title:"24.手写 Vite_ 实现 no-bundle 开发服务(上)",headingTitle:"24.手写 Vite_ 实现 no-bundle 开发服务(上)",frontmatter:{}}}}]);