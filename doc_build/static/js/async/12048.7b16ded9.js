"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12048"],{528710:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),i=r(740453);let t=r.p+"static/image/13fd7101233a3cc3ddfb2cf5e53e70f1.42128054.webp",c=r.p+"static/image/64c3750076bb13e03d70b0bf8a18b4d5.261fd14c.webp",a=r.p+"static/image/aa8c6284326f5e5d66953c5c0553d9f9.de2edc62.webp",l=r.p+"static/image/15be1a82e8cb34663cea601caa4996e2.c648f711.webp",d=r.p+"static/image/4e8265b86cf8f5bd09153b2ee74c97ef.1180d3c2.webp",o=r.p+"static/image/640f3277274a39f7894f8efd4e979fb4.e27fc19d.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li",pre:"pre",code:"code",ul:"ul",img:"img",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"2基础知识一次搞懂-ast-抽象语法树",children:["2.基础知识：一次搞懂 AST 抽象语法树",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2基础知识一次搞懂-ast-抽象语法树",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"理解 AST 抽象语法树是开发代码分析工具的前提，这一节我们将学习 AST 相关的基础知识，主要内容包括 AST 是什么？常见节点有哪些？AST 可视化工具有什么用？AST 有哪些具体用途？以及如何生成 AST。通过这一小节的学习，大家可以一次性搞懂抽象语法树的所有知识，为后续开发分析工具打下坚实基础。"}),"\n",(0,s.jsxs)(n.h2,{id:"ast-是什么",children:["AST 是什么？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-是什么",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"代码中常见的字面量、标识符、表达式、语句、模块语法、class 语法等语句都有各自对应的 AST 节点类型，下面我们简单介绍下常见的节点类型。"}),"\n",(0,s.jsxs)(n.h3,{id:"常见节点类型",children:["常见节点类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见节点类型",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"literal(字面量) : 本身语义代表了一个值。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  let name = 'iceman';       // iceman ---\x3e StringLiteral 字符串字面量\n  let age = 30;              // 30     ---\x3e NumberLiteral 数字字面量\n  const isMan = true;        // true   ---\x3e BooleanLiteral 布林字面量\n  const reg = /\\d/;          // /\\d/   ---\x3e RegExpLiteral 正则字面量\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Identifier(标识符) : 变量名、属性名、参数名等等一系列声明和引用的名字。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  import { request } form 'framework';   // request              ---\x3e Identifier\n  let name = 'iceman';                   // name                 ---\x3e Identifier\n  const age = 30;                        // age                  ---\x3e Identifier\n  function talk(name) {                  // talk, name           ---\x3e Identifier\n      console.log(name);                 // console, log, name   ---\x3e Identifier\n  }\n const obj = {                          // obj                  ---\x3e Identifier\n      name: 'guang'                      // name                 ---\x3e Identifier\n  }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Statement(语句) : 代码执行的最小单位。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  return 'iceman';                    // ReturnStatement\n  if (age > 35) {}                    // IfStatement\n  throw new Error('error')            // ThrowStatement\n  try {} catch(e) {}                  // TryStatement\n  for (let i = 0; i < 5; i++) {}      // ForStatement\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"Declaration(声明) : 声明语句是一种特殊的 Statement。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  const listlen = 1;            // VariableDeclaration\n  let listName = 'user';        // VariableDeclaration\n  function getInfo(info) {      // FunctionDeclaration\n      if(info.isRun){\n          return info.name;\n      }\n      return '';\n  }         \n  class Car {                   // ClassDeclaration\n      constructor() {}\n      method() {}\n  }\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Expression(表达式) : expression的特点是执行完成后会有返回值，这也是它和语句的区别"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  [1,2,3];                          // ArrayExpression 数组表达式\n  age = 1;                          // AssignmentExpression 赋值表达式\n  1 + 2;                            // BinaryExpression二元表达式\n  var obj = {                       // ObjectExpression对象表达式\n      foo: 'foo',     \n      bar: function() {}    \n  }\n  let getName = function (){}       // FunctionExpression函数表达式\n  const getAge = (age) => {         // ArrowFunctionExpression箭头函数表达式\n      return age;\n  };             \n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsx)(n.li,{children:"Import : 导入模块，属于一种特殊的声明语句，有三种类型 ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"  import { environment } from 'framework';        // named import\n  import { request as req } from 'framework';     // namespaced import\n  import api from 'framework';                    // default import\n  import * as APP from 'framework';               // namespaced imort\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"7",children:["\n",(0,s.jsx)(n.li,{children:"Export : 导出模块，也属于一种特殊的声明，有三种类型 ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export * from './iceman';\nexport default 'iceman';\nexport const ice = 'iceman';\n"})}),"\n",(0,s.jsx)(n.p,{children:"每个 AST 节点都有自己的属性，但是它们也有一些公共的属性："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"pos"}),"，AST 节点在代码字符串中索引的起始位置，配合 end 确定节点在代码字符串中的位置（用于唯一性判定）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"end"}),"，AST 节点在代码字符串中索引的结束位置，配合 pos 确定节点在代码字符串中的位置（用于唯一性判定）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"kind"}),"，用来标记当前 AST 节点的类型，上面列举的节点类型都可以通过 ",(0,s.jsx)(n.a,{href:"https://github.com/microsoft/TypeScript/blob/v4.7.4/lib/typescript.d.ts#L105",target:"_blank",rel:"noopener noreferrer",children:"ts.SyntaxKind"})," 的定义来查看。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这么多节点类型，肯定不可能都记住，我们可以通过一些可视化工具来帮助我们查看 AST 节点信息。"}),"\n",(0,s.jsxs)(n.h3,{id:"可视化工具",children:["可视化工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可视化工具",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"})," 是一个 AST 可视化工具，通过它可以查看各种编程语言代码解析后的 AST 结构，帮助开发者更直观地观察代码与 AST 节点树具体节点的对应关系，它支持切换各种 parser，可以修改 parse options。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["如果想把代码片段对应的 AST 结构分享给别人查看，可以点击 save 按钮保存下来，把 url 分享出去，比如",(0,s.jsx)(n.a,{href:"https://astexplorer.net/#/gist/0beb6bb16461e59baf96be02c82df9a0/c92e363f8f037df97a2434d71a5e28c55c4cc1e4",target:"_blank",rel:"noopener noreferrer",children:"https://astexplorer.net/#/gist/0beb6bb16461e59baf96be02c82df9a0/c92e363f8f037df97a2434d71a5e28c55c4cc1e4"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"})," 与 AST explorer 不同，它只用于 TypeScript AST 对象的可视化，除了展示 AST 节点信息外，还会关联节点 TS 编译过程中的 ",(0,s.jsx)(n.code,{children:"type"}),"、",(0,s.jsx)(n.code,{children:"symbol"})," 等信息，后续章节会很频繁的用到这个可视化工具。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["上图对应的 ",(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAQQApLgMyhEcDkGCGIApgO7QDWOA3AFCiSxwDecY+AJu8AHYDmc+AM5wAxgBsI3InAC+6TNhwisISQFoArsGo1l3QfGAiiIfNzgBeOAGZadNAApkSAJRMaASD2CIYogDoJXicUF1ovCSkHHABGACZrHDCaGRoaNA1uERhgSThTKF4eOAcXZk9veGdLWwrJHz9AiGDnZNTdevgYEzA4y0QUf2BBACVgXgALeAB+OBgoDWkALnR8MUEiOwysnLz2IjXS8o9gR2d-QQmIEjgAPjiy9w8PKCIYDShzbvA48NSZIA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer URL"}),"。举个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// 示例代码\nfunction add(num: number) {\n  return 5 + num;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面是一段 TS 代码，内容是声明了一个名为 add 的函数，代码对应的 ",(0,s.jsx)(n.a,{href:"https://astexplorer.net/#/gist/0beb6bb16461e59baf96be02c82df9a0/c92e363f8f037df97a2434d71a5e28c55c4cc1e4",target:"_blank",rel:"noopener noreferrer",children:"AST explorer URL"}),"，使用 TypeScript 编译器转化为 AST 对象以后，右侧的 AST 树信息如下图（图中简化隐藏了非关键节点，方便讲解重要节点）："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"AST 对象简化为 JSON 对象的话："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:"{\n    kind: 305,\n    statements: [{\n        kind: 256,\n        name: {\n            kind: 79,                                // Identifier\n            escapedText: 'add'\n        },\n        parameters: [{\n            kind: 164,                               // Identifier\n            name: {\n                kind: 79,                            // Identifier\n                escapedText: 'num'\n            },\n            type: {\n                kind: 147                            // NumberKeyword\n            }\n        }],\n        body: {\n            kind: 235,\n            statements: [{\n                kind: 247,\n                expression: {\n                    kind: 221,\n                    left: {\n                        kind: 8,\n                        text: '5'\n                    },\n                    operatorToken: {\n                        kind: 39\n                    },\n                    right: {\n                        kind: 79,                    // Identifier\n                        escapedText: 'num'\n                    }\n                }\n            }]\n        }\n    }]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"SourceFile 可以理解成 AST Root 节点，如果把它命名为 ast，我们可以获取如下信息："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"ast.statements[0].kind                                // 节点类型为函数声明\nast.statements[0].name.escapedText                    // 函数名称\nast.statements[0].parameters[0].name                  // 函数的首个参数名\nast.statements[0].parameters[0].type.kind             // 函数的首个参数类型为Number\nast.statements[0].body.statements[0].kind             // 函数体内第一行是return语句\nast.statements[0].body.statements[0].expression.kind  // 函数返回值为二元运算符表达式结果\n"})}),"\n",(0,s.jsx)(n.p,{children:"既然代码的含义可以通过 AST 来表述，而 AST 又可以理解为一个 JS 对象，那我们是不是可以通过程序代码对其进行处理，从而实现分析代码的目的呢？答案是肯定的，那么 AST 具体有哪些用途呢？"}),"\n",(0,s.jsxs)(n.h2,{id:"ast-有什么用",children:["AST 有什么用？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-有什么用",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"代码编译",children:["代码编译",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码编译",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Babel"}),"，将 ES6 JavaScript 转化为 ES5 JavaScript。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"TypeScript"}),"，将 TypeScript 转化为 JavaScript。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Sass"}),"，将 Sass 转化为 CSS。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"代码加工",children:["代码加工",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码加工",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Prettier"}),"，代码美化，风格格式化。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ESLint"}),", 修复语法错误。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"uglifyJS"}),"，代码压缩，混淆。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@vue/compiler-dom"}),"，可以将 Vue 文件代码拆分成 template、script、style 三种代码类型片段。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"代码分析",children:["代码分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码分析",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ESLint"}),"，代码语法检查。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Webpack"}),"，代码模块打包分析。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"基于 AST 的代码处理工具工作流程一般可以概括为 4 个阶段："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parsing（解析）"})," ：这个过程由编译器实现，会经过词法分析和语法分析两个过程，生成 ",(0,s.jsx)(n.code,{children:"AST"})," 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Traversing（遍历）："})," 深度优先遍历 ",(0,s.jsx)(n.code,{children:"AST"})," ，访问树上各个节点的信息（Node）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Transforming（修改）："})," 在遍历的过程中可对节点信息进行修改/转化，生成新的 ",(0,s.jsx)(n.code,{children:"AST"})," 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Printing（输出）："})," 将转化后新的 ",(0,s.jsx)(n.code,{children:"AST"})," 输出成新的代码块。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"代码编译，代码加工一般会经历 1，2，3，4 四个阶段，而代码分析因为不会去改变源代码，所以一般只经历 1，2 两个阶段。比如 ESLint 仅检查语法错误时，只需要对 AST 各级节点进行遍历，定位违反语法规则的节点信息并标记，返回修复建议即可，不需要对代码作出修改和再输出。"}),"\n",(0,s.jsx)(n.p,{children:"我们要开发的分析工具也属于代码分析类，核心工作也是对 AST 各级节点进行遍历分析并返回分析结果，那么如何生成 AST 呢？"}),"\n",(0,s.jsxs)(n.h2,{id:"ast-如何生成",children:["AST 如何生成?",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-如何生成",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"生成 AST 包含两个步骤："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"词法分析：将整个代码字符串分割成最小语法单元数组。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"语法分析：在分词基础上建立分析语法单元之间的关系。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"词法分析",children:["词法分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#词法分析",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"将输入的源代码字符串，生成一系列词法单元 (Tokens)，这些词法单元包括数字，标点符号，运算符等，这些词法单元之间都是独立的。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"词法分析的过程就像是我们刚开始学习汉语造句时，通常会先将一个句子拆分成很多独立的单词，然后先记住每一个单词的类型和含义，并不关心单词之间的具体联系。"}),"\n",(0,s.jsxs)(n.h3,{id:"语法分析",children:["语法分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#语法分析",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"将词法分析出来的 Token 按照不同的语法结构如声明语句、赋值表达式等转化成有语法含义的抽象语法树结构。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const iceman = 'good boy';\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"const iceman = 'good boy';"})," 上面这一段源代码字符串，先把它按照单词的构成规则分成一个个不能再细分的单词（Token），也就是 ",(0,s.jsx)(n.code,{children:"const"}),"、",(0,s.jsx)(n.code,{children:"iceman"}),"、",(0,s.jsx)(n.code,{children:"="}),"、 ",(0,s.jsx)(n.code,{children:"'good boy'"}),"，这个过程是词法分析。之后把 Tokens 按照声明语句、赋值表达式的语法结构如进行递归组装，生成 AST 对象，这个过程是语法分析。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"编译器-parser",children:["编译器 Parser",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译器-parser",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"})," 可视化工具的实现原理是通过调用对应开发语言 Parser 的 CompilerAPI，将代码解析为 AST 对象再进而遍历展示。也就是说，这些 Parser 的 API 可以帮助我们完成代码的词法分析与语法分析，并返回对应的 AST 对象，下面是常用的 JS Parser 与 TS Parser。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["JS Parser： ",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjquery%2Fesprima",target:"_blank",rel:"noopener noreferrer",children:"esprima"}),"、 ",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Facornjs%2Facorn",target:"_blank",rel:"noopener noreferrer",children:"acorn"}),"、 ",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feslint%2Fespree",target:"_blank",rel:"noopener noreferrer",children:"espree"}),"、",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmaster%2Fpackages%2Fbabel-parser",target:"_blank",rel:"noopener noreferrer",children:"@babel/parser"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["TS Parser：",(0,s.jsx)(n.a,{href:"https://github.com/microsoft/TypeScript/#readme",target:"_blank",rel:"noopener noreferrer",children:"typescript"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["TS Parser 可以同时解析 JS(X) 和 TS(X) 代码文件，所以我们代码分析工具选择的 Parser 是 ",(0,s.jsx)(n.a,{href:"https://github.com/microsoft/TypeScript/#readme",target:"_blank",rel:"noopener noreferrer",children:"typescript"}),"，后续的课程我们会对用到的 Typescript CompilerAPI 进行详细讲解，这里先介绍生成 AST 的几个 API："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createSourceFile"}),"：根据 TypeScript 代码字符串生成 AST 对象，",(0,s.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"})," 的底层原理就是通过这个方法将代码片段字符串转化为 AST 做可视化处理。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// TS编译器\nconst tsCompiler = require('typescript');\n\n// 待分析代码片段字符串\nconst tsCode = `import { app } from 'framework';                                \n\nconst dataLen = 3;\nlet name = 'iceman';\n\nif(app){\n    console.log(name);\n}\n\nfunction getInfos (info: string) {\n    const result = app.get(info);\n    return result;\n}`;\n \n// 第一个参数为命名，可以随意填，\n// 第二个参数是需要生成AST的源代码字符串\n// 第三个参数表示TS编译器版本\n// 第四个参数表示是否添加parent节点信息\nconst ast = tsCompiler.createSourceFile('xxx', tsCode, tsCompiler.ScriptTarget.Latest, true);\nconsole.log(ast);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createProgram"}),"，",(0,s.jsx)(n.code,{children:"getSourceFile"}),"：先创建 program 编译上下文，然后获取指定代码文件的 AST 对象，program 可以抽象成一次完整的 TS 编译过程，通过它可以获取编译过程的上下文信息。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// TS编译器\nconst tsCompiler = require('typescript');\n\n// 创建Program\n// fileNames参数表示文件路径列表，是一个数组\n// options参数是编译选项，可以理解成tsconfig\nconst program = tsCompiler.createProgram(fileNames, options);\n\n// 从 Program 中获取某个文件的 SourceFile\n// fileName表示某一个文件路径\nconst ast = program.getSourceFile(fileName);\nconsole.log(ast);\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面两种方式都可以生成 AST，区别在于前者仅仅是将一段 TS 代码字符串解析成 AST，因为不存在 program，所以无法获取编译上下文信息，只能通过遍历 AST 实现一些简单分析场景。而后者通过 program 获取更多编译上下文信息，可以实现更细致的分析场景，代码分析工具采用后者来获取 AST。"}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一小节我们学习了 AST 相关的知识，需要大家掌握以下知识点："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["了解 AST 及常见节点类型，学会使用 ",(0,s.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"}),"、",(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"})," 两个可视化工具观察 AST。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"代码的含义可以通过 AST 对象来表述，所以通过程序代码对其进行处理，就可以实现代码分析的目的。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["AST 是开发各种代码处理工具的前提，代码分析类工具一般只需要经历 ",(0,s.jsx)(n.strong,{children:"Parsing"})," ",(0,s.jsx)(n.strong,{children:"和"})," ",(0,s.jsx)(n.strong,{children:"Traversing"})," 两个阶段。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"获取 AST 对象需要学习对应语言的编译器 Parser，可以通过 TS parser 的 CompilerAPI 来获取 TS/JS 代码的 AST。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"如果大家对 AST 及相关概念还想有进一步的学习，可以参考以下延伸阅读："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844903798347939853#heading-58",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/6844903798347939853#heading-58"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://jkchao.github.io/typescript-book-chinese/compiler/program.html",target:"_blank",rel:"noopener noreferrer",children:"https://jkchao.github.io/typescript-book-chinese/compiler/program.html"})}),"\n"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let x=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F2.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82%20AST%20%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.md"]={toc:[{text:"AST 是什么？",id:"ast-是什么",depth:2},{text:"常见节点类型",id:"常见节点类型",depth:3},{text:"可视化工具",id:"可视化工具",depth:3},{text:"AST 有什么用？",id:"ast-有什么用",depth:2},{text:"代码编译",id:"代码编译",depth:3},{text:"代码加工",id:"代码加工",depth:3},{text:"代码分析",id:"代码分析",depth:3},{text:"AST 如何生成?",id:"ast-如何生成",depth:2},{text:"词法分析",id:"词法分析",depth:3},{text:"语法分析",id:"语法分析",depth:3},{text:"编译器 Parser",id:"编译器-parser",depth:3},{text:"小结",id:"小结",depth:2}],title:"2.基础知识：一次搞懂 AST 抽象语法树",headingTitle:"2.基础知识：一次搞懂 AST 抽象语法树",frontmatter:{}}}}]);