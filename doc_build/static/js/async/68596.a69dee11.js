"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["68596"],{582696:function(e,n,a){a.r(n),a.d(n,{default:()=>p});var s=a(552676),r=a(740453);let c=a.p+"static/image/768720c34e2ee5efe216689e2506c6d1.0a46c34d.webp",l=a.p+"static/image/fcd1703d0e4f2ef24c4044db54d378e1.24ac4dab.webp",d=a.p+"static/image/ddcfa59b14644c634f09ce587e9e6855.30286f8b.webp",t=a.p+"static/image/9ea320eaeb50ab408b6fd14cf79dafea.c32b7efd.webp",o=a.p+"static/image/067ed6123f2a0e875e3fa74db993dde8.d4b62573.webp";function i(e){let n=Object.assign({p:"p",a:"a",strong:"strong",ol:"ol",li:"li",h1:"h1",h2:"h2",pre:"pre",code:"code",img:"img",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"通过上两节的内容，我们知道 Form 组件是如何制作，又是如何控制表单控件的，那么这节我们自己实现一个简单的表单控件，通过这个组件，更好地理解 Hooks 在组件中的应用，如何配合 Form 组件联合使用。"}),"\n",(0,s.jsxs)(n.p,{children:["在这节，我们去实现 ProComponents 中 ",(0,s.jsx)(n.a,{href:"https://procomponents.ant.design/components/check-card",target:"_blank",rel:"noopener noreferrer",children:"CheckCard"})," 组件。"]}),"\n",(0,s.jsx)(n.p,{children:"之所以选择这个组件，是因为它与 Form 组件的结构类似，其次它的实现相对简单，在了解它的同时，也能巩固之前的 Form 组件，所以是个不错的示例组件。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CheckCard："})," 多选卡片，用于集合多种相关说明信息，并且可以被选择，用在 Form 表单中，成为一个效果非常好的表单控件。它分为两部分，分别是："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CheckCard："})," 用于展示头像、标题、描述信息等，具备选中、禁用、加载等状态，可单独使用。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CheckCard.Group："})," 集中控制 CheckCard，使其受控，可配合 Form 组件联合使用。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们依次来实现它们。"}),"\n",(0,s.jsxs)(n.h1,{id:"19实践篇checkcard多选卡片",children:["19.实践篇｜CheckCard：多选卡片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19实践篇checkcard多选卡片",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先不用考虑 CheckCard.Group 的实现，先去实现 CheckCard，再来实现 CheckCard.Group。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-基本布局",children:["1. 基本布局",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-基本布局",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 CheckCard 中具备四种布局元素，分别是 avatar（头像）、 title（标题）、description（描述信息）、extra（右上角额外信息）。这里用 useCss 来简单实现 CheckCard 的样式即可："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const CheckCard = (props: CheckCardProps) => {\n\n  const dataMemo = useCreation(() => {\n    const avatarDom = avatar ? (\n      <div className={styleDateMemo["check-card-avatar"]}>\n        {typeof avatar === "string" ? (\n          <Avatar size={48} shape="square" src={avatar} />\n        ) : (\n          avatar\n        )}\n      </div>\n    ) : null;\n\n    const header = (title ?? extra) !== null && (\n      <div className={styleDateMemo["check-card-header"]}>\n        <div className={styleDateMemo["check-card-title"]}>{title}</div>\n        {extra && (\n          <div className={styleDateMemo["check-card-extra"]}>{extra}</div>\n        )}\n      </div>\n    );\n\n    const descriptionDom = description ? (\n      <div className={styleDateMemo["check-card-description"]}>\n        {description}\n      </div>\n    ) : null;\n\n    return (\n      <div className={styleDateMemo["check-card-content"]}>\n        {avatarDom}\n        {header || descriptionDom ? (\n          <div className={styleDateMemo["check-card-detail"]}>\n            {header}\n            {descriptionDom}\n          </div>\n        ) : null}\n      </div>\n    );\n  }, [title, extra, description]);\n  \n  return (\n    <div>\n      {dataMemo}\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsxs)(n.h2,{id:"2-额外信息",children:["2. 额外信息",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-额外信息",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["可以通过 extra 来制作卡片的额外操作，但要注意，我们在整个卡片都附有点击事件，所以我们的额外操作中一定要",(0,s.jsx)(n.strong,{children:"阻止事件冒泡"}),"，即 ",(0,s.jsx)(n.code,{children:"e.stopPropagation();"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-基本状态的改变",children:["3. 基本状态的改变",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-基本状态的改变",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 CheckCard 中，共有三种状态，分别是未选中、选中、禁用，而这三种状态所对应的样式都有所改变，此时我们可以利用 ",(0,s.jsx)(n.code,{children:"classNames"})," 来帮助我们处理卡片的样式，使效果更美观。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const CheckCard = (props: CheckCardProps) => {\n  const {\n    avatar,\n    title,\n    extra,\n    description,\n    disabled = false,\n    loading = false,\n    style = {},\n    ...params\n  } = props;\n\n  const [checked, setChecked] = useSafeState<boolean>(\n    params.defaultChecked || false\n  );\n\n  const styleClassName: StylesBooleanProps = {};\n  styleClassName[useCss(styles["check-card"])] = true;\n  styleClassName[useCss(styles["check-card-checked"])] = !!checked;\n  styleClassName[useCss(styles["check-card-disabled"])] = !!disabled;\n  styleClassName[useCss(styles["check-card-disabled-after"])] = !!checked && !!disabled;\n\n  return (\n    <div\n      className={classNames(styleClassName)}\n      style={style}\n      onClick={(v) => {\n        if (!disabled && !loading) {\n          params.onClick && params.onClick(v);\n          params.onChange && params.onChange(!checked);\n          setChecked((v) => !v);\n        }\n      }}\n    >\n      {dataMemo}\n    </div>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"其中，鼠标移动到卡片上可以通过 hover 属性，右上角的标可以通过 after 简单制作，鼠标的样式可以通过 cursor 来控制。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-加载状态",children:["4. 加载状态",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-加载状态",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过配置 loading 属性可以配置组件的加载状态，可以通过 Row、Col 来做简单的布局，然后通过 ",(0,s.jsx)(n.code,{children:"linear-gradient"})," 来控制颜色的渐变，再配合 ",(0,s.jsx)(n.code,{children:"animation"})," 控制颜色的滚动。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const Loading = () => {\n  return (\n    <div className={useCss(styles["check-card-loading-content"])}>\n      <Row gutter={8}>\n        <Col span={22}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n      </Row>\n      <Row gutter={8}>\n        <Col span={8}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n        <Col span={14}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n      </Row>\n      <Row gutter={8}>\n        <Col span={6}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n        <Col span={16}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n      </Row>\n      <Row gutter={8}>\n        <Col span={13}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n        <Col span={9}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n      </Row>\n      <Row gutter={8}>\n        <Col span={4}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n        <Col span={3}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n        <Col span={14}>\n          <div className={useCss(styles["check-card-loading"])} />\n        </Col>\n      </Row>\n    </div>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.h1,{id:"checkcardgroup",children:["CheckCard.Group",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#checkcardgroup",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CheckCard.Group："})," 布局组件，用来集中控制 CheckCard，通过 value 和 onChange 使其受控，也可通过其他属性来整体控制 CheckCard，配合 Form 组件联合使用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"1-数据传递",children:["1. 数据传递",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-数据传递",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["CheckCard.Group 和 CheckCard 组件存在深层的嵌套关系，所以需要通过 ",(0,s.jsx)(n.code,{children:"context（ createContext + useContext ）"}),"跨层级方式传递数据。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'  // GroupContext\n  import { createContext } from "react";\n  import { SelectGroupConnextType } from "./interface.d";\n\n  const GroupContext = createContext<SelectGroupConnextType | null>(null);\n\n  export default GroupContext;\n  \n  // Group\n  const Group: React.FC<GroupProps> = (props) => {\n    ...\n    <GroupContext.Provider\n      value={{ ... }}\n    >\n      <div className={useCss(styles["select-card-group"])} style={style}>\n        {params.children}\n      </div>\n    </GroupContext.Provider>\n  }\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"2-注册与卸载",children:["2. 注册与卸载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-注册与卸载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"因为我们需要 CheckCard.Group 去管理 CheckCard 的数据，所以 CheckCard.Group 要监听 CheckCard 的数据变化，换言之，CheckCard 要进行注册和卸载，而判断的依据则是 value。"}),"\n",(0,s.jsxs)(n.p,{children:["同时，在 CheckCard.Group 中通过 ",(0,s.jsx)(n.code,{children:"new Map()"})," 集中管理数据，并以 useRef 保存数据源，防止闭包。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  // Group\n  const Group: React.FC<GroupProps> = (props) => {\n    const ref = useRef<Map<ValueType, any>>(new Map());\n\n    // 注册\n    const registerValue = (value: string) => {\n      ref.current?.set(value, true);\n    };\n\n    // 卸载\n    const cancelValue = (value: string) => {\n      ref.current?.delete(value);\n    };\n    \n    ...\n  }\n  \n  // index\n  const CheckCard = (props: CheckCardProps) => {\n    useEffect(() => {\n      params.value && group?.registerValue?.(params.value);\n      return () => {\n        params.value && group?.cancelValue?.(params.value);\n      };\n    }, [params.value]);\n    \n    ...\n  }\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"3-使-checkcard-受控",children:["3. 使 CheckCard 受控",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-使-checkcard-受控",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果存在多个 CheckCard，那么它们每一个都是独立的组件，但如果在 CheckCard.Group 下，CheckCard 则需要受 CheckCard.Group 的控制，由 CheckCard.Group 的 value 控制所有的 CheckCard。"}),"\n",(0,s.jsx)(n.p,{children:"那么 value 将会存在三种形式："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"undefined："})," value 不存在时；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"string："})," 字符串，单选时；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"string[]："})," 数组，多选时。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"触发 CheckCard.Group 的变化时机则是 CheckCard 的 onChange 方法。如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  // Group\n  const Group: React.FC<GroupProps> = (props) => {\n    const { multiple = false, onChange, ...params } = props;\n    const [stateValue, setStateValue] = useSafeState<GroupValueType>();\n    \n    ....\n    const selectOption = (option: SelectOptionProps) => {\n      if (multiple) {\n        let newValue: ValueType[] = [];\n        const stateValues = stateValue as ValueType[];\n        const flag = stateValues?.includes(option.value);\n        newValue = [...(stateValues || [])];\n        if (flag) {\n          newValue = newValue.filter((itemValue) => itemValue !== option.value);\n        } else {\n          newValue.push(option.value);\n        }\n\n        setStateValue?.(newValue);\n        onChange && onChange(newValue);\n      } else {\n        let newValue = stateValue;\n        if (newValue === option.value) {\n          newValue = undefined;\n        } else {\n          newValue = option.value;\n        }\n        setStateValue?.(newValue);\n        onChange && onChange(newValue);\n      }\n    };\n    \n    ...\n  }\n  \n  // index\n  const CheckCard = (props: CheckCardProps) => {\n    const selectData: any = {};\n     \n     ...\n     selectData.checked = checked;\n     if (group) { // 通过 Group 组件控制对应的选中状态\n      const isChecked = group.multiple\n        ? group.value?.includes(params.value)\n        : group.value === params.value;\n      selectData.checked = isChecked;\n    }\n\n    return (\n      <div\n        className={classNames(styleClassName)}\n        style={style}\n        onClick={(v) => {\n          if (!disabled && !loading) {\n            ...\n            group?.selectOption?.({ value: props.value });\n          }\n        }}\n      >\n        {dataMemo}\n      </div>\n    );\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"img3.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"4-配合-form-组件使用",children:["4. 配合 Form 组件使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-配合-form-组件使用",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在上两节的学习中，我们知道 Form.Item 控制表单控件是通过 ",(0,s.jsx)(n.code,{children:"React.cloneElement"})," 的帮助，给对应的表单控件加入 value 和 onChange 元素。也就是说，要想自定义控件跟 Form 绑定关系，只需要存在 value 和 onChange 这两个属性，使其受控配合即可。"]}),"\n",(0,s.jsx)(n.p,{children:"因为 Form 组件会统一管理 value，所以在 CheckCard.Group 中要对 value 进行监控，控制 value 属性。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  // Check.Group\n  const Group: React.FC<GroupProps> = (props) => {\n  \n    const [stateValue, setStateValue] = useSafeState<GroupValueType>();\n    \n    useEffect(() => {\n      setStateValue(params.value || params.initValue);\n    }, [params.value]);\n    \n    ...\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import React from "react";\nimport CheckCard from "./CheckCard";\nimport { Button, message } from "antd";\nimport Form from "../Form/HooksForm";\n\nconst Index: React.FC = () => {\n  return (\n    <>\n      <h1>在 Form 表单的应用</h1>\n      <Form\n        initialValues={{ card: "A" }}\n        onFinish={(data: any) => {\n          console.log("表单数据:", data);\n        }}\n        onReset={() => {\n          console.log("重制表单成功");\n        }}\n      >\n        <Form.Item label="选择卡片-单选" name="card" styles={{ with: "100%" }}>\n          <CheckCard.Group>\n            <CheckCard title="Card A" description="一起玩转Hooks吧" value="A" />\n            <CheckCard title="Card B" description="一起玩转Hooks吧" value="B" />\n            <CheckCard title="Card C" description="一起玩转Hooks吧" value="C" />\n          </CheckCard.Group>\n        </Form.Item>\n        <Form.Item label="选择卡片-多选" name="card-multiple">\n          <CheckCard.Group multiple>\n            <CheckCard title="Card A" description="一起玩转Hooks吧" value="A" />\n            <CheckCard title="Card B" description="一起玩转Hooks吧" value="B" />\n            <CheckCard title="Card C" description="一起玩转Hooks吧" value="C" />\n          </CheckCard.Group>\n        </Form.Item>\n        <Form.Item>\n          <Button type="primary" htmlType="submit">\n            提交\n          </Button>\n          <Button style={{ marginLeft: 4 }} htmlType="reset">\n            重置\n          </Button>\n        </Form.Item>\n      </Form>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"img4.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"5-集中控制-loading",children:["5. 集中控制 loading",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-集中控制-loading",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"CheckGroup.Card 除了可以控制 CheckGroup 的 value 外，还可以集中控制加载状态、边框样式、卡片大小等，原理与 value 一样。这里巩固一下，加一个 loading 状态，整体去控制 CheckGroup。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'  const CheckCard = (props: CheckCardProps) => {\n    const selectData: any = {};\n     \n    selectData.checked = checked;\n    selectData.loading = loading;\n    if (group) {\n      // 通过 Group 组件控制对应的选中状态\n      const isChecked = group.multiple\n        ? group.value?.includes(params.value)\n        : group.value === params.value;\n      selectData.checked = isChecked;\n      selectData.loading = loading || group.loading;\n    }\n    \n    // 之后使用 loading 的地方都换成 selectData.loading 即可\n    ...\n  }\n  \n  // 使用\n  <h1>集中控制 Loading：</h1>\n  <CheckCard.Group loading>\n    <CheckCard title="Card A" description="一起玩转Hooks吧" value="A" />\n    <CheckCard title="Card B" description="一起玩转Hooks吧" value="B" />\n    <CheckCard title="Card C" description="一起玩转Hooks吧" value="C" />     \n  </CheckCard.Group>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过本小节的阅读，我们知道 CheckCard 组件的实现原理，了解到 Hooks 在组件中的应用，简单总结下："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"明确数据流、数据走向，确保数据的传递。任何组件，首先要确保数据的流向，规划好数据源，确保数据由单个地方产生，一层一层传递，不要有多个数据源。"}),"\n",(0,s.jsxs)(n.li,{children:["组件传递需要考虑",(0,s.jsx)(n.strong,{children:"多层级嵌套"}),"的关系，优先使用 ",(0,s.jsx)(n.code,{children:"context（ createContext + useContext ）"}),"跨层级方式完成。"]}),"\n",(0,s.jsx)(n.li,{children:"有注册，就要有卸载，确保数据的唯一、整洁，防止未卸载的数据影响组件本身，造成内存泄漏。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"以上就是 CheckCard 组件的制作流程。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let p=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F19.%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BD%9CCheckCard%EF%BC%9A%E5%A4%9A%E9%80%89%E5%8D%A1%E7%89%87.md"]={toc:[{text:"1. 基本布局",id:"1-基本布局",depth:2},{text:"2. 额外信息",id:"2-额外信息",depth:2},{text:"3. 基本状态的改变",id:"3-基本状态的改变",depth:2},{text:"4. 加载状态",id:"4-加载状态",depth:2},{text:"1. 数据传递",id:"1-数据传递",depth:2},{text:"2. 注册与卸载",id:"2-注册与卸载",depth:2},{text:"3. 使 CheckCard 受控",id:"3-使-checkcard-受控",depth:2},{text:"4. 配合 Form 组件使用",id:"4-配合-form-组件使用",depth:2},{text:"5. 集中控制 loading",id:"5-集中控制-loading",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);