"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["33848"],{520501:function(e,n,t){t.r(n),t.d(n,{default:()=>i});var s=t(552676),c=t(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"14实战环节typescript--react",children:["14.实战环节：TypeScript + React",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14实战环节typescript--react",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"由于前端框架的存在，通常情况下我们在编写页面时，并不是在写原生的 JS 代码，而更多是如 React 的 JSX 和 Vue 的 SFC（单文件）这样，基于 JS 衍生出的代码。这些特殊的代码当然不能被浏览器直接执行，而是需要经过编译，得到纯 JS 代码。而我们学习了这么多 TypeScript 的知识后，肯定会感到 TS 与 JS 的关系之紧密，那么，上面这些特殊的代码能否基于 TS 来衍生呢？"}),"\n",(0,s.jsx)(n.p,{children:"答案是肯定的，最经典的示例就是基于 TypeScript 书写的 JSX，我们很自然地称之为 TSX。自然到什么程度呢，React 团队只需要提供 React 的 TS 类型声明，你就能够很简单地从 JSX 迁移到 TSX，同时享受到由 TS 提供的原汁原味的类型检查——这也是为什么我们选择 React 来作为 TS 在前端框架的应用示例。"}),"\n",(0,s.jsx)(n.p,{children:"在这一节中，我们会从创建工程开始，一步步介绍 React + TypeScript 的开发过程中有哪些注意事项，React 的类型声明应该如何使用等等。"}),"\n",(0,s.jsx)(n.p,{children:"在第一步创建阶段，你有两个脚手架可以选择：由 React 团队官方提供的 create-react-app 和 Vite 团队提供的 create-vite。对于入门阶段来说，选择哪一个并没有明显区别，因为它们的起始模板都足够简单但也足够全面。这里我们选择 create-vite 来作为示例，首先运行这个命令，并选择 React 与 TypeScript："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx create-vite\n"})}),"\n",(0,s.jsx)(n.p,{children:"它创建的文件目录大概是这么个结构："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"├── index.html\n├── package.json\n├── public\n│   └── vite.svg\n├── src\n│   ├── App.css\n│   ├── App.tsx\n│   ├── assets\n│   │   └── react.svg\n│   ├── index.css\n│   ├── main.tsx\n│   └── vite-env.d.ts\n├── tsconfig.json\n├── tsconfig.node.json\n└── vite.config.ts\n"})}),"\n",(0,s.jsx)(n.p,{children:"让我们先看看，这个初始化的项目里都包括了哪些类型的文件。首先是 .tsx 文件，我们打开 App.tsx 看看内容："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport reactLogo from './assets/react.svg'\nimport viteLogo from '/vite.svg'\nimport './App.css'\n\nfunction App() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <>\n      {/* 省略 */}\n    </>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后是 .d.ts 文件，前面我们已经了解过，这就是类型声明文件，我们打开 vite-env.d.ts 文件，看看一个 React 工程需要哪些类型声明才能正常运转？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'/// <reference types="vite/client" />\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这里它使用了三斜线指令来导入 ",(0,s.jsx)(n.code,{children:"vite/client"})," 下的类型定义，我们不需要了解具体使用，只需要知道其作用是将 npm 包 'vite' 下的 'client.d.ts' 文件中的类型声明导入即可，直接将其内部的类型定义粘贴个简化版本看看："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// CSS modules\ntype CSSModuleClasses = { readonly [key: string]: string }\n\ndeclare module '*.module.css' {\n  const classes: CSSModuleClasses\n  export default classes\n}\n\n// CSS\ndeclare module '*.css' {\n  const css: string\n  export default css\n}\n\n// images\ndeclare module '*.png' {\n  const src: string\n  export default src\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，这里的类型声明主要是提供了你导入 ",(0,s.jsx)(n.code,{children:".module.css"}),"，",(0,s.jsx)(n.code,{children:".css"}),"，",(0,s.jsx)(n.code,{children:".png"})," 这些非常规代码文件时的类型声明。毕竟，虽然我们导入了它们，但实际上还需要经过编译工具处理后才能在页面中正常展示。而如果缺少这些非标准文件的类型声明，在 TS 文件中我们会得到一片一片的报错。"]}),"\n",(0,s.jsx)(n.p,{children:"这两类文件就是最核心的逻辑存放了，接下来我们就可以来学习，如何让 JSX 与 TypeScript 进行融合了。先想想 TypeScript 最重要的优势是什么？无疑是类型约束带来的安全性，那么在 React 项目里什么地方最需要进行类型约束？当然是组件属性了！我们可以使用 TypeScript，描述一个组件能够接受的属性有哪些，分别又是什么类型，这样就能够避免传入了错误的属性时组件崩溃了。在 React 中，我们可以使用 React.FC 类型来描述一个函数式组件的类型，并通过它为属性类型预留的泛型坑位，来描述这个组件的属性类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import * as React from 'react';\n\ninterface HomeProps {\n  owner: string;\n}\n\nconst Home: React.FC<HomeProps> = ({ owner }) => {\n  return <>Home of {owner}</>;\n};\n\nconst App1: React.FC = () => {\n  // √\n  return <Home owner='me' />;\n};\n\nconst App2: React.FC = () => {\n  // X 不能将类型“number”分配给类型“string”。\n  return <Home owner={599} />;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"除了这里，再想想还有什么地方我们会迫切地需要类型？前端页面中最重要的一个概念就是状态管理，而在 React 中，我们接触状态管理最常用的方式就是 React Hooks 中的 useState："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const [count, setCount] = useState(0)\n  return <></>\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"它同样为你预留了泛型坑位："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const [count, setCount] = useState<number>(0)\n  return <></>\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个例子看起来是否有点多此一举？TypeScript 会自动地尝试从你的输入值中推导实际的类型，比如这里其实是可以推导出 number 类型的，但如果说你的初始值是一个空数组，那么 TypeScript 就无能为力，只能推导出一个 ",(0,s.jsx)(n.code,{children:"never[]"})," 类型了："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  // never[]\n  const [list, setList] = useState([]);\n  return <></>;\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时指定类型就显得尤为重要了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  // never[]\n  const [list, setList] = useState<string[]>([]);\n\n  useEffect(() => {\n    // x，对于每个元素，都会提示 不能将类型“number”分配给类型“string”。\n    setList([1, 2, 3]);\n  });\n\n  return <></>;\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类似的，useRef 中也允许你传入一个类型参数，比如我们最常见的使用 ref 来存储 DOM 元素："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const Container = () => {\n  const domRef = useRef<HTMLDivElement>(null);\n\n  const operateRef = () => {\n    // element 能被推导为 HTMLDivElement | null 类型\n    domRef.current?.getBoundingClientRect();\n  };\n\n  return <div ref={domRef}></div>;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"在这一节，我们学习了 TypeScript 结合 React 的实战，从一个 Vite React 项目开始，我们一步步了解了一个 TypeScript + React 工程内各个文件的作用，Vite 为我们内置的 CSS 与 CSS Modules 类型声明的作用，以及 React 的 JSX 中我们可以添加类型的地方——当然，别忘记要把它升级成 TSX。在下一节，我们会继续了解 TypeScript 的实战场景——使用 TypeScript 来开发一个 npm 包。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}let i=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F14.%E5%AE%9E%E6%88%98%E7%8E%AF%E8%8A%82%EF%BC%9ATypeScript%20%2B%20React.md"]={toc:[],title:"14.实战环节：TypeScript + React",headingTitle:"14.实战环节：TypeScript + React",frontmatter:{}}}}]);