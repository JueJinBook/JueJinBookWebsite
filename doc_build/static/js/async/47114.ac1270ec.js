"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["47114"],{554858:function(e,n,d){d.r(n),d.d(n,{default:()=>h});var c=d(552676),i=d(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",ul:"ul",li:"li",h3:"h3",pre:"pre"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"21vue-常考基础知识点",children:["21.Vue 常考基础知识点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21vue-常考基础知识点",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这一章节我们将来学习 Vue 的一些经常考到的基础知识点。"}),"\n",(0,c.jsxs)(n.h2,{id:"生命周期钩子函数",children:["生命周期钩子函数",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生命周期钩子函数",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"beforeCreate"})," 钩子函数调用的时候，是获取不到 ",(0,c.jsx)(n.code,{children:"props"})," 或者 ",(0,c.jsx)(n.code,{children:"data"})," 中的数据的，因为这些数据的初始化都在 ",(0,c.jsx)(n.code,{children:"initState"})," 中。"]}),"\n",(0,c.jsxs)(n.p,{children:["然后会执行 ",(0,c.jsx)(n.code,{children:"created"})," 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来会先执行 ",(0,c.jsx)(n.code,{children:"beforeMount"})," 钩子函数，开始创建 VDOM，最后执行 ",(0,c.jsx)(n.code,{children:"mounted"})," 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来是数据更新时会调用的钩子函数 ",(0,c.jsx)(n.code,{children:"beforeUpdate"})," 和 ",(0,c.jsx)(n.code,{children:"updated"}),"，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外还有 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 独有的生命周期，分别为 ",(0,c.jsx)(n.code,{children:"activated"})," 和 ",(0,c.jsx)(n.code,{children:"deactivated"})," 。用 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 ",(0,c.jsx)(n.code,{children:"deactivated"})," 钩子函数，命中缓存渲染后会执行 ",(0,c.jsx)(n.code,{children:"actived"})," 钩子函数。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后就是销毁组件的钩子函数 ",(0,c.jsx)(n.code,{children:"beforeDestroy"})," 和 ",(0,c.jsx)(n.code,{children:"destroyed"}),"。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 ",(0,c.jsx)(n.code,{children:"destroyed"})," 钩子函数。"]}),"\n",(0,c.jsxs)(n.h2,{id:"组件通信",children:["组件通信",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件通信",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"组件通信一般分为以下几种情况："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"父子组件通信"}),"\n",(0,c.jsx)(n.li,{children:"兄弟组件通信"}),"\n",(0,c.jsx)(n.li,{children:"跨多层级组件通信"}),"\n",(0,c.jsx)(n.li,{children:"任意组件"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。"}),"\n",(0,c.jsxs)(n.h3,{id:"父子通信",children:["父子通信",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#父子通信",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["父组件通过 ",(0,c.jsx)(n.code,{children:"props"})," 传递数据给子组件，子组件通过 ",(0,c.jsx)(n.code,{children:"emit"})," 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。"]}),"\n",(0,c.jsxs)(n.p,{children:["这种父子通信方式也就是典型的单向数据流，父组件通过 ",(0,c.jsx)(n.code,{children:"props"})," 传递数据，子组件不能直接修改 ",(0,c.jsx)(n.code,{children:"props"}),"， 而是必须通过发送事件的方式告知父组件修改数据。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外这两种方式还可以使用语法糖 ",(0,c.jsx)(n.code,{children:"v-model"})," 来直接实现，因为 ",(0,c.jsx)(n.code,{children:"v-model"})," 默认会解析成名为 ",(0,c.jsx)(n.code,{children:"value"})," 的 ",(0,c.jsx)(n.code,{children:"prop"})," 和名为 ",(0,c.jsx)(n.code,{children:"input"})," 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。"]}),"\n",(0,c.jsxs)(n.p,{children:["当然我们还可以通过访问 ",(0,c.jsx)(n.code,{children:"$parent"})," 或者 ",(0,c.jsx)(n.code,{children:"$children"})," 对象来访问组件实例中的方法和数据。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外如果你使用 Vue 2.3 及以上版本的话还可以使用 ",(0,c.jsx)(n.code,{children:"$listeners"})," 和 ",(0,c.jsx)(n.code,{children:".sync"})," 这两个属性。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"$listeners"})," 属性会将父组件中的 (不含 ",(0,c.jsx)(n.code,{children:".native"})," 修饰器的) ",(0,c.jsx)(n.code,{children:"v-on"})," 事件监听器传递给子组件，子组件可以通过访问 ",(0,c.jsx)(n.code,{children:"$listeners"})," 来自定义监听器。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:".sync"})," 属性是个语法糖，可以很简单的实现子组件与父组件通信"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'\x3c!--父组件中--\x3e\n<input :value.sync="value" />\n\x3c!--以上写法等同于--\x3e\n<input :value="value" @update:value="v => value = v"></comp>\n\x3c!--子组件中--\x3e\n<script>\n  this.$emit(\'update:value\', 1)\n<\/script>\n'})}),"\n",(0,c.jsxs)(n.h3,{id:"兄弟组件通信",children:["兄弟组件通信",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#兄弟组件通信",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["对于这种情况可以通过查找父组件中的子组件实现，也就是 ",(0,c.jsx)(n.code,{children:"this.$parent.$children"}),"，在 ",(0,c.jsx)(n.code,{children:"$children"})," 中可以通过组件 ",(0,c.jsx)(n.code,{children:"name"})," 查询到需要的组件实例，然后进行通信。"]}),"\n",(0,c.jsxs)(n.h3,{id:"跨多层次组件通信",children:["跨多层次组件通信",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#跨多层次组件通信",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["对于这种情况可以使用 Vue 2.2 新增的 API ",(0,c.jsx)(n.code,{children:"provide / inject"}),"，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。"]}),"\n",(0,c.jsx)(n.p,{children:"假设有父组件 A，然后有一个跨多层级的子组件 B"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 父组件 A\nexport default {\n  provide: {\n    data: 1\n  }\n}\n// 子组件 B\nexport default {\n  inject: ['data'],\n  mounted() {\n    // 无论跨几层都能获得父组件的 data 属性\n    console.log(this.data) // => 1\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"任意组件",children:["任意组件",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#任意组件",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况"}),"\n",(0,c.jsxs)(n.h2,{id:"extend-能做什么",children:["extend 能做什么",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#extend-能做什么",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 ",(0,c.jsx)(n.code,{children:"$mount"})," 一起使用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 创建组件构造器\nlet Component = Vue.extend({\n  template: '<div>test</div>'\n})\n// 挂载到 #app 上\nnew Component().$mount('#app')\n// 除了上面的方式，还可以用来扩展已有的组件\nlet SuperComponent = Vue.extend(Component)\nnew SuperComponent({\n    created() {\n        console.log(1)\n    }\n})\nnew SuperComponent().$mount('#app')\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"mixin-和-mixins-区别",children:["mixin 和 mixins 区别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-和-mixins-区别",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"mixin"})," 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Vue.mixin({\n    beforeCreate() {\n        // ...逻辑\n        // 这种方式会影响到每个组件的 beforeCreate 钩子函数\n    }\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["虽然文档不建议我们在应用中直接使用 ",(0,c.jsx)(n.code,{children:"mixin"}),"，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ",(0,c.jsx)(n.code,{children:"ajax"})," 或者一些工具函数等等。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"mixins"})," 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 ",(0,c.jsx)(n.code,{children:"mixins"})," 混入代码，比如上拉下拉加载数据这种逻辑等等。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外需要注意的是 ",(0,c.jsx)(n.code,{children:"mixins"})," 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 ",(0,c.jsx)(n.a,{href:"https://cn.vuejs.org/v2/guide/mixins.html",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"computed-和-watch-区别",children:["computed 和 watch 区别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#computed-和-watch-区别",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"computed"})," 是计算属性，依赖其他属性计算值，并且 ",(0,c.jsx)(n.code,{children:"computed"})," 的值有缓存，只有当计算值变化才会返回内容。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"watch"})," 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。"]}),"\n",(0,c.jsxs)(n.p,{children:["所以一般来说需要依赖别的属性来动态获得值的时候可以使用 ",(0,c.jsx)(n.code,{children:"computed"}),"，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 ",(0,c.jsx)(n.code,{children:"watch"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外 ",(0,c.jsx)(n.code,{children:"computed"})," 和 ",(0,c.jsx)(n.code,{children:"watch"})," 还都支持对象的写法，这种方式知道的人并不多。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"vm.$watch('obj', {\n    // 深度遍历\n    deep: true,\n    // 立即触发\n    immediate: true,\n    // 执行的函数\n    handler: function(val, oldVal) {}\n})\nvar vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    aPlus: {\n      // this.aPlus 时触发\n      get: function () {\n        return this.a + 1\n      },\n      // this.aPlus = 1 时触发\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"keep-alive-组件有什么作用",children:["keep-alive 组件有什么作用",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#keep-alive-组件有什么作用",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 组件包裹需要保存的组件。"]}),"\n",(0,c.jsxs)(n.p,{children:["对于 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 组件来说，它拥有两个独有的生命周期钩子函数，分别为 ",(0,c.jsx)(n.code,{children:"activated"})," 和 ",(0,c.jsx)(n.code,{children:"deactivated"})," 。用 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 ",(0,c.jsx)(n.code,{children:"deactivated"})," 钩子函数，命中缓存渲染后会执行 ",(0,c.jsx)(n.code,{children:"actived"})," 钩子函数。"]}),"\n",(0,c.jsxs)(n.h2,{id:"v-show-与-v-if-区别",children:["v-show 与 v-if 区别",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v-show-与-v-if-区别",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"v-show"})," 只是在 ",(0,c.jsx)(n.code,{children:"display: none"})," 和 ",(0,c.jsx)(n.code,{children:"display: block"})," 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 ",(0,c.jsx)(n.code,{children:"v-show"})," 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"v-if"})," 的话就得说到 Vue 底层的编译了。当属性初始为 ",(0,c.jsx)(n.code,{children:"false"})," 时，组件就不会被渲染，直到条件为 ",(0,c.jsx)(n.code,{children:"true"}),"，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。"]}),"\n",(0,c.jsxs)(n.p,{children:["并且基于 ",(0,c.jsx)(n.code,{children:"v-if"})," 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。"]}),"\n",(0,c.jsxs)(n.h2,{id:"组件中-data-什么时候可以使用对象",children:["组件中 data 什么时候可以使用对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件中-data-什么时候可以使用对象",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这道题目其实更多考的是 JS 功底。"}),"\n",(0,c.jsxs)(n.p,{children:["组件复用时所有组件实例都会共享 ",(0,c.jsx)(n.code,{children:"data"}),"，如果 ",(0,c.jsx)(n.code,{children:"data"})," 是对象的话，就会造成一个组件修改 ",(0,c.jsx)(n.code,{children:"data"})," 以后会影响到其他所有组件，所以需要将 ",(0,c.jsx)(n.code,{children:"data"})," 写成函数，每次用到就调用一次函数获得新的数据。"]}),"\n",(0,c.jsxs)(n.p,{children:["当我们使用 ",(0,c.jsx)(n.code,{children:"new Vue()"})," 的方式的时候，无论我们将 ",(0,c.jsx)(n.code,{children:"data"})," 设置为对象还是函数都是可以的，因为 ",(0,c.jsx)(n.code,{children:"new Vue()"})," 的方式是生成一个根组件，该组件不会复用，也就不存在共享 ",(0,c.jsx)(n.code,{children:"data"})," 的情况了。"]}),"\n",(0,c.jsxs)(n.h1,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"总的来说这一章节的内容更多的偏向于 Vue 的基础，下一章节我们将来了解一些原理性方面的知识。"})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(s,{...e})}):s(e)}let h=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F21.Vue%20%E5%B8%B8%E8%80%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9.md"]={toc:[{text:"生命周期钩子函数",id:"生命周期钩子函数",depth:2},{text:"组件通信",id:"组件通信",depth:2},{text:"父子通信",id:"父子通信",depth:3},{text:"兄弟组件通信",id:"兄弟组件通信",depth:3},{text:"跨多层次组件通信",id:"跨多层次组件通信",depth:3},{text:"任意组件",id:"任意组件",depth:3},{text:"extend 能做什么",id:"extend-能做什么",depth:2},{text:"mixin 和 mixins 区别",id:"mixin-和-mixins-区别",depth:2},{text:"computed 和 watch 区别",id:"computed-和-watch-区别",depth:2},{text:"keep-alive 组件有什么作用",id:"keep-alive-组件有什么作用",depth:2},{text:"v-show 与 v-if 区别",id:"v-show-与-v-if-区别",depth:2},{text:"组件中 data 什么时候可以使用对象",id:"组件中-data-什么时候可以使用对象",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);