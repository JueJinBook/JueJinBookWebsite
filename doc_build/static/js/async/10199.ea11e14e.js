"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10199"],{253771:function(n,e,t){t.r(e),t.d(e,{default:()=>c});var s=t(552676),r=t(740453);let o=t.p+"static/image/3cc78bd41687fdf90934f48d5ecc1dbb.4c47edf6.webp";function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",strong:"strong",blockquote:"blockquote",ul:"ul",li:"li",pre:"pre",code:"code",ol:"ol"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"4基础篇自定义-hooks-开发响应式的-usestate",children:["4.基础篇｜自定义 Hooks 开发：响应式的 useState",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4基础篇自定义-hooks-开发响应式的-usestate",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"通过前两节的学习，我们已经知道如何使用 Hooks API 了，在 v16.8 中，官方还提出了一个 Hooks 我们没有讲到，就是自定义 Hooks。顾名思义，自定义 Hooks 是我们自己开发的。"}),"\n",(0,s.jsx)(e.p,{children:"通过本节课的学习，你将完全了解什么是自定义 Hooks、一个优秀的自定义 Hooks 该如何设计，以及如何设计一个具备响应式的 useState。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"自定义-hooks-究竟是什么",children:["自定义 Hooks 究竟是什么？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义-hooks-究竟是什么",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"react-hooks 是 React16.8 的产物，目的是增加代码的可复用性、逻辑性，并且解决函数式组件无状态的问题，这样既保留了函数式的简单，又解决了没有数据管理状态的缺陷。"}),"\n",(0,s.jsx)(e.p,{children:"而自定义 Hooks 是 react-hooks 基础上的一个扩展，它可以根据实际的业务场景、需求制定相应的 Hooks， 将对应的逻辑进行封装，从而具备逻辑性、复用性。"}),"\n",(0,s.jsxs)(e.p,{children:["从本质而言，",(0,s.jsx)(e.strong,{children:"Hooks 就是一个函数"}),"，可以简单地认为 Hooks 是用来处理一些通用性数据、逻辑的。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：既然 Hooks 是函数，那么它与普通函数又什么关系，与函数组件又有什么关系？"}),"\n",(0,s.jsx)(e.p,{children:"答：其实三者的关系十分紧密，也是一个比较容易混淆的点。先看下图"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"从图中可看出，普通函数加入 html（JSX 语法）就是函数组件，但这个组件无状态，也就是没有数据管理状态，而 Hooks 的作用就是让函数组件具备数据管理的能力。如果说函数组件是一辆车，那么 Hooks 就是油，驱动这辆车跑起来的燃料。"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Hooks 的驱动条件"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"所谓驱动条件，就是会改变数据源，从而驱动整个数据状态。通常用 useState、useReducer 为驱动条件，驱动整个自定义 Hooks。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"通用模式"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"自定义 Hooks 的名称通常以 use 开头，我们设计为："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"const [ xxx, ...] = useXXX(参数一，参数二...)"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"正所谓光说不练假把式，接下来我们正式进入自定义 Hooks 的讲解，直接开搞！！！"}),"\n",(0,s.jsxs)(e.h2,{id:"uselatest",children:["useLatest",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#uselatest",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"useLatest：永远返回最新的值，可以避免闭包问题。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：什么是闭包？"}),"\n",(0,s.jsx)(e.p,{children:"答：闭包是指有权访问另一个函数作用域的变量的函数。"}),"\n",(0,s.jsx)(e.p,{children:"另外，关于 Hooks 闭包的问题，在之后讲解 useEffect 的时候详细介绍，届时会用到这个钩子。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"示例："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useEffect } from "react";\n\nexport default () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      console.log("count:", count);\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <>\n      <div>自定义Hooks：useLatestt</div>\n      <div>count: {count}</div>\n    </>\n  );\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"大家可以猜想下，打印出的 count 值是什么？以及页面中的 count 值是多少？"}),"\n",(0,s.jsx)(e.p,{children:"答案：打印出的 count 为 0，页面中的 count 为 1（具体原因我们在讲 useEffect 源码篇时提及，这里先看解决方法），效果如下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"解决方法："})}),"\n",(0,s.jsxs)(e.p,{children:["利用 useRef 的高级用法：",(0,s.jsx)(e.strong,{children:"缓存数据"}),"去解决，并且这种方式在",(0,s.jsx)(e.code,{children:"react-redux"}),"源码中进行应用，而不止是获取元素属性。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useRef } from "react";\n\nconst useLatest = <T,>(value: T): { readonly current: T } => {\n  const ref = useRef(value);\n  ref.current = value;\n\n  return ref;\n};\n\nexport default useLatest;\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"一起来看下这段代码 <T,>(value: T): { readonly current: T }。"}),"\n",(0,s.jsx)(e.p,{children:"从作用来看，这个钩子返回的永远是最新值，也就是说，这个钩子的入参与出参都是这个值，但这个值我们却不知道是 string、number 还是其他类型的值，这时，我们就希望它传入的值与返回的值是同种类型。"}),"\n",(0,s.jsxs)(e.p,{children:["简单来说，",(0,s.jsx)(e.strong,{children:"无论传入什么类型，都要返回对应的类型"}),"，这种情况必是泛型。"]}),"\n",(0,s.jsx)(e.p,{children:":{readonly current: T} 代表返回结果的类型，由于我们使用的为 useRef ，所以，返回的值都在 current 内，那么 current 的类型就是 T。"}),"\n",(0,s.jsx)(e.p,{children:"至于 readonly 则是代表的只读不可修改，因为固定模式为 current 对象，所以这里使用 readonly 。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"验证："})}),"\n",(0,s.jsx)(e.p,{children:"我们用 useLatest 包一下 count，如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:' const ref = useLatest(count);\n \n    useEffect(() => {\n        const interval = setInterval(() => {\n          console.log("count:", count);\n          console.log("ref:", ref);\n          setCount(ref.current + 1);\n        }, 1000);\n        return () => clearInterval(interval);\n    }, []);\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"最终效果："})}),"\n",(0,s.jsx)(e.p,{children:"此时就能拿到 count 的最新值。"}),"\n",(0,s.jsxs)(e.h2,{id:"usemount-和-useunmount",children:["useMount 和 useUnmount",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usemount-和-useunmount",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useMount："})," 只在组件初始化执行的 hook。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useUnmount"}),"：只在组件卸载时的 hook。"]}),"\n",(0,s.jsx)(e.p,{children:"两者都是根据 useEffect 演化而来，而 useUnmount 需要注意一下，这里传入的函数需要保持最新值，直接使用 useLatest 即可："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// useMount\nimport { useEffect } from "react";\n\nconst useMount = (fn: () => void) => {\n  useEffect(() => {\n    fn?.();\n  }, []);\n};\n\nexport default useMount;\n\n// useUnmount\nimport { useEffect } from "react";\nimport useLatest from "../useLatest";\n\nconst useUnmount = (fn: () => void) => {\n  const fnRef = useLatest(fn);\n\n  useEffect(\n    () => () => {\n      fnRef.current();\n    },\n    []\n  );\n};\n\nexport default useUnmount;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"示例："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState } from "react";\nimport { useMount, useUnmount } from "../../hooks";\n\nimport { Button, message } from "antd";\n\nconst Child = () => {\n  useMount(() => {\n    message.info("首次渲染");\n  });\n\n  useUnmount(() => {\n    message.info("组件已卸载");\n  });\n\n  return <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>;\n};\n\nconst Index = () => {\n  const [flag, setFlag] = useState<boolean>(false);\n\n  return (\n    <div>\n      <Button type="primary" onClick={() => setFlag((v) => !v)}>\n        切换 {flag ? "unmount" : "mount"}\n      </Button>\n      {flag && <Child />}\n    </div>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"useunmountedref",children:["useUnmountedRef",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#useunmountedref",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useUnmountedRef："})," 获取当前组件是否卸载，这个钩子的思路也很简单，只需要利用 useEffect 的状态，来保存对应的值就 ok 了。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useEffect, useRef } from "react";\n\nconst useUnmountedRef = (): { readonly current: boolean } => {\n  const unmountedRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    unmountedRef.current = false;\n    return () => {\n      unmountedRef.current = true;\n    };\n  }, []);\n\n  return unmountedRef;\n};\n\nexport default useUnmountedRef;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"示例："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState } from "react";\nimport { useUnmountedRef, useUnmount, useMount } from "../../hooks";\nimport { Button } from "antd";\n\nconst Child = () => {\n  const unmountedRef = useUnmountedRef();\n\n  useMount(() => {\n    console.log("初始化：", unmountedRef);\n  });\n  useUnmount(() => {\n    console.log("卸载：", unmountedRef);\n  });\n\n  return <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>;\n};\n\nconst Index = () => {\n  const [flag, setFlag] = useState<boolean>(false);\n\n  return (\n    <div>\n      <Button type="primary" onClick={() => setFlag((v) => !v)}>\n        切换 {flag ? "卸载" : "初始化"}\n      </Button>\n      {flag && <Child />}\n    </div>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"usesafestate",children:["useSafeState",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usesafestate",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"useSafeState：使用方法与 useState 的用法完全一致，但在组件卸载后异步回调内的 setState 不再执行，这样可以避免因组件卸载后更新状态而导致的内存泄漏。"}),"\n",(0,s.jsx)(e.p,{children:"这里要注意的是卸载后的异步条件，所以直接使用 useUnmountedRef 即可，代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useCallback, useState } from "react";\nimport type { Dispatch, SetStateAction } from "react";\nimport useUnmountedRef from "../useUnmountedRef";\n\nfunction useSafeState<S>(\n  initialState: S | (() => S)\n): [S, Dispatch<SetStateAction<S>>];\nfunction useSafeState<S = undefined>(): [\n  S | undefined,\n  Dispatch<SetStateAction<S | undefined>>\n];\nfunction useSafeState<S>(initialState?: S | (() => S)) {\n  const unmountedRef: { current: boolean } = useUnmountedRef();\n  const [state, setState] = useState(initialState);\n  const setCurrentState = useCallback((currentState: any) => {\n    if (unmountedRef.current) return;\n    setState(currentState);\n  }, []);\n\n  return [state, setCurrentState] as const;\n}\n\nexport default useSafeState;\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"之所以讲 useSafeState，是因为虽然它本身的实现并不难，但在真实的环境中，我们经常使用。所以在这里，主要介绍一下 ts，让不熟悉的小伙伴尽快熟悉起来，方便我们后面的代码的阅读。"}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"首先，这个钩子和 useState 的用法完全一致，所以我们的入参和出参保持一致。这里使用泛型与 useLatest 的原因一样；"}),"\n",(0,s.jsx)(e.li,{children:"入参：initialState，这个参数并不是一定必需的，所以存在两种情况，一种是 S（传入什么就是什么类型）、另一种是 undefined，其中 S 还分为是否为函数。所以标准的写法是函数重载，简单理解为：可以在同一个函数下定义多种类型值，最后汇总到一块；"}),"\n",(0,s.jsxs)(e.li,{children:["返参：",(0,s.jsx)(e.code,{children:"[state, setCurrentState] as const"}),"，这种写法叫做断言，所谓断言，通过 as 这个参数告诉编辑器，就是这种类型，不用你再次校验。是不是很任性，像极了你的女朋友，而 ",(0,s.jsx)(e.code,{children:"as const"})," 是标记为不可变，即这个数组的长度与成员类型均不可再进行修改，可翻译为 readonly ",(0,s.jsx)(e.code,{children:"[S, Dispatch<SetStateAction<S>>]"}),"，这样可能更加好理解一点；"]}),"\n",(0,s.jsxs)(e.li,{children:["至于 ",(0,s.jsx)(e.code,{children:"Dispatch<SetStateAction<S>>"})," 这种写法是固定的，就是对应 useState 的第二个参数。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"除此之外，这里还用到了 useCallback。在之前的介绍中，我说要配合使用 React.Memo，那么这里为什么要用呢？"}),"\n",(0,s.jsx)(e.p,{children:"其实这里要特意说明下，如果是在开发自定义 Hooks 的时候，可直接使用 useCallback，而在具体的业务场景中，useCallback 需要配合 React.Memo 使用，具体为何，在之后介绍 useCallBack 源码篇中进行说明，现在只需要记住即可。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"useupdate",children:["useUpdate",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#useupdate",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useUpdate："})," 强制组件重新渲染，最终返回一个函数。"]}),"\n",(0,s.jsx)(e.p,{children:"这就回到开头所说的问题，是什么驱动函数式的更新：用 useState、useReducer 作为更新条件，这里以 useReducer 做演示，毕竟大家对 useState 都很熟悉。"}),"\n",(0,s.jsx)(e.p,{children:"具体的做法是：搞个累加器，无关的变量，触发一次，就累加 1，这样就会强制刷新。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useReducer } from "react";\n\nfunction useUpdate(): () => void {\n  const [, update] = useReducer((num: number): number => num + 1, 0);\n\n  return update;\n}\n\nexport default useUpdate;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"测试："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'import { useUpdate } from "../../hooks";\nimport { Button, message } from "antd";\n\nconst Index = () => {\n  const update = useUpdate();\n\n  return (\n    <div>\n      <div>时间：{Date.now()}</div>\n      <Button\n        type="primary"\n        onClick={() => {\n          update();\n        }}\n      >\n        更新\n      </Button>\n    </div>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"usecreation",children:["useCreation",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usecreation",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useCreation"}),"：强化 useMemo 和 useRef，用法与 useMemo 一样，一般用于性能优化。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"useCreation 如何增强："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"useMemo 的第一个参数 fn，会缓存对应的值，那么这个值就有可能拿不到最新的值，而 useCreation 拿到的值永远都是最新值；"}),"\n",(0,s.jsxs)(e.li,{children:["useRef 在创建复杂常量的时候，会出现潜在的性能隐患（如：实例化 ",(0,s.jsx)(e.code,{children:"new Subject"}),"），但 useCreation 可以有效地避免。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"来简单分析一下如何实现 useCreation:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"明确出参入参：useCreation 主要强化的是 useMemo，所以出入参应该保持一致。出参返回对应的值，入参共有两个，第一个对应函数，第二个对应数组（此数组可变触发）；"}),"\n",(0,s.jsx)(e.li,{children:"最新值处理：针对 useMemo 可能拿不到最新值的情况，可直接依赖 useRef 的高级用法来保存值，这样就会永远保存最新值；"}),"\n",(0,s.jsx)(e.li,{children:"触发更新条件：比较每次传入的数组，与之前对比，若不同，则触发、更新对应的函数。"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useRef } from "react";\nimport type { DependencyList } from "react";\n\nconst depsAreSame = (\n  oldDeps: DependencyList,\n  deps: DependencyList\n): boolean => {\n  if (oldDeps === deps) return true;\n\n  for (let i = 0; i < oldDeps.length; i++) {\n    if (!Object.is(oldDeps[i], deps[i])) return false;\n  }\n\n  return true;\n};\n\nconst useCreation = <T,>(fn: () => T, deps: DependencyList) => {\n  const { current } = useRef({\n    deps,\n    obj: undefined as undefined | T,\n    initialized: false,\n  });\n\n  if (current.initialized === false || !depsAreSame(current.deps, deps)) {\n    current.deps = deps;\n    current.obj = fn();\n    current.initialized = true;\n  }\n\n  return current.obj as T;\n};\n\nexport default useCreation;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"分析 useRef："})}),"\n",(0,s.jsxs)(e.p,{children:["useRef 的保存值应该有哪些？其中 ",(0,s.jsx)(e.code,{children:"deps"})," 和 ",(0,s.jsx)(e.code,{children:"obj"})," 不必多说，一个是数组，一个是数据，是必须要保存的，除此之外，还需要保存 ",(0,s.jsx)(e.code,{children:"initialized（初始化条件）"}),"，这个参数的作用是应对首次保存值，之后判断是否保存，根据 deps 判断即可。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"测试："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import React, { useState } from "react";\nimport { Button } from "antd";\nimport { useCreation } from "../../hooks";\n\nconst Index: React.FC<any> = () => {\n  const [flag, setFlag] = useState<boolean>(false);\n\n  const getNowData = () => {\n    return Math.random();\n  };\n\n  const nowData = useCreation(() => getNowData(), []);\n\n  return (\n    <>\n      <div>正常的函数： {getNowData()}</div>\n      <div>useCreation包裹后的： {nowData}</div>\n      <Button\n        type="primary"\n        onClick={() => {\n          setFlag((v) => !v);\n        }}\n      >\n        切换状态{JSON.stringify(flag)}\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，当无关的变量刷新时，会影响 getNowData 产生的随机值，但不会影响经过 useCreation 包裹后的值，从而增强渲染时的性能问题。"}),"\n",(0,s.jsxs)(e.h2,{id:"usereactive",children:["useReactive",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usereactive",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"背景："})," 当我们开发组件或做功能复杂的页面时，会有大量的变量，再来看看 useState 的结构",(0,s.jsx)(e.code,{children:"const [count, setCount] = useState<number>(0)"}),"，假设要设置 10 个变量，那么我们是不是要设置 10 个这样的结构？"]}),"\n",(0,s.jsx)(e.p,{children:"有的小伙伴会说，值设置成对象不就好了吗？但我们设置的时候必须 setCount(v => {...v, count: 7}) 这样去写，也是比较麻烦的。"}),"\n",(0,s.jsx)(e.p,{children:"其次，我们用的值和设置的值分成了两个，这样也带来了不便，因此：useReactive 可以帮我们解决这个问题。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useReactive"}),"：一种具备响应式的 useState，用法与 useState 类似，但可以动态地设置值。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：什么是响应式？"}),"\n",(0,s.jsx)(e.p,{children:"答：响应式是指能及时更新的数据，比如 let count = 0; count = 7；那么此时 count 的值就为 7，这样的数据就是响应式。"}),"\n",(0,s.jsx)(e.p,{children:"这里尤其注意一点，函数式组件是无法通过上面这种方式来更新视图，要牢记，有的小伙伴可能看着看着就懵了，觉得本来就这样，实际不然，所以一定要熟记概念。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"useReactive 如何设计："})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"useReactive 的入参、出参怎么设定？"}),"\n",(0,s.jsx)(e.li,{children:"如何制作成响应式数据？"}),"\n",(0,s.jsx)(e.li,{children:"如何使用 Ts 类型？如何优化 useReactive ？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"分析："})}),"\n",(0,s.jsxs)(e.p,{children:["useReactive 整体结构：",(0,s.jsx)(e.code,{children:"const state = useReactive({ count: 0 })"})," 。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"使用：state.count；"}),"\n",(0,s.jsx)(e.li,{children:"设置：state.count = 7。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"数据制作成响应式，实际上分两个步骤:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"如何检测值的改变，就是当 state.count = 7 设置后，怎样让 state.count 成为 7 ？"}),"\n",(0,s.jsx)(e.li,{children:"如何刷新视图，让页面看到效果？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"刷新视图用上述的 useUpdate 即可，而监测数据、改变数据可以使用 ES6 提供的 Proxy 和 Reflect 来处理。"}),"\n",(0,s.jsxs)(e.p,{children:["Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。可以这样理解，Proxy 就是在目标对象之前设置的一层",(0,s.jsx)(e.code,{children:"拦截"}),"，外界想要访问都要经过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。"]}),"\n",(0,s.jsx)(e.p,{children:"而 Reflect 与 Proxy 的功能类似，但只能保持 Object 的默认行为。"}),"\n",(0,s.jsx)(e.p,{children:"至于优化，直接用 useCreation 即可，配合 useLatest 来处理存放 initialState（初始值），用来确保值永远是最新值。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useUpdate, useCreation, useLatest } from "../index";\n\nconst observer = <T extends Record<string, any>>(\n  initialVal: T,\n  cb: () => void\n): T => {\n  const proxy = new Proxy<T>(initialVal, {\n    get(target, key, receiver) {\n      const res = Reflect.get(target, key, receiver);\n      return typeof res === "object"\n        ? observer(res, cb)\n        : Reflect.get(target, key);\n    },\n    set(target, key, val) {\n      const ret = Reflect.set(target, key, val);\n      cb();\n      return ret;\n    },\n  });\n\n  return proxy;\n};\n\nconst useReactive = <T extends Record<string, any>>(initialState: T): T => {\n  const ref = useLatest<T>(initialState);\n  const update = useUpdate();\n\n  const state = useCreation(() => {\n    return observer(ref.current, () => {\n      update();\n    });\n  }, []);\n\n  return state;\n};\n\nexport default useReactive;\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Ts 分析："})," 这里使用了一个新的的知识点：",(0,s.jsx)(e.code,{children:"Record<string, any>"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Record 的语法介绍："})," ",(0,s.jsx)(e.code,{children:"Record<K extends keyof any, T>"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"作用："})," 将 ",(0,s.jsx)(e.code,{children:"K"})," 中所有的属性转化为 ",(0,s.jsx)(e.code,{children:"T"})," 类型。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"举个例子："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"    interface Props {\n        name: string,\n        age: number\n    }\n\n    type InfoProps = 'JS' | 'TS'\n    \n    const Info: Record<InfoProps, Props> = {\n        JS: {\n            name: '小杜杜',\n            age: 7\n        },\n        TS: {\n            name: 'TypeScript',\n            age: 11\n        }\n    }\n"})}),"\n",(0,s.jsx)(e.p,{children:"也就是说，InfoProps 的每一项属性都包含 Props 的属性。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：为什么 Proxy 和 Reflect 联合使用？单独使用 Proxy 不行吗？"}),"\n",(0,s.jsxs)(e.p,{children:["答：ES6 中的 Proxy 和 Reflect 在平常的开发中可能运用的比较少，很多小伙伴可能并不了解，Proxy 和 Reflect 一般是对数据的劫持，有点类似于 ES5 中的 ",(0,s.jsx)(e.code,{children:"Object.defineProperty()"}),"，但功能要更加强大。"]}),"\n",(0,s.jsx)(e.p,{children:"两者联合使用的根本原因是：this 的指向，至于具体为什么，这里就不做过多的介绍，但要强调一点，Proxy 和 Reflect 的作用非常大，在 Vue/corejs 的源码中有大量的应用，掌握这两个 API 非常有必要。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"验证："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useReactive } from "../../hooks";\nimport { Button, Input } from "antd";\n\nconst Index = () => {\n  const state = useReactive<any>({\n    count: 0,\n    name: "大家好，我是小杜杜，一起玩转Hooks吧！",\n    flag: true,\n    arr: [],\n    bugs: ["小杜杜", "react", "hook"],\n    addBug(bug: string) {\n      this.bugs.push(bug);\n    },\n    get bugsCount() {\n      return this.bugs.length;\n    },\n  });\n\n  return (\n    <div>\n      <div style={{ fontWeight: "bold" }}>基本使用：</div>\n      <div style={{ marginTop: 8 }}> 对数字进行操作：{state.count}</div>\n      <div\n        style={{\n          margin: "8px 0",\n          display: "flex",\n          justifyContent: "flex-start",\n        }}\n      >\n        <Button type="primary" onClick={() => state.count++}>\n          加1\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.count--}\n        >\n          减1\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => (state.count = 7)}\n        >\n          设置为7\n        </Button>\n      </div>\n      <div style={{ marginTop: 8 }}> 对字符串进行操作：{state.name}</div>\n      <div\n        style={{\n          margin: "8px 0",\n          display: "flex",\n          justifyContent: "flex-start",\n        }}\n      >\n        <Button type="primary" onClick={() => (state.name = "小杜杜")}>\n          设置为小杜杜\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => (state.name = "Domesy")}\n        >\n          设置为Domesy\n        </Button>\n      </div>\n      <div style={{ marginTop: 8 }}>\n        {" "}\n        对布尔值进行操作：{JSON.stringify(state.flag)}\n      </div>\n      <div\n        style={{\n          margin: "8px 0",\n          display: "flex",\n          justifyContent: "flex-start",\n        }}\n      >\n        <Button type="primary" onClick={() => (state.flag = !state.flag)}>\n          切换状态\n        </Button>\n      </div>\n      <div style={{ marginTop: 8 }}>\n        {" "}\n        对数组进行操作：{JSON.stringify(state.arr)}\n      </div>\n      <div\n        style={{\n          margin: "8px 0",\n          display: "flex",\n          justifyContent: "flex-start",\n        }}\n      >\n        <Button\n          type="primary"\n          onClick={() => state.arr.push(Math.floor(Math.random() * 100))}\n        >\n          push\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.arr.pop()}\n        >\n          pop\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.arr.shift()}\n        >\n          shift\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.arr.unshift(Math.floor(Math.random() * 100))}\n        >\n          unshift\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.arr.reverse()}\n        >\n          reverse\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => state.arr.sort()}\n        >\n          sort\n        </Button>\n      </div>\n      <div style={{ fontWeight: "bold", marginTop: 8 }}>计算属性：</div>\n      <div style={{ marginTop: 8 }}>数量：{state.bugsCount} 个</div>\n      <div style={{ margin: "8px 0" }}>\n        <form\n          onSubmit={(e) => {\n            state.bug ? state.addBug(state.bug) : state.addBug("domesy");\n            state.bug = "";\n            e.preventDefault();\n          }}\n        >\n          <Input\n            type="text"\n            value={state.bug}\n            style={{ width: 200 }}\n            onChange={(e) => (state.bug = e.target.value)}\n          />\n          <Button type="primary" htmlType="submit" style={{ marginLeft: 8 }}>\n            增加\n          </Button>\n          <Button style={{ marginLeft: 8 }} onClick={() => state.bugs.pop()}>\n            删除\n          </Button>\n        </form>\n      </div>\n      <ul>\n        {state.bugs.map((bug: any, index: number) => (\n          <li key={index}>{bug}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"本节共讲解了 useLatest、useMount、useUnmount、useUnmountedRef、useSafeState、useUpdate、useCreation、useReactive 共 8 个 Hooks。"}),"\n",(0,s.jsx)(e.p,{children:"了解自定义 Hooks 的驱动条件和通用模式，配合 ts，讲解如何实现自定义 Hooks，大体步骤如下："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"确定自定义 Hooks 的入参和出参；"}),"\n",(0,s.jsx)(e.li,{children:"优化方面优先考虑 useCreation，函数优化使用 useCallback；"}),"\n",(0,s.jsx)(e.li,{children:"保存值使用 useLatest，如果复杂的话，依旧用 useRef 的高级用法处理，如 useCreation 的实现；"}),"\n",(0,s.jsx)(e.li,{children:"最后使用 ts 来优化类型，因为是通用的 Hooks，所以基本都会使用泛型这一概念，如果对 ts 不清楚，建议多看看 ts 的语法，因为 ts 也是主流，在现在的项目中基本都会使用 ts。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"最后再说一句：当我们自己想实现一个这样的功能，该如何思考？方法有的时候比结果更为重要，所以建议看文章的小伙伴都能亲自实现一遍，加深对 Hooks 的感悟。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(i,{...n})}):i(n)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F4.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E5%BC%80%E5%8F%91%EF%BC%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%20useState.md"]={toc:[{text:"自定义 Hooks 究竟是什么？",id:"自定义-hooks-究竟是什么",depth:2},{text:"useLatest",id:"uselatest",depth:2},{text:"useMount 和 useUnmount",id:"usemount-和-useunmount",depth:2},{text:"useUnmountedRef",id:"useunmountedref",depth:2},{text:"useSafeState",id:"usesafestate",depth:2},{text:"useUpdate",id:"useupdate",depth:2},{text:"useCreation",id:"usecreation",depth:2},{text:"useReactive",id:"usereactive",depth:2},{text:"小结",id:"小结",depth:2}],title:"4.基础篇｜自定义 Hooks 开发：响应式的 useState",headingTitle:"4.基础篇｜自定义 Hooks 开发：响应式的 useState",frontmatter:{}}}}]);