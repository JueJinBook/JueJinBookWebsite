"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85742"],{389367:function(n,e,s){s.r(e),s.d(e,{default:()=>i});var c=s(552676),r=s(740453);function o(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",strong:"strong",pre:"pre",blockquote:"blockquote",h3:"h3",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"8-基础篇函数千变万化的特殊对象",children:["8 基础篇｜函数：千变万化的特殊对象",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8-基础篇函数千变万化的特殊对象",children:"#"})]}),"\n",(0,c.jsxs)(e.h2,{id:"什么是函数",children:["什么是函数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是函数",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["根据 ECMAScript 规范的定义，函数（",(0,c.jsx)(e.code,{children:"function"}),"）是一种特殊的对象，它的特殊性体现在它的内部必须要存在一个 ",(0,c.jsx)(e.code,{children:"[[Call]]"})," 方法。这个方法代表了一段可复用的",(0,c.jsx)(e.strong,{children:"过程"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["这个方法对于我们使用者来说是不可见的，不过在规范内部，",(0,c.jsx)(e.code,{children:"typeof"})," 的原理就看对象里面有没有这个 ",(0,c.jsx)(e.code,{children:"[[Call]]"})," 属性的。"]}),"\n",(0,c.jsxs)(e.p,{children:["ECMAScript 规范还特意定义来一个",(0,c.jsx)(e.code,{children:"操作（Operation）"}),"，叫做 ",(0,c.jsx)(e.code,{children:"Call(F,V[,argumentsList] )"}),"（以下简称",(0,c.jsx)(e.code,{children:"Call()"}),"）。它的第一个参数 F 是一个函数对象，第二个参数 V 是一个上下文对象，最后是不定数量的参数。这个操作的语义很明确，就是：",(0,c.jsx)(e.strong,{children:"在 V 上调用 F，传入 argumentsList 参数"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["以 ",(0,c.jsx)(e.code,{children:"Object.assign(a, b)"})," 为例，它在规范内部的表述就是 ",(0,c.jsx)(e.code,{children:"Call(assign, Object, a, b)"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["大部分函数对象的内部还会存在一个叫做 ",(0,c.jsx)(e.code,{children:"[[Construct]]"})," 方法，代表这个函数可以作为一个构造函数来创建对象。相应的，也有一个 ",(0,c.jsx)(e.code,{children:"Construct(F[,argumentsList[,newTarget]])"})," 操作。"]}),"\n",(0,c.jsxs)(e.p,{children:["对于一般的函数来说，它作为对象，也是被特定构造函数来创建出来的，哪个构造函数呢？自然是 ",(0,c.jsx)(e.code,{children:"Function"}),"。我们可以这样验证："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function foo() {}\n\nfoo.constructor === Function // true\nfoo instanceof Function // true\n"})}),"\n",(0,c.jsxs)(e.p,{children:["只不过这个过程是隐式的，如果没有 ",(0,c.jsx)(e.code,{children:"function"})," 语法关键字，我们仍然可以通过构造的方式来创建函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const foo = new Function();\n"})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["\uD83D\uDCA1 调用 Function 时，也可以选择不使用 ",(0,c.jsx)(e.code,{children:"new"}),"，有点类似于我们前面讲过的 RegExp。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"由于动态代码的特性，这种写法通常作为 eval 的一种替代。"}),"\n",(0,c.jsxs)(e.p,{children:["函数会创建出一个新的上下文，还记得前面讲过的 ",(0,c.jsx)(e.code,{children:"Function Environment Record"})," 吗？不过不同类型的函数，其上下文也是有较大不同的。"]}),"\n",(0,c.jsxs)(e.h2,{id:"函数的种类",children:["函数的种类",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的种类",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["在 ES6 之前，函数只有",(0,c.jsx)(e.code,{children:"函数声明"}),"和",(0,c.jsx)(e.code,{children:"函数表达式"}),"两种写法，但是它们只会影响到",(0,c.jsx)(e.code,{children:"变量提升"}),"，本质上还是普通的同步函数。"]}),"\n",(0,c.jsxs)(e.p,{children:["ES6 之后，引入了如",(0,c.jsx)(e.code,{children:"箭头（Arrow）函数"}),"、",(0,c.jsx)(e.code,{children:"异步（Async）函数"}),"、",(0,c.jsx)(e.code,{children:"生成器（Generator）函数"}),"这几类特殊函数。它们的用法存在着很大不同。"]}),"\n",(0,c.jsxs)(e.h3,{id:"箭头函数",children:["箭头函数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#箭头函数",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["箭头函数的特点就是它的内部没有 ",(0,c.jsx)(e.code,{children:"this"})," 的概念，也就是说，",(0,c.jsx)(e.code,{children:"Function Environment Record"})," 的 ",(0,c.jsx)(e.code,{children:"HasThisBinding()"})," 函数返回 ",(0,c.jsx)(e.strong,{children:"false"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["当然这并不代表在箭头函数内部不可以使用 ",(0,c.jsx)(e.code,{children:"this"}),"，只不过它会顺着作用域链向上查找最近的 this，举一个例子："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<script>\nconst foo  = () => { return this; };\n\nfoo(); // window\n<\/script>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["它就会找到全局中的 this，即 ",(0,c.jsx)(e.code,{children:"window/globalThis"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["这种特性不因调用方式的改变而改变，我们都知道，函数的 ",(0,c.jsx)(e.code,{children:"call"}),"、",(0,c.jsx)(e.code,{children:"apply"}),"、",(0,c.jsx)(e.code,{children:"bind"})," 方法都可以重置上下文，但是大家注意，这对箭头函数无效！"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<script>\nconst foo = () => { return this; };\nfoo.call(5); // window\nfoo.bind(4)(); //window\n<\/script>\n"})}),"\n",(0,c.jsx)(e.p,{children:"所以，当你想锁定一个函数的上下文的时候，那么就应该把它定义成箭头函数。如果不打算使用 this，那么箭头函数还是写起来更简练。"}),"\n",(0,c.jsxs)(e.p,{children:["除了这个最重要的特性之外，箭头函数还有一个由此而来的推论：",(0,c.jsx)(e.code,{children:"箭头函数不可以作为构造函数"}),"。这很容易理解，它没有 ",(0,c.jsx)(e.code,{children:"this"}),"，而构造函数又必须有，由此产生了不可调和的冲突，强行使用 ",(0,c.jsx)(e.code,{children:"new"})," 来创建对象会导致错误："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const foo = () => {};\nnew foo(); // ❌ Uncaught TypeError: foo is not a constructor\n"})}),"\n",(0,c.jsxs)(e.p,{children:["在上一节我们讲过，函数对象可能存在一个 ",(0,c.jsx)(e.code,{children:"[[Construct]]"})," 内部函数，但是也可能不存在，箭头函数就不存在这个函数，因而不能作为构造函数。"]}),"\n",(0,c.jsxs)(e.p,{children:["而且我们还应该能理解箭头函数内部也不能使用 ",(0,c.jsx)(e.code,{children:"super"}),"。更严格的是，不像 this 可以顺着作用域链往上查找，",(0,c.jsx)(e.code,{children:"super"})," 连出现都不能出现，否则直接报出一个语法错误（",(0,c.jsx)(e.strong,{children:"SyntaxError"}),"）："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const foo = () => { return super; }; // ❌ Uncaught SyntaxError: 'super' keyword unexpected here\n"})}),"\n",(0,c.jsxs)(e.p,{children:["最后，",(0,c.jsx)(e.code,{children:"arguments"})," 也不能出现在箭头函数中："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const foo = () => { return arguments; };\nfoo(1,2,3); // ❌ Uncaught ReferenceError: arguments is not defined\n"})}),"\n",(0,c.jsxs)(e.p,{children:["不过在 ES6 以后，我们也不再建议使用 ",(0,c.jsx)(e.code,{children:"arguments"})," 了，展开语法（",(0,c.jsx)(e.code,{children:"Function Spread"}),"）写起来更优雅，下面会讲到。"]}),"\n",(0,c.jsxs)(e.p,{children:["总体来说，箭头函数还是比较特别的，它的语法其实是一种 ",(0,c.jsx)(e.code,{children:"lambda"})," 表达式的写法，它没有独立的 ",(0,c.jsx)(e.code,{children:"this"}),"，不能使用 ",(0,c.jsx)(e.code,{children:"super"}),"、",(0,c.jsx)(e.code,{children:"arguments"}),"，也不能作为构造函数使用。"]}),"\n",(0,c.jsxs)(e.h3,{id:"异步函数",children:["异步函数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步函数",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["异步函数是对传统异步编程的革命性改变。但事实上，讲到异步函数就不能够避开 ",(0,c.jsx)(e.code,{children:"Promise"})," 的话题，关于它，我们在后面的章节中还会详细地讲到，今天我们仅需要知道：",(0,c.jsxs)(e.strong,{children:[(0,c.jsx)(e.code,{children:"Promise"})," 是对",(0,c.jsx)(e.code,{children:"回调地狱"}),"的升级，是多种语言公认的优秀异步方案"]}),"。但还不够。"]}),"\n",(0,c.jsx)(e.p,{children:"在复杂的逻辑代码中，混合包含多个同步异步过程，且带有分支，那么用 Promise 写起来是什么样子的呢？"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'Promise.resolve()\n    .then(() => fetch("/xxx"))\n    .then(res => res.json())\n    .then(data => {\n        if (data.role === 1) {\n            return Promise.resolve()\n                .then(() => {\n                    return processAdmin(data.payload);\n                });\n        } else {\n            return Promise.resolve()\n                .then(() => {\n                    return processMemeber(data.payload);\n                });\n        }\n    })\n    .catch(err => console.log(err));\n'})}),"\n",(0,c.jsx)(e.p,{children:"我只写了一个非常非常简单的例子，已经能够看到 Promise 这种链式调用的写法，虽然比回调函数已经好太多，但是在需要处理分支的情况下，依然产生了大量的缩进，需要进一步提取出去进行封装，才能让代码阅读起来容易一些。"}),"\n",(0,c.jsxs)(e.p,{children:["归根到底，Promise 仍然离不开回调函数。异步（",(0,c.jsx)(e.code,{children:"async"}),"）函数从语法层面解决了这个问题，配合 ",(0,c.jsx)(e.code,{children:"await"}),"，能实现类似同步代码的写法："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'async onMount() {\n    try {\n        const res = await fetch("/xxx");\n        const data = await res.json();\n    \n        if (data.role === 1) {\n            await processAdmin(data.payload);\n        } else {\n            await processMemeber(data.payload);\n        }\n    } catch(err) {\n        console.log(err);\n    }\n}\n'})}),"\n",(0,c.jsxs)(e.p,{children:["这样看着就舒适多了。由于异步函数通常需要内部的 ",(0,c.jsx)(e.strong,{children:"await"})," 配合，因此将这种写法也称作 ",(0,c.jsx)(e.code,{children:"async/await"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"async/await"})," 在 ES2017（ES8）引入，在现代浏览器中，如果不打算支持 Safari 10 和 IE，那么可以认为浏览器都原生支持。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"async/await"})," 的原理并不难，事实上，它只是 ",(0,c.jsx)(e.code,{children:"Promise 的语法糖"}),"，即每一个异步函数的返回值，都一定是一个 Promise 对象，加上 await 后才是我们想要的数据："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"async function foo() {\n    return 1;\n}\n\nfoo() instanceof Promise; // true\n\nawait foo(); // 1\n"})}),"\n",(0,c.jsxs)(e.p,{children:["由于这种异步的关系，我们自然也能推测出：",(0,c.jsx)(e.code,{children:"异步函数不可以作为构造函数，不可以使用 super"}),"。至于 this 和 arguments，取决于 async 修饰的是一个箭头函数还是普通函数。"]}),"\n",(0,c.jsxs)(e.p,{children:["大家注意，异步函数并不是由 Function 隐式创建的，而是叫做 ",(0,c.jsx)(e.code,{children:"AsyncFunction"}),"，它是 Function 的子类。不过 AsyncFunction 并不能直接访问得到，只能间接获取："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const AsyncFunction = (async () => {}).constructor;\n\nObject.getPrototypeOf(AsyncFunction) === Function; // true\n"})}),"\n",(0,c.jsx)(e.p,{children:"因此，当你需要决定一个函数如何调用时，便可以以此来判断类型："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"if (callback instanceof AsyncFunction) {\n    await callback();\n} else {\n    callback();\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["也可以",(0,c.jsx)(e.code,{children:"动态创建一个异步函数"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'const fn = AsyncFunction("", "return 1");\n\nfn().then(ret => console.log(ret)); // 1\n'})}),"\n",(0,c.jsxs)(e.h3,{id:"生成器函数",children:["生成器函数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#生成器函数",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"这是一类理解起来比较晦涩的函数类型，在语法层面就表现出一种复杂感："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function* foo(seed) {\n    const  ret = yield seed;\n    return ret * seed;\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["异步函数总是返回一个 Promise 对象，类似地，生成器函数每次总是返回一个",(0,c.jsx)(e.code,{children:"迭代器（iterator）"}),"对象。至于什么是迭代器，我们将在后面单独开一章节详细讲解。今天我们只需要知道生成器函数的返回值不能直接使用，但是可以用 ",(0,c.jsx)(e.code,{children:"for...of"})," 来遍历就可以了。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function* count() {\n    yield 9;\n    yield 8;\n    yield 7;\n}\n\nconst it = count();\n\nfor (let k of it) {\n    console.log(k); // 7 8 9\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["与异步函数类似，生成器函数也不是由 Function 构造的，而是不可直接访问到的 ",(0,c.jsx)(e.code,{children:"GeneratorFunction"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const GeneratorFunction = (function*() {}).constructor;\n\nObject.getPrototypeOf(GeneratorFunction) === Function; // true\n"})}),"\n",(0,c.jsxs)(e.p,{children:["注意，生成器函数也可以是异步的，构成一个",(0,c.jsx)(e.code,{children:"异步生成器函数"}),"。但生成器函数不可以用箭头函数的形式定义。可见，",(0,c.jsx)(e.code,{children:"箭头函数、异步函数、生成器函数之间并不是并列关系的分类，可以相互组合，但生成器和箭头不能组合"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"不同函数的创建方式不同，使用场景不同，决定了它们作为函数有着共同数据属性的同时，也会存在一些差异。"}),"\n",(0,c.jsxs)(e.h2,{id:"函数的结构",children:["函数的结构",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的结构",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"函数作为一个特殊的对象，也有自己独特的属性："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"name；"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"length；"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"prototype。"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"name",children:["name",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#name",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"name"})," 即函数的名字，如果函数这样定义："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function foo (){}\n"})}),"\n",(0,c.jsx)(e.p,{children:"那么，name 显然就是 foo，这并不难，我们看一些容易让人困惑的例子："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'// 匿名\n(function() {}).name // ""\n(() => {}).name // ""\n(async () => {}).name //""\n(function*() {}).name // ""\n\n// 普通函数\nconst foo = function(){};\nfoo.name // "foo"\n\n// 箭头函数\nconst foo = () => {};\nfoo.name // "foo"\n\n// 构造函数\nconst fn = Function()\nfn.name // "anonymous"\n\n// 成员函数\nconst obj = {\n    foo() {},\n    [Symbol.for("bar")]() {},\n    get baz() {},\n    set baz() {},\n};\nobj.foo.name // "foo"\nobj[Symbol.for("bar")] // "[bar]"\nObject.getOwnPropertyDescriptor(obj, "baz").get.name // "get baz"\nObject.getOwnPropertyDescriptor(obj, "baz").set.name // "set baz"\n\n// 私有函数\nclass Foo {\n    #say() {}\n    bark() {\n        return this.#say.name;\n    }\n}\n\nnew Foo().bark() // "#say"\n\n// 绑定函数\nconst foo = function() {}\nfoo.bind(3).name // "bound foo"\n(() => {}).bind(3).name // "bound"\n\n// 属性定义/赋值\nconst obj = {}\n            \nObject.defineProperty(obj, \'foo\', {\n    value: async() => {}\n});\n\nobj.bar = () => {};\n\nobj.foo.name // "value"\nobj.bar.name // ""\n\n// ESM场景\n// lib.js\nexport default function() {};\n// index.js\nimport("./lib.js").then(({ default }) => {\n    default.name // "default"\n});\n'})}),"\n",(0,c.jsx)(e.p,{children:"上面我列举的能想到的典型场景，如果你仔细阅读这段代码，就能发现虽然看上去场景很多，name 取值差别很大，但仍然有一些规律可循："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:'各种匿名函数的 name 均为空串（""）；'}),"\n",(0,c.jsx)(e.li,{children:"函数表达式的 name 为定义时赋值给的独立变量名；"}),"\n",(0,c.jsx)(e.li,{children:"对象成员函数 name 为 key 的字符串表达；"}),"\n",(0,c.jsxs)(e.li,{children:["使用 Function 创建的函数的 name 为 ",(0,c.jsx)(e.code,{children:"anonymous"}),"；"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"bind"})," 后的函数，name 前置 ",(0,c.jsx)(e.code,{children:"bound"}),"；"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"export default"})," 导出的匿名函数 name 为 ",(0,c.jsx)(e.code,{children:"default"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["诸如",(0,c.jsx)(e.strong,{children:"类私有函数"}),"、",(0,c.jsx)(e.strong,{children:"getter/setter"}),"，都符合上述规则。事实上，name 只是一个字符串表达，其值可以任意定义。但由于 name 作为对象属性本身是只读的（后面的章节中会详细讲解对象属性的知识），我们只能以重新定义的方式来修改："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function foo() { }\n\nObject.defineProperty(foo,'name', {\n    value: 'bar',\n    writable: false,\n    configurable: true,\n    enumerable: false,\n});\n        \nfoo.name // \"bar\"\n"})}),"\n",(0,c.jsx)(e.p,{children:"严格来讲，我们不建议使用 name 来作为逻辑操作的判断依据，但是可以作为日志打印的构成信息。"}),"\n",(0,c.jsxs)(e.h3,{id:"length",children:["length",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#length",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"length"})," 即指函数的参数个数，注意是函数的代码静态声明的参数，而不是运行时传入的参数。"]}),"\n",(0,c.jsxs)(e.p,{children:["一般来说，函数在定义时，其参数声明就已经定了，因此 ",(0,c.jsx)(e.code,{children:"length"})," 也是一个不可写的属性。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"(function (a, b) {}).length // 2\n"})}),"\n",(0,c.jsx)(e.p,{children:"ES6 引入了函数展开语法后，有一些特殊情况："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"(function (...a) {}).length // 0\n(function (a, ...b) {}).length // 1\n"})}),"\n",(0,c.jsx)(e.p,{children:"可见，展开的那部分参数并不参与 length 的计算。下面是我们日常常用的一些函数的 length 值，看看有没有让你感到意外的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"Function.length // 1\nFunction.prototype.call.length // 1\nFunction.prototype.apply.length // 2\nArray.prototype.splice.length // 2\nwindow.setTimeout.length // 1\nwindow.alert.length // 0\nwindow.getComputedStyle.length // 1\nparseInt.length // 2\nJSON.stringify.length // 3\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"prototype",children:["prototype",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#prototype",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["一般的函数还会有一个 ",(0,c.jsx)(e.code,{children:"prototype"})," 属性，这个属性在函数用作构造函数时是至关重要的，用来实现 JavaScript 的继承。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function Foo() {}\n\nconst foo = new Foo();\n"})}),"\n",(0,c.jsxs)(e.p,{children:["以上面的代码为例，函数 Foo 会有一个默认的 ",(0,c.jsx)(e.code,{children:"prototype"}),"，那么对于用其创建的对象 foo 来说，访问属性将很有可能顺着原型链访问到 Foo.prototype 上来。相当于以 Foo 创建的所有对象，都会共享 Foo.prototype 上面的属性。"]}),"\n",(0,c.jsx)(e.p,{children:"关于原型链的知识，我们在下一章会详细探讨。现在我们来看看 Foo.prototype 从何而来。"}),"\n",(0,c.jsxs)(e.p,{children:["根据 ECMAScript 规范的定义，函数在定义的时候，就应该为其创建一个 ",(0,c.jsx)(e.code,{children:"prototype"})," 属性，值是一个包含 ",(0,c.jsx)(e.code,{children:"constructor"})," 属性的简单对象，大概是这么个意思："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const fooProto = {};\n\nObjet.defineProperty(fooProto, 'constructor', {\n    value: Foo,\n    writable: true,\n    enumerable: false,\n    configurable: true\n});\n\nObjet.defineProperty(Foo, 'prototype', {\n    value: fooProto,\n    writable: true,\n    enumerable: false,\n    configurable: false\n});\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"constructor"})," 就是指向 Foo 本身。不过注意，它是不可枚举的，这也解释了当你用 ",(0,c.jsx)(e.code,{children:"for...in"})," 遍历一个对象的时候，根本遍历不到 constructor。"]}),"\n",(0,c.jsx)(e.p,{children:"如果在 Foo.prototype 上定义新的方法，那么将实现了全部实例的数据共享："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"Foo.prototype.bar = function() {};\n\nfoo.bar();\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这样写不够优雅，比较麻烦，从 ES6 开始，JavaScript 有了 ",(0,c.jsx)(e.code,{children:"class"})," 语法来实现这一机制，我们也有一个章节来专门讲解 ",(0,c.jsx)(e.code,{children:"class"})," 的原理和使用。"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["\uD83D\uDCA1 注意：异步函数和箭头函数没有 ",(0,c.jsx)(e.code,{children:"prototype"})," 属性，这很容易理解，因为它们不能作为构造函数。"]}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"小结",children:["小结",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["这一讲，我们梳理了 JavaScript 中的函数，讲到了函数是一种特殊的对象，有普通函数、箭头函数、异步函数和生成器函数 4 种类型，它们各有特点，部分可以相互组合。箭头函数没有自己的 ",(0,c.jsx)(e.code,{children:"this"}),"，异步函数背后的 ",(0,c.jsx)(e.code,{children:"async/await"})," 本质是 ",(0,c.jsx)(e.code,{children:"Promise"})," 的语法糖，生成器函数始终返回迭代器对象。它们之中只有普通函数允许作为构造函数，可以被 ",(0,c.jsx)(e.code,{children:"class"})," 语法替代。"]}),"\n",(0,c.jsxs)(e.p,{children:["函数有 ",(0,c.jsx)(e.code,{children:"name"})," 和 ",(0,c.jsx)(e.code,{children:"length"})," 两个固定属性，不同创建方式，其值不同。构造函数还可以有 ",(0,c.jsx)(e.code,{children:"prototype"})," 属性，用来实现继承。"]}),"\n",(0,c.jsxs)(e.p,{children:["由于对象通常都是函数创建的，围绕着 ",(0,c.jsx)(e.code,{children:"constructor"}),"、",(0,c.jsx)(e.code,{children:"prototype"})," 形成了 JavaScript 最为特别的对象原型链体系，是最难的一部分知识，同时也是能灵活运用 JavaScript 实现各种复杂数据关系的根基。"]}),"\n",(0,c.jsx)(e.p,{children:"下一节，我们就以对象的结构为出发点，连续花几讲的时间来把这一部分吃透，以后能在面对任意的对象操作时游刃有余。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(o,{...n})}):o(n)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F8%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E5%87%BD%E6%95%B0%EF%BC%9A%E5%8D%83%E5%8F%98%E4%B8%87%E5%8C%96%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AF%B9%E8%B1%A1.md"]={toc:[{text:"什么是函数",id:"什么是函数",depth:2},{text:"函数的种类",id:"函数的种类",depth:2},{text:"箭头函数",id:"箭头函数",depth:3},{text:"异步函数",id:"异步函数",depth:3},{text:"生成器函数",id:"生成器函数",depth:3},{text:"函数的结构",id:"函数的结构",depth:2},{text:"name",id:"name",depth:3},{text:"length",id:"length",depth:3},{text:"prototype",id:"prototype",depth:3},{text:"小结",id:"小结",depth:2}],title:"8 基础篇｜函数：千变万化的特殊对象",headingTitle:"8 基础篇｜函数：千变万化的特殊对象",frontmatter:{}}}}]);