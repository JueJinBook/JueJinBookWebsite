"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57787"],{799470:function(e,n,r){r.r(n),r.d(n,{default:()=>T});var a=r(552676),s=r(740453);let i=r.p+"static/image/93ec842c200fbad62f4ec1d82ec73b05.32b9c591.png",c=r.p+"static/image/7edddebaaf04e1ce585cb504666b5a15.8928a0b3.png",t=r.p+"static/image/947d535e318d47462f255230a9cf2fad.0cebe3e3.png",d=r.p+"static/image/6980384e18e4506299d086bc953159c1.a52910bc.png",l=r.p+"static/image/ea99b0c97d2764e7d5e0b794e958db9b.bb2fd806.png",h=r.p+"static/image/003b7d9be334528c0947a7218a7b75e8.cdbfe72c.png",p=r.p+"static/image/c3cc84ad471045cb6469e22b0e5469bc.72ccab6e.png",x=r.p+"static/image/ed4371f955a6209a7bca125b09a4f448.1a66256f.png",o=r.p+"static/image/27d8da6ce76c3749b5af7bf62e9b7221.34bbaa8c.png",j=r.p+"static/image/95293aad155bd5c789b57d3ba998e76d.a3aab79b.png",m=r.p+"static/image/afe3c8aba544ec75970c53b69bdf9b7a.da582727.png",b=r.p+"static/image/440a5033699f48cb59ff17b49bcf7b53.d969fb11.png",f=r.p+"static/image/efdcd0e73928f82dabef6a5c8fef9794.0196a176.png",g=r.p+"static/image/a6b42c34fc959ba9d63a15b69ec5d2a0.ce5dce86.png",u=r.p+"static/image/972ebeeaf342efffb9a062009d503a71.bfbb7003.png";function S(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",code:"code",img:"img",pre:"pre",h4:"h4",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"3babel-的-ast",children:["3.Babel 的 AST",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3babel-的-ast",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"babel 编译的第一步是把源码 parse 成抽象语法树 AST （Abstract Syntax Tree），后续对这个 AST 进行转换。"}),"\n",(0,a.jsx)(n.p,{children:"整个编译流程都是围绕 AST 来的，所以这一节我们先来熟悉一下 AST："}),"\n",(0,a.jsxs)(n.h2,{id:"常见的-ast-节点",children:["常见的 AST 节点",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见的-ast-节点",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"AST 是对源码的抽象，字面量、标识符、表达式、语句、模块语法、class 语法都有各自的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"我们分别来了解一下："}),"\n",(0,a.jsxs)(n.h3,{id:"literal",children:["Literal",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#literal",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["Literal 是字面量的意思，比如 ",(0,a.jsx)(n.code,{children:"let name = 'guang'"}),"中，",(0,a.jsx)(n.code,{children:"'guang'"}),"就是一个字符串字面量 StringLiteral，相应的还有数字字面量 NumericLiteral，布尔字面量 BooleanLiteral，字符串字面量  StringLiteral，正则表达式字面量 RegExpLiteral 等。"]}),"\n",(0,a.jsx)(n.p,{children:"下面这些字面量都有对应的 Literal 节点："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"代码中的字面量很多，babel 就是通过 xxLiteral 来抽象这部分内容的。"}),"\n",(0,a.jsxs)(n.h3,{id:"identifier",children:["Identifier",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#identifier",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。"}),"\n",(0,a.jsx)(n.p,{children:"我们知道，JS 中的标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。这是 Identifier 的词法特点。"}),"\n",(0,a.jsx)(n.p,{children:"尝试分析一下，下面这一段代码里面有多少 Identifier 呢？"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const name = 'guang';\n\nfunction say(name) {\n  console.log(name);\n}\n\nconst obj = {\n  name: 'guang'\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"答案是这些"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsxs)(n.h3,{id:"statement",children:["Statement",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#statement",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"statement 是语句，它是可以独立执行的单位，比如 break、continue、debugger、return 或者 if 语句、while 语句、for 语句，还有声明语句，表达式语句等。我们写的每一条可以独立执行的代码都是语句。"}),"\n",(0,a.jsx)(n.p,{children:"语句末尾一般会加一个分号分隔，或者用换行分隔。"}),"\n",(0,a.jsx)(n.p,{children:"下面这些我们经常写的代码，每一行都是一个 Statement："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"break;\ncontinue;\nreturn;\ndebugger;\nthrow Error();\n{}\ntry {} catch(e) {} finally{}\nfor (let key in obj) {}\nfor (let i = 0;i < 10;i ++) {}\nwhile (true) {}\ndo {} while (true)\nswitch (v){case 1: break;default:;}\nlabel: console.log();\nwith (a){}\n"})}),"\n",(0,a.jsx)(n.p,{children:"它们对应的 AST 节点如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"语句是代码执行的最小单位，可以说，代码是由语句（Statement）构成的。"}),"\n",(0,a.jsxs)(n.h3,{id:"declaration",children:["Declaration",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#declaration",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个变量、函数、class、import、export 等。"}),"\n",(0,a.jsx)(n.p,{children:"比如下面这些语句都是声明语句："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const a = 1;\nfunction b(){}\nclass C {}\n\nimport d from 'e';\n\nexport default e = 1;\nexport {e};\nexport * from 'e';\n"})}),"\n",(0,a.jsx)(n.p,{children:"它们对应的 AST 节点如下图："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"声明语句用于定义变量，这也是代码中一个基础组成部分。"}),"\n",(0,a.jsxs)(n.h3,{id:"expression",children:["Expression",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#expression",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"expression 是表达式，特点是执行完以后有返回值，这是和语句 (statement) 的区别。"}),"\n",(0,a.jsx)(n.p,{children:"下面是一些常见的表达式"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"[1,2,3]\na = 1\n1 + 2;\n-1;\nfunction(){};\n() => {};\nclass{};\na;\nthis;\nsuper;\na::b;\n"})}),"\n",(0,a.jsx)(n.p,{children:"它们对应的AST如图："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"细心的同学可能会问 identifier 和 super 怎么也是表达式呢？"}),"\n",(0,a.jsx)(n.p,{children:"因为 identifier、super 有返回值，符合表达式的特点，所以也是 expression。"}),"\n",(0,a.jsx)(n.p,{children:"我们判断 AST 节点是不是某种类型要看它是不是符合该种类型的特点，比如语句的特点是能够单独执行，表达式的特点是有返回值。"}),"\n",(0,a.jsx)(n.p,{children:"有的表达式可以单独执行，符合语句的特点，所以也是语句，比如赋值表达式、数组表达式等。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"a=1;\n[1,2,3];\n"})}),"\n",(0,a.jsx)(n.p,{children:"但有的表达式不能单独执行，需要和其他类型的节点组合在一起构成语句。"}),"\n",(0,a.jsx)(n.p,{children:"比如匿名函数表达式和匿名 class 表达式单独执行会报错："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function(){};\nclass{}\n"})}),"\n",(0,a.jsx)(n.p,{children:"需要和其他部分一起构成一条语句，比如组成赋值语句："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"a = function() {}\nb = class{}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这条赋值语句对应的 AST 是这样的："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"你会发现赋值语句的 AST 节点 AssignmentExpression 包裹了一层ExpressionStatement 的节点，代表这个表达式是被当成语句执行的。"}),"\n",(0,a.jsxs)(n.h3,{id:"class",children:["Class",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#class",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"class 的语法也有专门的 AST 节点来表示。"}),"\n",(0,a.jsx)(n.p,{children:"整个 class 的内容是 ClassBody，属性是 ClassProperty，方法是ClassMethod（通过 kind 属性来区分是 constructor 还是 method）。"}),"\n",(0,a.jsx)(n.p,{children:"比如下面的代码"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class Guang extends Person{\n    name = 'guang';\n    constructor() {}\n    eat() {}\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应的AST是这样的"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"class 是 es next 的语法，babel 中有专门的 AST 来表示它的内容。"}),"\n",(0,a.jsxs)(n.h3,{id:"modules",children:["Modules",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#modules",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"es module 是语法级别的模块规范，所以也有专门的 AST 节点。"}),"\n",(0,a.jsxs)(n.h4,{id:"import",children:["import",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#import",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"import 有 3 种语法："}),"\n",(0,a.jsx)(n.p,{children:"named import："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import {c, d} from 'c';\n"})}),"\n",(0,a.jsx)(n.p,{children:"default import："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import a from 'a';\n"})}),"\n",(0,a.jsx)(n.p,{children:"namespaced import:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import * as b from 'b';\n"})}),"\n",(0,a.jsx)(n.p,{children:"这 3 种语法都对应 ImportDeclaration 节点，但是 specifiers 属性不同，分别对应 ImportSpicifier、ImportDefaultSpecifier、ImportNamespaceSpcifier。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"图中黄框标出的就是 specifier 部分。可以直观的看出整体结构相同，只是 specifier 部分不同，所以 import 语法的 AST 的结构是 ImportDeclaration 包含着各种 import specifier。"}),"\n",(0,a.jsxs)(n.h4,{id:"export",children:["export",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#export",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"export 也有3种语法："}),"\n",(0,a.jsx)(n.p,{children:"named export："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export { b, d};\n"})}),"\n",(0,a.jsx)(n.p,{children:"default export："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export default a;\n"})}),"\n",(0,a.jsx)(n.p,{children:"all export："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"export * from 'c';\n"})}),"\n",(0,a.jsx)(n.p,{children:"分别对应 ExportNamedDeclaration、ExportDefaultDeclaration、ExportAllDeclaration 的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"比如这三种 export"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export { b, d};\nexport default a;\nexport * from 'c';\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应的 AST 节点为"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsxs)(n.h3,{id:"program--directive",children:["Program & Directive",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#program--directive",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["program 是代表整个程序的节点，它有 body 属性代表程序体，存放 statement 数组，就是具体执行的语句的集合。还有 directives 属性，存放 Directive 节点，比如",(0,a.jsx)(n.code,{children:'"use strict"'})," 这种指令会使用 Directive 节点表示。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"Program 是包裹具体执行语句的节点，而 Directive 则是代码中的指令部分。"}),"\n",(0,a.jsxs)(n.h3,{id:"file--comment",children:["File & Comment",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#file--comment",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"babel 的 AST 最外层节点是 File，它有 program、comments、tokens 等属性，分别存放 Program 程序体、注释、token 等，是最外层节点。"}),"\n",(0,a.jsx)(n.p,{children:"注释分为块注释和行内注释，对应 CommentBlock 和 CommentLine 节点。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"上面 6 种就是常见的一些 AST 节点类型，babel 就是通过这些节点来抽象源码中不同的部分。"}),"\n",(0,a.jsxs)(n.h2,{id:"ast-可视化查看工具",children:["AST 可视化查看工具",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-可视化查看工具",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这么多 AST 我们都要记住么？"}),"\n",(0,a.jsxs)(n.p,{children:["不需要。可以通过 ",(0,a.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"axtexplorer.net"}),"  这个网站来可视化的查看。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这个网站可以查看代码 parse 以后的 AST，可以切换 parse 的语言和用的 parser，也可以修改 parse options。"}),"\n",(0,a.jsx)(n.p,{children:"点击这里的 save 就可以保存下来，然后把 url 分享出去："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"比如这个链接"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/7267e806bfec60b48b9d39d039f29313/c343ad5a76a8dd78c22d39ce89f4d0733c2b17e4",target:"_blank",rel:"noopener noreferrer",children:(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/7267e806bfec60b48b9d39d039f29313/c343ad5a76a8dd78c22d39ce89f4d0733c2b17e4",target:"_blank",rel:"noopener noreferrer",children:"https://astexplorer.net/#/gist/7267e806bfec60b48b9d39d039f29313/c343ad5a76a8dd78c22d39ce89f4d0733c2b17e4"})}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["如果想查看全部的 AST 可以在",(0,a.jsx)(n.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md",target:"_blank",rel:"noopener noreferrer",children:"babel parser 仓库里的 AST 文档"}),"里查，或者直接去看 @babel/types 的",(0,a.jsx)(n.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts",target:"_blank",rel:"noopener noreferrer",children:" typescript 类型定义"}),"。"]}),"\n",(0,a.jsxs)(n.h2,{id:"ast-的公共属性",children:["AST 的公共属性",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-的公共属性",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"每种 AST 都有自己的属性，但是它们也有一些公共的属性："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"type"}),"： AST 节点的类型"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"start、end、loc"}),"：start 和 end 代表该节点在源码中的开始和结束下标。而 loc 属性是一个对象，有 line 和 column 属性分别记录开始和结束的行列号。"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"leadingComments、innerComments、trailingComments"}),"： 表示开始的注释、中间的注释、结尾的注释，每个 AST 节点中都可能存在注释，而且可能在开始、中间、结束这三种位置，想拿到某个 AST 的注释就通过这三个属性。"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["比如",(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/7267e806bfec60b48b9d39d039f29313/c343ad5a76a8dd78c22d39ce89f4d0733c2b17e4",target:"_blank",rel:"noopener noreferrer",children:"这段有注释的代码的 AST"}),"："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extra"}),"：记录一些额外的信息，用于处理一些特殊情况。比如 StringLiteral 的 value 只是值的修改，而修改 extra.raw 则可以连同单双引号一起修改。"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["比如",(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/84c587000fced891a2fcf6212418e67e/41636c5445957a4d83bbc9232689ddb02d3e2571",target:"_blank",rel:"noopener noreferrer",children:"这段代码的 AST"}),"："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"修改 value 只能修改值，修改 extra.raw 可以连引号一起修改。"}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这一节我们学习了代码中常见的语法在 babel 的 AST 中对应的节点。"}),"\n",(0,a.jsx)(n.p,{children:"我们学习了： 标识符 Identifer、各种字面量 xxLiteral、各种语句 xxStatement，各种声明语句 xxDeclaration，各种表达式 xxExpression，以及 Class、Modules、File、Program、Directive、Comment 这些 AST 节点。"}),"\n",(0,a.jsx)(n.p,{children:"了解了这些节点，就能知道平时写的代码是怎么用 AST 表示的。"}),"\n",(0,a.jsxs)(n.p,{children:["当然也不需要记，可以用 (",(0,a.jsx)(n.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"astexpoler.net"}),") 可视化的查看。"]}),"\n",(0,a.jsx)(n.p,{children:"AST 节点可能同时有多种类型，确定一种 AST 节点是什么类型主要看它的特点，比如 Statement 的特点是可以单独执行，Expression 的特点是有返回值，所以一些可以单独执行的 Expression 会包一层 ExpressionStatement。"}),"\n",(0,a.jsx)(n.p,{children:"不同 AST 节点有不同的属性来存放对应的源码信息，但是都有一些公共属性如 type、xxComments、loc 等。"}),"\n",(0,a.jsx)(n.p,{children:"学会了 AST，就可以把对代码的操作转为对 AST 的操作了，这是编译、静态分析的第一步。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(S,{...e})}):S(e)}let T=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F3.Babel%20%E7%9A%84%20AST.md"]={toc:[{text:"常见的 AST 节点",id:"常见的-ast-节点",depth:2},{text:"Literal",id:"literal",depth:3},{text:"Identifier",id:"identifier",depth:3},{text:"Statement",id:"statement",depth:3},{text:"Declaration",id:"declaration",depth:3},{text:"Expression",id:"expression",depth:3},{text:"Class",id:"class",depth:3},{text:"Modules",id:"modules",depth:3},{text:"import",id:"import",depth:4},{text:"export",id:"export",depth:4},{text:"Program & Directive",id:"program--directive",depth:3},{text:"File & Comment",id:"file--comment",depth:3},{text:"AST 可视化查看工具",id:"ast-可视化查看工具",depth:2},{text:"AST 的公共属性",id:"ast-的公共属性",depth:2},{text:"总结",id:"总结",depth:2}],title:"3.Babel 的 AST",headingTitle:"3.Babel 的 AST",frontmatter:{}}}}]);