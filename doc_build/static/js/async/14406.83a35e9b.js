"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["14406"],{135073:function(e,n,c){e.exports=c.p+"static/image/0c38d680ab0c69bf9acb4fbe360605e0.00484b77.webp"},688634:function(e,n,c){e.exports=c.p+"static/image/87aa5fb542fd4473d2d6e35ce3723e2a.ee3dda94.webp"},987658:function(e,n,c){c.r(n),c.d(n,{default:()=>U});var r=c(552676),a=c(740453);let t=c.p+"static/image/4522c54a38e8419c14201b51c11e0847.6eba250c.webp";var s=c(688634);let i=c.p+"static/image/8d8a2ec43b3fd00495d8812ff53e0477.58925503.webp",d=c.p+"static/image/70b5792506d7293bbcf822aa69235766.b4be8751.webp",p=c.p+"static/image/ecf83e8e97ace1ef33509852e97b044f.cff448b0.webp",l=c.p+"static/image/089984fd53207e7ce32073ddd75669b4.e0470477.webp",f=c.p+"static/image/8bcff7afc7c5345eebcb15550ada12bd.359045a2.webp",j=c.p+"static/image/8f81a6af2d0c810ce217f9b8627aa218.ae0cc5b2.webp",x=c.p+"static/image/40a6a2f90936f8d3708f047073956446.1857804a.webp",o=c.p+"static/image/8db9e6d54071e673693978bbba0b4cc6.b8833917.webp",m=c.p+"static/image/ca2dfda18b14154bdc90595c547d0d8b.6e17c996.webp",h=c.p+"static/image/a5269cad35cec2cb39bb061cd615e8ce.bd6e35a6.webp",b=c.p+"static/image/473aeef2ed99c7b88569d1b1ce0a32df.6347e4a9.webp",u=c.p+"static/image/651dbd5741f1783661ee32d494aeee31.56a96509.webp",g=c.p+"static/image/7de5779d273b1413e1cb9622d5efb66c.72dcec02.webp",R=c.p+"static/image/3288492981701deed285d27b85d24df3.e9c1b2b0.webp",w=c.p+"static/image/f3b06d538cfe2f6302c7e218c8bc9971.3182d7d3.webp",E=c.p+"static/image/b948f850e917a0b21b9838cb061f8104.210aadd6.webp",v=c.p+"static/image/b8213f8dfe42227ac87afa6dd5dce510.fb694ada.webp",k=c.p+"static/image/653c7985ec737ab5ea61f4e23ab8a336.69fe7b99.webp",y=c.p+"static/image/7f7a35809cfe0e56d4ad54be90c3abe3.c0b5926d.webp",A=c.p+"static/image/5d3d963751ff7373cf5210202103c93b.584d91bd.webp",H=c.p+"static/image/a0bdfb617658fa15d3e022bc347dcdbb.ec4c693a.webp",I=c.p+"static/image/71a864a6ab3bbd3b6534e7f430291c91.d65ffaa7.webp";var C=c(135073);let M=c.p+"static/image/5f0fa42c425ea61c2a8722053d0c2d25.66294ddc.webp",N=c.p+"static/image/468eca60a30af7219df0748a104f65de.46710565.webp",_=c.p+"static/image/5460bd255c0f01924487e8056f54a489.55e204ad.webp",F=c.p+"static/image/99ccaf3049cd496c9a34ca0d795f71e1.c659749f.webp",S=c.p+"static/image/fb1adf534b60752e22b9344975eb8d1c.84e3826c.webp",T=c.p+"static/image/f58d020b9b4b6b7e7022f24ca03f50d1.685c3c65.webp",W=c.p+"static/image/06158af6cdf56cc621f61da8eb513c74.612088a0.webp",O=c.p+"static/image/3038643485de1a6499a8cf822bafca59.b073857d.webp",L=c.p+"static/image/e6c131f56c12744ce41961768595fbe4.aba4202d.webp",B=c.p+"static/image/84634eec3903c1a7698552f6401e9dad.e0cea57c.webp",P=c.p+"static/image/0fdd939357d4ae60c70e30cd0d00cddd.4eea3c0f.webp",D=c.p+"static/image/84d6883fc0adfbed8f837602a52beacc.6210b769.gif",G=c.p+"static/image/550713f9b4db82954adbf3ae1b83dabd.56480d84.webp",q=c.p+"static/image/040c2c35b407c185acc06e95892820c9.431bf912.webp",z=c.p+"static/image/4901e68765e6d7abbf85adaf901e6e88.6cd24252.webp",$=c.p+"static/image/e205144a753173a65e4bc94cf696d7cb.342ae893.webp",J=c.p+"static/image/b56d56496a0454a6648d7554ba9fde1d.62db4d4a.webp";function K(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",strong:"strong",h2:"h2"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第66章ref的实现原理",children:["第66章—Ref的实现原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第66章ref的实现原理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFFref 是 React 里常用的特性，我们会用它来拿到 dom 的引用，或者用来保存渲染过程中不变的数据。"}),"\n",(0,r.jsx)(n.p,{children:"我们创建个项目试一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:J,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"去掉 index.css 和 StrictMode"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:$,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"改下 App.tsx"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { useRef, useEffect } from "react";\n\nexport default function App() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(()=> {\n    inputRef.current?.focus();\n  }, []);\n\n  return <input ref={inputRef} type="text" />\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"把开发服务跑起来："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run dev\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"创建个调试配置："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "type": "chrome",\n    "request": "launch",\n    "name": "Launch Chrome against localhost",\n    "url": "http://localhost:5173",\n    "webRoot": "${workspaceFolder}"\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，useRef 可以拿到 dom 的引用："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"此外，useRef 还可以保存渲染中不变的一些值："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { useEffect, useRef, useState } from "react";\n\nexport default function App() {\n  const [num, setNum] = useState(0);\n  const timerRef = useRef<number>();\n\n  useEffect(() => {\n    timerRef.current = setInterval(() => {\n      setNum(num => num + 1);\n    }, 100);\n  }, []);\n\n  return <div>\n    {num}\n    <button onClick={() => {\n      clearInterval(timerRef.current!);\n    }}>停止</button>\n  </div>\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当传入 null 时，返回的是 RefObject 类型，用来保存 dom 引用："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"传其他值返回的是 MutableRefObject，可以修改 current，保存其它值："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而在 class 组件里用 createRef："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from "react";\n\nexport default class App  extends React.Component{\n  constructor() {\n    super();\n    this.inputRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n\n  render() {\n    return <input ref={this.inputRef} type="text" />\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果想转发 ref 给父组件，可以用 forwardRef："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { useRef, forwardRef, useImperativeHandle, useEffect } from "react";\n\nconst ForwardRefMyInput = forwardRef<HTMLInputElement>((props, ref) => {\n    return <input {...props} ref={ref} type="text" />\n  }\n)\n\nexport default function App() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    inputRef.current?.focus();\n  }, [])\n\n  return (\n    <div className="App">\n      <ForwardRefMyInput ref={inputRef} />\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而且还可以使用 useImperativeHandle 自定义传给父元素的 ref："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { useRef, forwardRef, useImperativeHandle, useEffect } from "react";\n\ninterface RefType {\n  aaa: Function\n}\n\nconst ForwardRefMyInput = forwardRef<RefType>((props, ref) => {\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    useImperativeHandle(ref, () => {\n      return {\n        aaa() {\n          inputRef.current?.focus();\n        }\n      }\n    });\n    return <input {...props} ref={inputRef} type="text" />\n  }\n)\n\nexport default function App() {\n  const apiRef = useRef<RefType>(null);\n\n  useEffect(() => {\n    apiRef.current?.aaa();\n  }, [])\n\n  return (\n    <div className="App">\n      <ForwardRefMyInput ref={apiRef} />\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:W,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这就是我们平时用到的所有的 ref api 了。"}),"\n",(0,r.jsx)(n.p,{children:"小结一下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"函数组件里用 useRef 保存 dom 引用或者自定义的值，而在类组件里用 createRef"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"forwardRef 可以转发子组件的 ref 给父组件，还可以用 useImperativeHandle 来修改转发的 ref 的值"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"相信开发 React 项目，大家或多或少会用到这些 api。"}),"\n",(0,r.jsx)(n.p,{children:"那这些 ref api 的实现原理是什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"下面我们就从源码来探究下："}),"\n",(0,r.jsx)(n.p,{children:"我们通过 jsx 写的代码，最终会编译成 React.createElement 等 render function，执行之后产生 vdom："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所谓的 vdom 就是这样的节点对象："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"vdom 是一个 children 属性连接起来的树。"}),"\n",(0,r.jsx)(n.p,{children:"react 会先把它转成 fiber 链表："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"vdom 树转 fiber 链表树的过程就叫做 reconcile，这个阶段叫 render。"}),"\n",(0,r.jsx)(n.p,{children:"render 阶段会从根组件开始 reconcile，根据不同的类型做不同的处理，拿到渲染的结果之后再进行 reconcileChildren，这个过程叫做 beginWork："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"比如函数组件渲染完产生的 vom 会继续 renconcileChildren："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"beginWork 只负责渲染组件，然后继续渲染 children，一层层的递归。"}),"\n",(0,r.jsx)(n.p,{children:"全部渲染完之后，会递归回来，这个阶段会调用 completeWork："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个阶段会创建需要的 dom，然后记录增删改的 tag 等，同时也记录下需要执行的其他副作用到 fiber 上。"}),"\n",(0,r.jsx)(n.p,{children:"之后 commit 阶段才会遍历 fiber 链表根据 tag 来执行增删改 dom 等 effect。"}),"\n",(0,r.jsx)(n.p,{children:"commit 阶段也分了三个小阶段，beforeMutation、mutation、layout："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"它们都是消费的同一条 fiber 链表，但是每个阶段做的事情不同"}),"\n",(0,r.jsx)(n.p,{children:"mutation 阶段会根据标记增删改 dom，也就是这样的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以这个阶段叫做 mutation，它之前的一个阶段叫做 beforeMutation，而它之后的阶段叫做 layout。"}),"\n",(0,r.jsx)(n.p,{children:"小结下 react 的流程："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"通过 jsx 写的代码会编译成 render function，执行产生 vdom，也就是 React Element 对象的树。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"react 分为 render 和 commit 两个阶段:"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"render 阶段会递归做 vdom 转 fiber，beginWork 里递归进行 reconcile、reconcileChildren，completeWork 里创建 dom，记录增删改等 tag 和其他 effect"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"commit 阶段遍历 fiber 链表，做三轮处理，这三轮分别叫做 before mutation、mutation、layout，mutation 阶段会根据 tag 做 dom 增删改。"})}),"\n",(0,r.jsx)(n.p,{children:"ref 的实现同样是在这个流程里的。"}),"\n",(0,r.jsx)(n.p,{children:"首先，我们 ref 属性一般是加在原生标签上的，比如 input、div、p 这些，所以看 HostComponent 的分支就可以了，HostComponent 就是原生标签。"}),"\n",(0,r.jsx)(n.p,{children:"可以看到处理原生标签的 fiber 节点时，beginWork 里会走到这个分支："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:H,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"里面调用 markRef 打了个标记："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"前面说的 tag 就是指这个 flags。"}),"\n",(0,r.jsx)(n.p,{children:"然后就到了 commit 阶段，开始根据 flags 做不同处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 layout 阶段，这时候已经操作完 dom 了，就会遍历 fiber 链表，给 HostComponent 设置新的 ref。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:v,alt:""}),"\n",(0,r.jsx)("img",{src:E,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:"ref 的元素就是在 fiber.stateNode 属性上保存的在 render 阶段就创建好了的 dom，："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，在代码里的 ref.current 就能拿到这个元素了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而且我们可以发现，他只是对 ref.current 做了赋值，并不管你是用 createRef 创建的、useRef 创建的，还是自己创建的一个普通对象。"}),"\n",(0,r.jsx)(n.p,{children:"我们试验一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我创建了一个普通对象，current 属性依然被赋值为 input 元素。"}),"\n",(0,r.jsx)(n.p,{children:"那我们用 createRef、useRef 的意义是啥呢？"}),"\n",(0,r.jsx)(n.p,{children:"看下源码就知道了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"createRef 也是创建了一个这样的对象，只不过 Object.seal 了，不能增删属性。"}),"\n",(0,r.jsx)(n.p,{children:"用自己创建的对象其实也没啥问题。"}),"\n",(0,r.jsx)(n.p,{children:"那 useRef 呢？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"useRef 也是一样的，只不过是保存在了 fiber 节点 hook 链表元素的 memoizedState 属性上。"}),"\n",(0,r.jsx)(n.p,{children:"只是保存位置的不同，没啥很大的区别。"}),"\n",(0,r.jsx)(n.p,{children:"同样，用 forwardRef 转发的 ref 也很容易理解，只是保存的位置变了，变成了从父组件传过来的 ref："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那 forwardRef 是怎么实现这个 ref 转发的呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们再看下源码："}),"\n",(0,r.jsx)(n.p,{children:"forwarRef 函数其实就是创建了个专门的 React Element 类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后 beginWork 处理到这个类型的节点会做专门的处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"也就是把它的 ref 传递给函数组件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"渲染函数组件的时候专门留了个后门来传第二个参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以函数组件里就可以拿到 ref 参数了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样就完成了 ref 从父组件到子组件的传递："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那 useImperativeHandle 是怎么实现的修改 ref 的值呢？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"源码里可以看到 useImperativeHandle 底层就是 useEffect，只不过是回调函数是把传入的 ref 和 create 函数给 bind 到 imperativeHandleEffect 这个函数了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而这个函数里就是更新 ref.current 的逻辑："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们知道，useEffect 是在 commit 阶段异步调度的，在 layout 更新 dom 之后了，自然可以拿到新的 dom："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"更新了 ref 的值："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，useImperativeHandle 就成功修改了 forwardRef 传过来的 ref。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们平时会用到 createRef、useRef、forwardRef、useImperativeHandle 这些 api，而理解它们的原理需要熟悉 react 的运行流程，也就是 render（beginWork、completeWork） + commit（before mutation、mutation、layout）的流程。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"render 阶段处理到原生标签的也就是 HostComponent 类型的时候，如果有 ref 属性会在 fiber.flags 里加一个标记。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"commit 阶段会在 layout 操作完 dom 后遍历 fiber 链表更新 HostComponent 的 ref，也就是把 fiber.stateNode 赋值给 ref.current。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"react 并不关心 ref 是哪里创建的，用 createRef、useRef 创建的，或者 forwardRef 传过来的都行，甚至普通对象也可以，createRef、useRef 只是把普通对象 Object.seal 了一下。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"forwarRef 是创建了单独的 React Element 类型，在 beginWork 处理到它的时候做了特殊处理，也就是把它的 ref 作为第二个参数传递给了函数组件，这就是它 ref 转发的原理。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"useImperativeHandle 的底层实现就是 useEffect，只不过执行的函数是它指定的，bind 了传入的 ref 和 create 函数，这样在 layout 阶段调用 hook 的 effect 函数的时候就可以更新 ref 了。"})}),"\n",(0,r.jsx)(n.p,{children:"理解了 react 渲染流程之后，很多特性只是其中多一个 switch case 的分支而已，就比如 ref。"})]})}function Q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(K,{...e})}):K(e)}let U=Q;Q.__RSPRESS_PAGE_META={},Q.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC66%E7%AB%A0%E2%80%94Ref%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第66章—Ref的实现原理",headingTitle:"第66章—Ref的实现原理",frontmatter:{}}}}]);