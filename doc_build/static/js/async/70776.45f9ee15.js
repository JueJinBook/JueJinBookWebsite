"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["70776"],{222992:function(e,n,t){t.r(n),t.d(n,{default:()=>p});var s=t(552676),a=t(740453);let r=t.p+"static/image/9e4fdbe9028c5320cd9eab2c0edc3087.4ce47536.webp",i=t.p+"static/image/77640731489b89b01f47203d5c8ff672.c1e04534.webp",d=t.p+"static/image/ed047d22c6d3822d01c28293ea0790ac.f6111180.webp",o=t.p+"static/image/f457df8e1336c3816e52050b934963a5.54ebaee9.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",img:"img",h2:"h2",blockquote:"blockquote",code:"code",pre:"pre",ol:"ol",li:"li"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"19-理解-http持久化存储",children:["19 理解 HTTP：持久化存储",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19-理解-http持久化存储",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在上一节课里，我们通过 Mock 数据模拟了 Web 应用的数据源，实现了一个简单的数据查询功能。在一般的 Web 应用服务端，数据通常存储在关系数据库、分布式 K/V 存储或者分布式文件系统等",(0,s.jsx)(n.strong,{children:"持久化存储服务"}),"中，Web 服务端通过 TCP 或者其他协议与这些存储服务通讯、存储或读取数据。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所以这节课，我们就来看一下如何实现数据的持久化存储。"}),"\n",(0,s.jsxs)(n.h2,{id:"sqlite-数据库",children:["SQLite 数据库",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sqlite-数据库",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"简单的 Web 应用通常选择关系数据库作为持久存储，关系数据库的选择需根据应用特点和规模而定。社区中有非常多优秀的开源库，大名鼎鼎的 MySQL 你一定听说过。MySQL 功能强大，既能够单机部署，又能分布式部署。不过 MySQL 安装、部署和使用相对比较复杂，而我们是想写一个简单的例子，不需要分布式存储，所以选择一个比 MySQL 更加轻量级的关系数据库 —— SQLite。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"SQLite 是一款轻型的关系数据库，它的设计目标是嵌入式的，而且很多嵌入式产品中已经使用了它，它占用资源非常的低，在嵌入式设备中可能只需要几百 K 的内存。它能够支持 Windows/Linux/Unix 等主流的操作系统，同时能够跟很多程序语言相结合，比如 Tcl、C#、PHP、Java 等，还有 ODBC 接口。比起 MySQL、PostgreSQL 这两款著名数据库管理系统，SQLite 的处理速度更快，而且同样受 Node.js 支持。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["SQLite 数据库是基于文件的，不需要在系统中安装 server 服务，只需要安装一个图形界面的客户端管理工具，方便我们初始化数据库和创建数据表。Windows 和 Mac 系统下都有不错的管理工具，比如",(0,s.jsx)(n.code,{children:"sqlpro studio"}),"、",(0,s.jsx)(n.code,{children:"sqliteexpert"}),"等等，你可以根据需要安装。"]}),"\n",(0,s.jsxs)(n.h2,{id:"设计-todolist-数据表",children:["设计 Todolist 数据表",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计-todolist-数据表",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们将用 Node.js 作为服务端实现一个简单的 Todolist 应用。它的前端界面我已经写好了，如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们设计一个",(0,s.jsx)(n.code,{children:"todo"}),"表来存储 Todolist 的数据，这个表结构很简单，只有3个字段：id、text 和 state。其中 id 是自动产生的，text 字段表示任务描述，state 字段表示任务的状态（已完成或未完成）。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后，我们在的 HTTP 服务器的项目中安转 SQLite 模块："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i sqlite3 sqlite --save\n"})}),"\n",(0,s.jsx)(n.p,{children:"Node.js 中安装 SQLite 需要安装两个模块：SQLite3 和 SQLite。sqlite3 是支持 SQLite 的标准Node.js模块，而 SQLite 模块是在这个基础上将 SQLite3 模块的异步 API 封装成 Promise 规范，易于使用。"}),"\n",(0,s.jsxs)(n.h2,{id:"实现服务端主体逻辑",children:["实现服务端主体逻辑",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现服务端主体逻辑",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们将服务器端的主体逻辑添加一下。这个应用比较简单，主要由几个拦截切面构成。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\nconst sqlite3 = require('sqlite3');\nconst {open} = require('sqlite');\nconst {Server, Router} = require('./lib/interceptor'); // 这里我们将server 和 router都规划到interceptor包中\n\nconst dbFile = path.resolve(__dirname, '../database/todolist.db'); // todolist.db是sqlite数据库文件\nlet db = null;\n\nconst app = new Server(); // 创建HTTP服务器\nconst router = new Router(); // 创建路由中间件\n\napp.use(async ({req}, next) => {\n  console.log(`${req.method} ${req.url}`); // eslint-disable-line no-console\n  await next();\n});\n\napp.use(async (ctx, next) => {\n  if(!db) { // 如果数据库连接未创建，就创建一个\n    db = await open({\n      filename: dbFile,\n      driver: sqlite3.cached.Database,\n    });\n  }\n  ctx.database = db; // 将db挂在ctx上下文对象的database属性上\n\n  await next();\n});\n\n/*\n如果请求的路径是/list，则从todo表中获取所有任务数据\n*/\napp.use(router.get('/list', async ({database, route, res}, next) => {\n  res.setHeader('Content-Type', 'application/json');\n  const {getList} = require('./model/todolist');\n  const result = await getList(database); // 获取任务数据\n  res.body = {data: result};\n  await next();\n}));\n\n/*\n如果路径不是/list, 则返回'<h1>Not Found</h1>'文本\n*/\napp.use(router.all('.*', async ({params, req, res}, next) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.body = '<h1>Not Found</h1>';\n  res.statusCode = 404;\n  await next();\n}));\n\napp.listen({\n  port: 9090,\n  host: '0.0.0.0',\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个 web 服务中，我们一共创建了 4 个拦截切面："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"第一个切面是打印每次请求的日志；"}),"\n",(0,s.jsx)(n.li,{children:"第二个切面是创建 SQLite 数据库连接，每次请求都通过这个切面获得数据库实例；"}),"\n",(0,s.jsxs)(n.li,{children:["第三个切面是处理",(0,s.jsx)(n.code,{children:"/list"}),"请求，返回任务数据；"]}),"\n",(0,s.jsx)(n.li,{children:"第四个切面是其他路径请求返回 404。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"大部分拦截切面的逻辑我们已经比较熟悉了，这里主要讲一个新的拦截切面："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"app.use(async (ctx, next) => {\n  if(!db) {\n    db = await open({\n      filename: dbFile,\n      driver: sqlite3.cached.Database,\n    });\n  }\n  ctx.database = db;\n\n  await next();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面的 open 方法创建 SQLite 数据库连接，成功后返回数据库实例对象。然后，我们将这个数据库实例缓存起来，即保存在 db 变量。这样，除了第一次请求，后续的请求都不需要再创建数据库连接。最后，我们将数据库实例保存到 ctx 对象的 database 属性里，以方便后续的切面使用该实例操作数据库。比如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {getList} = require('./model/todolist');\nconst result = await getList(database); // 获取\n"})}),"\n",(0,s.jsx)(n.p,{children:"getList 方法是 todolist model 的一个方法，旨在从 todo 表中获取所有的任务数据："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// model/todolist.js\nasync function getList(database) {\n  const result = await database.all('SELECT * FROM todo');\n  return result;\n}\n\nmodule.exports = {\n  getList,\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个模块非常简单，",(0,s.jsx)(n.code,{children:"database.all"}),"方法可以执行 SQL 语句，并以列表形式返回查询结果。所以我们在主体路由切面中直接引入这个模块，获取我们想要的查询结果，并返回："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"app.use(router.get('/list', async ({database, route, res}, next) => {\n  res.setHeader('Content-Type', 'application/json');\n  const {getList} = require('./model/todolist');\n  const result = await getList(database);\n  res.body = {data: result};\n  await next();\n}));\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样我们就实现了一个查询 SQLite 数据库 todo 表的服务，它返回的 JSON 结果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为现在数据表中没有数据，所以返回的是空数组。"}),"\n",(0,s.jsxs)(n.h2,{id:"从页面提交数据到服务器",children:["从页面提交数据到服务器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从页面提交数据到服务器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们需要实现一个数据提交的功能，让用户通过页面提交任务数据到服务器，再写入数据库。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://juejin.cn/editor/book/7133100888566005763/section/7133185465691144196",target:"_blank",rel:"noopener noreferrer",children:"第 13 节"}),"我们说 HTTP 请求的动作分为 GET、HEAD、OPTIONS、POST、PUT、PATCH、DELETE。其中，只有 GET 和 HEAD 不从body 传数据，其它都通过 body 传递。"]}),"\n",(0,s.jsx)(n.p,{children:"还记得我们前面介绍的解析参数的 param.js 拦截切面吗？我们只实现了解析 URL 上的 GET 请求的参数。接下来，我们就一起完善它，添加对 POST 请求的数据的解析。"}),"\n",(0,s.jsxs)(n.p,{children:["POST 请求与 GET 请求不同，有多种数据提交方式，由 request 的 Content-Type 字段决定。其中常用的有",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"、",(0,s.jsx)(n.code,{children:"application/json"}),"、",(0,s.jsx)(n.code,{children:"multipart/form-data"}),"等。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"是最常见的数据提交方式，在这种方式下，POST 的 body 中的数据格式和 GET 的 URL 参数的格式一样，都是经过 URLEncode 的",(0,s.jsx)(n.code,{children:"key1=value1&key2=value2&..."})," 的形式。所以，解析这种方式提交的数据，我们可以和解析 GET 里的参数一样，具体操作如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"POST http://www.example.com HTTP/1.1\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\ntitle=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3\n"})}),"\n",(0,s.jsxs)(n.p,{children:["需要注意的是，如果是",(0,s.jsx)(n.code,{children:"applicaiton/json"}),"格式，body 中的数据是字符串化的 JSON 数据，我们直接通过 JSON.parse 解析即可。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'POST http://www.example.com HTTP/1.1 \nContent-Type: application/json;charset=utf-8\n\n{"title":"test","sub":[1,2,3]}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"multipart/form-data"}),"格式则稍稍复杂，这种格式是用来发送多种格式的数据的，比如文件上传或者发送二进制数据等，",(0,s.jsx)(n.code,{children:"multipart/form-data"}),"会在请求的 body 中生成分隔符，用来分隔不同的字段，所以用这种格式提交的数据内容大致如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'POST http://www.example.com HTTP/1.1\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name="text"\n\ntitle\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA\nContent-Disposition: form-data; name="file"; filename="chrome.png"\nContent-Type: image/png\n\nPNG ... content of chrome.png ...\n------WebKitFormBoundaryrGKCBY7qhFd3TrwA--\n'})}),"\n",(0,s.jsx)(n.p,{children:"这种情况下，我们需要先分隔 SQLite 数据再解析，处理起来稍微麻烦一些。"}),"\n",(0,s.jsxs)(n.p,{children:["以上三种数据格式是浏览器推荐的规范。但其实，",(0,s.jsx)(n.strong,{children:"body 里传什么格式都行，HTTP 并没有规定 body 里的数据一定要按照规范，只要我们的服务器能对应解析就可以"}),"。当然，根据规范来传递数据能让我们的应用更加通用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"修改-paramjs",children:["修改 param.js",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#修改-paramjs",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在，我们来修改一下上一节课的 param 拦截切面，让它支持解析第一种和第二种形式的POST数据，至于第三种形式的 POST 数据的解析，可以使用一些第三方模块，这里先不做详细介绍了，如果你有兴趣可以在 npm 上找找相应的模块来学习。"}),"\n",(0,s.jsx)(n.p,{children:"在 param.js 中，我们添加对 POST 数据的解析："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const url = require('url');\nconst querystring = require('querystring');\n\nmodule.exports = async function (ctx, next) {\n  const {req} = ctx;\n  // 解析query数据\n  const {query} = url.parse(`http://${req.headers.host}${req.url}`);\n  ctx.params = querystring.parse(query);\n  // 解析POST\n  if(req.method === 'POST') {\n    const headers = req.headers;\n\n    // 读取POST的body数据\n    const body = await new Promise((resolve) => {\n      let data = '';\n      req.on('data', (chunk) => {\n        data += chunk.toString(); // convert Buffer to string\n      });\n      req.on('end', () => {\n        resolve(data);\n      });\n    });\n    ctx.params = ctx.params || {};\n    if(headers['content-type'] === 'application/x-www-form-urlencoded') {\n      Object.assign(ctx.params, querystring.parse(body));\n    } else if(headers['content-type'] === 'application/json') {\n      Object.assign(ctx.params, JSON.parse(body));\n    }\n  }\n  await next();\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上代码所示，读取 POST 请求的 BODY 是一个异步的过程：监听 req 对象的 data 和 end 事件，当 data 事件触发表示数据块被接收，end 事件触发表示数据接收完毕。然后，我们判断请求头的 Content-Type 字段，如果是",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"，那么用 querystring 模块来解析，如果是",(0,s.jsx)(n.code,{children:"application/json"}),"，那么直接 JSON.parse 即可。最终我们将解析的数据信息写入到 ctx.params 对象中，这样其他的拦截切面就可以使用它了。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们在 server 中添加相应的拦截切面："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const param = require('./aspect/param');\napp.use(param);\n\napp.use(router.post('/add', async ({database, params, res}, next) => {\n  // ...保存todolist数据\n}));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上代码所示，如果请求的路径是",(0,s.jsx)(n.code,{children:"/add"}),"，则将用户提交的数据保存到数据库的 todo 表中。"]}),"\n",(0,s.jsxs)(n.h2,{id:"提交的数据",children:["提交的数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#提交的数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["修改",(0,s.jsx)(n.code,{children:"model/todolist.js"}),"模块，添加插入数据的 API："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function getList(database) {\n  const result = await database.all('SELECT * FROM todo');\n  return result;\n}\n\nasync function addTask(database, {text, state}) {\n  try {\n    const data = await database.run('INSERT INTO todo(text,state) VALUES (?, ?)', text, state);\n    return {err: '', data};\n  } catch (ex) {\n    return {err: ex.message};\n  }\n}\n\nmodule.exports = {\n  getList,\n  addTask,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们增加一个 addTask 方法，将 text、state 信息插入到 todo 表中，这样我们在 server 中 POST 路由的拦截切面的完整代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"app.use(router.post('/add', async ({database, params, res}, next) => {\n  res.setHeader('Content-Type', 'application/json');\n  const {addTask} = require('./model/todolist');\n  const result = await addTask(database, params);\n  res.body = result;\n  await next();\n}));\n"})}),"\n",(0,s.jsx)(n.p,{children:"到此，我们完成了获取任务列表和添加任务数据的服务。为了课程的完整性，我们来看看客户端（浏览器）是如何和我们的 HTTP 服务器进行交互的。"}),"\n",(0,s.jsxs)(n.h2,{id:"与前端集成",children:["与前端集成",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与前端集成",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"因为 Todolist 应用比较简单，所以我们直接采用客户端渲染，将这个页面命名为 index.html，并保存在项目的静态目录 www 下。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n  <title>Todo List</title>\n  <link rel="stylesheet" href="static/css/style.css">\n</head>\n<body>\n  <header>\n    <input type="text" placeholder="输入一项任务..." id="itemText">\n    <button id="addItem">\n      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" style="enable-background:new 0 0 16 16;" xml:space="preserve">\n        <g>\n          <path fill="#25b99a" d="M16,8c0,0.5-0.5,1-1,1H9v6c0,0.5-0.5,1-1,1s-1-0.5-1-1V9H1C0.5,9,0,8.5,0,8s0.5-1,1-1h6V1c0-0.5,0.5-1,1-1s1,0.5,1,1v6h6C15.5,7,16,7.5,16,8z"></path>\n        </g>\n      </svg>\n		</button>\n  </header>\n  <ul class="todolist"></ul>\n  <script src="static/js/app.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,s.jsx)(n.p,{children:"然后，我们在服务器中添加静态加载文件的切面，让任意的 URL 请求返回相应的静态页面（这个例子中是 index.html 页面）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"app.use(router.get('.*', async ({req, res}, next) => {\n  let filePath = path.resolve(__dirname, path.join('../www', url.fileURLToPath(`file:///${req.url}`)));\n\n  if(fs.existsSync(filePath)) {\n    const stats = fs.statSync(filePath);\n    if(stats.isDirectory()) {\n      filePath = path.join(filePath, 'index.html');\n    }\n    if(fs.existsSync(filePath)) {\n      const {ext} = path.parse(filePath);\n      const stats = fs.statSync(filePath);\n      const timeStamp = req.headers['if-modified-since'];\n      res.statusCode = 200;\n      if(timeStamp && Number(timeStamp) === stats.mtimeMs) {\n        res.statusCode = 304;\n      }\n      const mimeType = mime.getType(ext);\n      res.setHeader('Content-Type', mimeType);\n      res.setHeader('Cache-Control', 'max-age=86400');\n      res.setHeader('Last-Modified', stats.mtimeMs);\n      const acceptEncoding = req.headers['accept-encoding'];\n      const compress = acceptEncoding && /^(text|application)\\//.test(mimeType);\n      let compressionEncoding;\n      if(compress) {\n        acceptEncoding.split(/\\s*,\\s*/).some((encoding) => {\n          if(encoding === 'gzip') {\n            res.setHeader('Content-Encoding', 'gzip');\n            compressionEncoding = encoding;\n            return true;\n          }\n          if(encoding === 'deflate') {\n            res.setHeader('Content-Encoding', 'deflate');\n            compressionEncoding = encoding;\n            return true;\n          }\n          if(encoding === 'br') {\n            res.setHeader('Content-Encoding', 'br');\n            compressionEncoding = encoding;\n            return true;\n          }\n          return false;\n        });\n      }\n      if(res.statusCode === 200) {\n        const fileStream = fs.createReadStream(filePath);\n        if(compress && compressionEncoding) {\n          let comp;\n          if(compressionEncoding === 'gzip') {\n            comp = zlib.createGzip();\n          } else if(compressionEncoding === 'deflate') {\n            comp = zlib.createDeflate();\n          } else {\n            comp = zlib.createBrotliCompress();\n          }\n          res.body = fileStream.pipe(comp);\n        } else {\n          res.body = fileStream;\n        }\n      }\n    }\n  } else {\n    res.setHeader('Content-Type', 'text/html');\n    res.body = '<h1>Not Found</h1>';\n    res.statusCode = 404;\n  }\n\n  await next();\n}));\n"})}),"\n",(0,s.jsx)(n.p,{children:"当浏览器加载 index.html 页面后，会自动运行 app.js 中的 loadItem 方法，从服务器端获取任务列表，它的实现如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function loadItems(list) {\n  const {data} = await (await fetch('/list')).json();\n  data.forEach(({state, text}) => addItem(list, text, states[state]));\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上代码所示，我们通过浏览器的 fetch 方法请求",(0,s.jsx)(n.code,{children:"GET /list"}),"，以获取 todo 表的数据，并通过 addItem 方法将数据渲染到页面上。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function addItem(id, list, text, state = 'todo') {\n  const removeSVG = `... 省略svg数据 ...`;\n  const completeSVG = ` ... 省略svg数据 ...`;\n\n  const item = document.createElement('li');\n  item.className = state;\n  item.innerHTML = `${text}<button class=\"remove\">${removeSVG}</button><button class=\"complete\">${completeSVG}</button>`;\n  list.insertBefore(item, list.children[0]);\n\n  item.dataset.id = id;\n\n  const completeBtn = item.querySelector('button.complete');\n\n  completeBtn.addEventListener('click', () => {\n    const id = item.dataset.id;\n    if(item.className === 'todo') {\n      updateItem(id, 1);\n      completeItem(item);\n    } else {\n      updateItem(id, 0);\n      uncompleteItem(item);\n    }\n  });\n\n  const removeBtn = item.querySelector('button.remove');\n\n  removeBtn.addEventListener('click', () => {\n    updateItem(id, 2);\n    removeItem(item);\n  });\n\n  return item;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同样的，当我们点击按钮添加任务时，浏览器通过",(0,s.jsx)(n.code,{children:"POST /add"}),"请求将添加的数据保存到数据库中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function saveItem(text) {\n  const result = await (await fetch('/add', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: `text=${text}&state=0`,\n  })).json();\n\n  return result;\n}\n\nconst addItemBtn = document.getElementById('addItem');\n\naddItemBtn.addEventListener('click', async () => {\n  const text = inputText.value;\n  if(text) {\n    const result = await saveItem(text);\n    if(!result.err) {\n      addItem(result.data.lastID, list, text);\n      inputText.value = '';\n      inputText.focus();\n    } else {\n      throw new Error(result.err);\n    }\n  }\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们使用 fetch 方法请求服务端",(0,s.jsx)(n.code,{children:"/add"}),"接口，method 是 POST，Content-Type 是",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"，然后我们将 text 和 state 传给服务器。"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的代码演示了浏览器和服务器之间的交互。当然这个交互除了 list 和 add 之外还两个功能，一个是删除任务，一个是将任务变更为已完成状态，或者从已完成恢复为未完成，它们实际上都属于变更数据状态的操作，只需要一个 update 接口就可以。你可以在我们的",(0,s.jsx)(n.a,{href:"https://github.com/akira-cn/todolist",target:"_blank",rel:"noopener noreferrer",children:"GitHub仓库"}),"中查看项目的完整代码。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节课我们介绍了如何在服务端实现持久化存储。我们采用了一个轻量级的数据库 SQLite，使用 SQLite3 和 SQLite 模块来操作数据库，同时添加了查询 todo 数据列表和添加 todo 项的 API，并将它们写入到具体的拦截切面中，这样就可以实现对应的服务端功能了。"}),"\n",(0,s.jsx)(n.p,{children:"此外，我们还学习了如何解析 POST 数据的内容，根据 POST 数据不同的类型，使用不同的方式进行解析。"}),"\n",(0,s.jsx)(n.p,{children:"完成了操作数据库，我们就实现了 HTTP 动态服务器最基本的功能，现在我们可以通过 Web 来增、删、改、查数据了。不过 Web 应用除了处理数据，还有其他一些细节需要考虑，比如用户的登录和权限、应用的操作状态等等，这些需要通过状态和会话管理来实现，这是我们下节课要讲的。"}),"\n",(0,s.jsx)(n.p,{children:"最后再多说一点，不知道你是否注意到了我们的代码组织形式。一般来说，实现一个服务器接口是在服务器端做 2 件事情："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"在 model 模块中添加一个方法操作数据库；"}),"\n",(0,s.jsx)(n.li,{children:"在 server 中添加一个拦截切面，提供一个 URL 给前端调用。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在前端也做 2 件事情："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"用 fetch 方法调用对应的 URL 发送请求；"}),"\n",(0,s.jsx)(n.li,{children:"根据请求返回的结果更新UI界面。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"服务端的两件事情，分别属于两个不同的层次，一个是模型（model）层，一个是逻辑（logical）层，如果我们把逻辑层再细分，考虑服务端渲染又可以分为视图（view）层和控制（controller）层，这样我们的服务器就开始有了 MVC 模式的雏形。MVC 是服务器常用的设计模式，后面我们会详细介绍它，一起期待下吧！"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let p=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F19%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8.md"]={toc:[{text:"SQLite 数据库",id:"sqlite-数据库",depth:2},{text:"设计 Todolist 数据表",id:"设计-todolist-数据表",depth:2},{text:"实现服务端主体逻辑",id:"实现服务端主体逻辑",depth:2},{text:"从页面提交数据到服务器",id:"从页面提交数据到服务器",depth:2},{text:"修改 param.js",id:"修改-paramjs",depth:2},{text:"提交的数据",id:"提交的数据",depth:2},{text:"与前端集成",id:"与前端集成",depth:2},{text:"总结",id:"总结",depth:2}],title:"19 理解 HTTP：持久化存储",headingTitle:"19 理解 HTTP：持久化存储",frontmatter:{}}}}]);