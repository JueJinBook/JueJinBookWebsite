"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85941"],{957822:function(n,e,t){t.r(e),t.d(e,{default:()=>m});var c=t(552676),r=t(740453);let s=t.p+"static/image/836deaf938090b67d7d721b52a9341a9.1d5008a0.webp",l=t.p+"static/image/1daf0a7ab862f1caefa02f413bdb8458.5ae29481.webp",i=t.p+"static/image/171a74930ea0bb721db9b83569c006a0.592ed0f5.webp",d=t.p+"static/image/d06258a36c50480d2bc1da7ead642ec7.ca97898b.webp",o=t.p+"static/image/405e6e97845ab483775d72ae49ffee1c.0441392f.webp",a=t.p+"static/image/c086c2a983c7054dfb317202e6862710.22b010f9.webp",u=t.p+"static/image/faffecb4732af0c90c6e8b3b86bb9170.3e8332cd.webp",h=t.p+"static/image/3f63c190e19f1ad7ec7f16a6ed611bae.518e6402.webp",p=t.p+"static/image/5393adf25ce8b9286237c6a00573f32f.6ce4ad15.webp",x=t.p+"static/image/e8cf9f4cd4f8d7921f1793bbed6f8b2b.378575d3.webp",b=t.p+"static/image/0fcfac231fb2eda110d2e4eb606107e2.cf86cecf.webp",j=t.p+"static/image/9765bdfb0782e8fe541fa483487bdd55.e303a307.webp";function f(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",strong:"strong",h3:"h3",pre:"pre",code:"code",img:"img",hr:"hr"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"3-语法篇--从-svelte-4-到符文",children:["3-语法篇 ❘ 从 Svelte 4 到符文",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-语法篇--从-svelte-4-到符文",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"推荐学习指数：⭐️⭐"}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"1-前言",children:["1. 前言",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"本篇针对使用过 Svelte 4 的同学"}),"，讲解 Svelte 4 中存在的问题，以及使用符文带来的好处。如果初学就是 Svelte 5，本篇简单了解即可。"]}),"\n",(0,c.jsxs)(e.h2,{id:"2-svelte-4-中的问题",children:["2. Svelte 4 中的问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-svelte-4-中的问题",children:"#"})]}),"\n",(0,c.jsxs)(e.h3,{id:"21-问题-1状态与派生状态不一致",children:["2.1. 问题 1：状态与派生状态不一致",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21-问题-1状态与派生状态不一致",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"这是一段 Svelte 4 中的代码："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = 0;\n  $: double = count * 2\n\n  function increment() {\n    count += 1\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/11881df2378146da9f1d2eef1db3dad8?version=4.2.18",title:"https://svelte.dev/repl/11881df2378146da9f1d2eef1db3dad8?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"看起来很正常，但其实有一个小问题。"}),"\n",(0,c.jsxs)(e.p,{children:["我们在 ",(0,c.jsx)(e.code,{children:"increment()"})," 函数中打印一下 ",(0,c.jsx)(e.code,{children:"count"})," 和 ",(0,c.jsx)(e.code,{children:"double"})," 的值："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-diff",children:"<script>\n  let count = 0;\n  $: double = count * 2\n\n  function increment() {\n    count += 1\n+   console.log({count, double})\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/4f705d1fa36e4090bdb9c22d0da0b0aa?version=4.2.18",title:"https://svelte.dev/repl/4f705d1fa36e4090bdb9c22d0da0b0aa?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"当第一次点击的时候，count 的值是 1，double 的值却是 0。第二次点击的时候，count 的值是 2，double 的值却是 2。你会发现，count 和 double 的值并不同步。"}),"\n",(0,c.jsx)(e.p,{children:"这是为什么呢？"}),"\n",(0,c.jsx)(e.p,{children:"这是因为 Svelte 为了避免重复计算，会确保没有其他值更改的时候，才会重新计算 double，所以它会拖到快要进行 DOM 更新时再重新计算，所以 double 变更的时机要晚于 console.log 执行的时机。"}),"\n",(0,c.jsx)(e.p,{children:"如果你想要获取同步的值，你可以这样写："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-diff",children:"<script>\n  let count = 0;\n  $: double = count * 2\n\n  function increment() {\n    count += 1\n+   requestAnimationFrame(() => {\n+      console.log({count, double})\n+   })\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/c0c8da888f1841788c9f5b8c2fe7c633?version=4.2.18",title:"https://svelte.dev/repl/c0c8da888f1841788c9f5b8c2fe7c633?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsxs)(e.h3,{id:"22-问题-2依赖追踪只发生在编译时",children:["2.2. 问题 2：依赖追踪只发生在编译时",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-问题-2依赖追踪只发生在编译时",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["第二个问题是依赖追踪只发生在编译时。还是上节这个例子，我们用 ",(0,c.jsx)(e.code,{children:"doubleCount"})," 函数优化下响应式声明："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = 0;\n  $: double = doubleCount()\n\n  function doubleCount() {\n    return count * 2\n  }\n\n  function increment() {\n    count += 1\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如果这样写，double 是不会响应式更新的。",(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/55461f0b09b24b18ad2cd130bd5bc80b?version=4.2.18",title:"https://svelte.dev/repl/55461f0b09b24b18ad2cd130bd5bc80b?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"这是因为编译器无法看到依赖关系，所以 double 并不会响应式更新。如果你想要更新，你需要这样做："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-diff",children:"<script>\n  let count = 0;\n-	$: double = doubleCount()\n+	$: double = doubleCount(count)\n\n  +function doubleCount() {\n    return count * 2\n  }\n\n  function increment() {\n    count += 1\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:"通过在参数中传入 count，让 Svelte 在编译的时候知道 double 依赖了 count，才会让 double 在 count 变化的时候重新计算。"}),"\n",(0,c.jsxs)(e.h3,{id:"23-问题-3学习成本高",children:["2.3. 问题 3：学习成本高",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23-问题-3学习成本高",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"还是这个计数器："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = 0;\n\n  $: double = count * 2\n\n  function increment() {\n    count += 1\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:"假设有很多计数器，我们创建一个函数将代码复用："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  function createCounter() {\n    let count = 0;\n\n    $: double = count * 2\n\n    function increment() {\n      count += 1\n    }\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["因为 ",(0,c.jsx)(e.code,{children:"let"})," 没有声明在顶层，所以响应式会失效，",(0,c.jsx)(e.code,{children:"$: double"})," 也变成了普通的语法，没有什么作用。"]}),"\n",(0,c.jsx)(e.p,{children:"为了让 count 值变得响应式，我们需要借助 Store："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:'<script>\n  import { writable } from "svelte/store";\n\n  function createCounter() {\n    const { subscribe, update } = writable(0)\n    function increment() {\n      update((count) => count+1)\n    }\n    return {\n      subscribe,\n      increment\n    }\n  }\n\n  const counter = createCounter()\n<\/script>\n\n<button on:click={counter.increment}>Click</button>\n\n{$counter}\n'})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/b21d11c8598f484e81cbb8b368d4fe81?version=4.2.18",title:"https://svelte.dev/repl/b21d11c8598f484e81cbb8b368d4fe81?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["这样做本身没有什么问题，但是对于初学者而言，仅仅是为了解决一个普通的代码复用问题，却要去用复杂的 Store，还要理解 Store contract 以及掌握 ",(0,c.jsx)(e.code,{children:"$xxx"})," 这种自动订阅语法。这会提高初学者的理解和学习成本。"]}),"\n",(0,c.jsxs)(e.h3,{id:"24-问题-4重复计算",children:["2.4. 问题 4：重复计算",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24-问题-4重复计算",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"这是一个 Bindings 章节用到的例子："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let todos = [\n    { done: false, text: 'finish Svelte tutorial' },\n    { done: false, text: 'build an app' },\n    { done: false, text: 'world domination' }\n  ];\n\n  function remaining(todos) {\n  console.log('recalculating')\n  return todos.filter((t) => !t.done).length;\n  }\n<\/script>\n\n<ul class=\"todos\">\n  {#each todos as todo}\n  <li class:done={todo.done}>\n    <input\n      type=\"checkbox\"\n      bind:checked={todo.done}\n      />\n\n      <input\n        type=\"text\"\n        placeholder=\"What needs to be done?\"\n        bind:value={todo.text}\n        />\n      </li>\n\n  {/each}\n</ul>\n\n<p>未完成：{remaining(todos)}</p>\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/b5fe143c887a43a89fe2c6480e0537a6?version=4.2.18",title:"https://svelte.dev/repl/b5fe143c887a43a89fe2c6480e0537a6?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["你会发现，当我们修改任务的完成状态时，",(0,c.jsx)(e.code,{children:"remaining(todos)"})," 重新计算，这是没有问题的，但当我们修改任务的内容时，也会导致 ",(0,c.jsx)(e.code,{children:"remaining(todos)"})," 重新计算，但这是没有必要的。如果列表很长，这会造成性能问题。难道就不能避免这些不必要的计算吗？"]}),"\n",(0,c.jsxs)(e.h2,{id:"3-runes",children:["3. Runes",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-runes",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"Runes 解决了这些问题！"}),"\n",(0,c.jsx)(e.p,{children:"Runes，中文译文“符文”，一个听起来很帅，但又会让人感到有些莫名其妙的名词。想想游戏中的符文作用，往往是有着特殊作用的一个字母或者标记："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"比如在巫师 3 中，通过给武器嵌入符文石，可以增强武器力量，比如嵌入火焰符文会额外造成火焰伤害。"}),"\n",(0,c.jsxs)(e.p,{children:["Svelte 5 中的符文也差不多，也是通过一些字符实现特殊作用，只不过游戏中的符文千奇百怪，影响的是角色属性，Svelte 中的符文是 ",(0,c.jsx)(e.code,{children:"$"}),"开头的字符，影响的是 Svelte 编译器。"]}),"\n",(0,c.jsxs)(e.p,{children:["简单来说，符文就是影响 Svelte 编译器的符号。其实 Svelte 4 使用的 ",(0,c.jsx)(e.code,{children:"let"}),"、",(0,c.jsx)(e.code,{children:"="}),"、",(0,c.jsx)(e.code,{children:"export"}),"、",(0,c.jsx)(e.code,{children:"$:"})," 就是一种“符文”，但 Svelte 5 新增的符文将使用函数语法替代它们并实现更多的功能。"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"当使用 Svelte 的时候，符文就是语言的一部分，无须导入（会编译真的可以为所欲为呀！）。"})}),"\n",(0,c.jsxs)(e.h3,{id:"31-state",children:["3.1. $state",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31-state",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"首先介绍的是状态符文，这是 Svelte 4 的代码："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = 0;\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button onclick={increment}>\n  clicks: {count}\n</button>\n\n"})}),"\n",(0,c.jsx)(e.p,{children:"这是 Svelte 5 的代码："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button onclick={increment}>\n  clicks: {count}\n</button>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["其实就是改了响应式变量的声明方式，之前是 ",(0,c.jsx)(e.code,{children:"let count = 0"}),"，现在是 ",(0,c.jsx)(e.code,{children:"let count = $state(0)"}),"。猛一看，代码变得繁琐了一点，但使用状态符文会带来很多好处。"]}),"\n",(0,c.jsxs)(e.p,{children:["就比如响应式将不限制于在组件顶层进行 ",(0,c.jsx)(e.code,{children:"let"})," 声明，在应用的任何位置都可以（在本篇的“好处 1：通用响应式” 章节我们会举例解释）。而且，",(0,c.jsx)(e.code,{children:"$state"})," 也可以用于普通对象和数组："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let numbers = $state([1, 2, 3]);\n<\/script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n  push\n</button>\n\n<button onclick={() => numbers.pop()}> pop </button>\n\n<p>\n  {numbers.join(' + ') || 0}\n  =\n  {numbers.reduce((a, b) => a + b, 0)}\n</p>\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"32-derived",children:["3.2. $derived",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#32-derived",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["之前的响应式声明 ",(0,c.jsx)(e.code,{children:"$："}),"改为使用 ",(0,c.jsx)(e.code,{children:"$derived"})," 符文。使用之前："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = 0;\n  $: double = count * 2\n\n  function increment() {\n    count += 1\n  }\n<\/script>\n\n<button on:click={increment}>Click</button>\n\n{count} * 2 = {double}\n"})}),"\n",(0,c.jsx)(e.p,{children:"使用之后："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button onclick={increment}>\n  clicks: {count}\n</button>\n\n<p>{count} * 2 = {doubled}</p>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["使用 ",(0,c.jsx)(e.code,{children:"$derived"})," 的好处在于，doubled 的值始终是新的，这就解决了问题 1："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"而且即便你进行重构："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n  let doubled = $derived(doubleCount());\n\n  function doubleCount() {\n    return count * 2;\n  }\n\n  function increment() {\n    count += 1;\n    console.log({count, doubled})\n  }\n<\/script>\n\n<button onclick={increment}>\n  clicks: {count}\n</button>\n\n<p>{count} * 2 = {doubled}</p>\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样也是可以生效的："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"使用符文，依赖项将在运行时进行跟踪"}),"，这就解决了问题 2。"]}),"\n",(0,c.jsxs)(e.h3,{id:"33-好处-1通用响应式universal-reactivity-",children:["3.3. 好处 1：通用响应式（Universal reactivity ）",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#33-好处-1通用响应式universal-reactivity-",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"使用符文带来的一大好处就是通用响应式，意味着你可以在应用程序的任何地方创建响应状态，而不仅仅是在组件的顶层。比如这是一个普通的计数器："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n<\/script>\n\n<button onclick={() => {\n  count += 1\n}}>\n  clicks: {count}\n</button>\n"})}),"\n",(0,c.jsx)(e.p,{children:"你可以将逻辑封装到一个函数中，以便它可以在多个地方使用："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  function createCounter() {\n    let count = $state(0);\n    return { count }\n  }\n\n  let counter = createCounter()\n<\/script>\n\n<button onclick={() => {\n  counter.count += 1\n}}>\n  clicks: {counter.count}\n</button>\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样写是不会有效果的，因为响应式并不能跨域函数的边界："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["要是想生效，可以借助 ",(0,c.jsx)(e.code,{children:"getter"})," 和 ",(0,c.jsx)(e.code,{children:"setter"})," 语法："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  function createCounter() {\n    let count = $state(0);\n    return {\n      get count() {\n        return count\n      },\n      set count(value) {\n        count = value\n      }\n    }\n  }\n\n  let counter = createCounter()\n<\/script>\n\n<button onclick={() => {\n  counter.count += 1\n}}>\n  clicks: {counter.count}\n</button>\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE11Q3UrFMAx-lRC82HD4czvXgfgY1ovZk0lxJx1tekBK31262enxKmm-v6QJZ7tQwP41IU9nwh6f1xU7lK-1PMKFFiHsMLjoTZkMwXi7yqgZYI5sxDoG42kSenGRhXzTQioowEICpgxBwU2QSah5aJ92zJNEz5UJ8FG5v_I_tA2p09zVLhyiy7REulLW4A05pHuzlay5lGNJ8qD-X6J5uD8O1jy8RxHH4Ngs1nyq1LSgxj31x-Nuz71V8Kg55-2fNnLoIV1xcjHfDUfs8OxOdrZ0wl58pPyWvwGR-cwynAEAAA==",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE11Q3UrFMAx-lRC82HD4czvXgfgY1ovZk0lxJx1tekBK31262enxKmm-v6QJZ7tQwP41IU9nwh6f1xU7lK-1PMKFFiHsMLjoTZkMwXi7yqgZYI5sxDoG42kSenGRhXzTQioowEICpgxBwU2QSah5aJ92zJNEz5UJ8FG5v_I_tA2p09zVLhyiy7REulLW4A05pHuzlay5lGNJ8qD-X6J5uD8O1jy8RxHH4Ngs1nyq1LSgxj31x-Nuz71V8Kg55-2fNnLoIV1xcjHfDUfs8OxOdrZ0wl58pPyWvwGR-cwynAEAAA==",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["尽管我们使用了符文，但我们依然可以把函数封装在 ",(0,c.jsx)(e.code,{children:".svelte"})," 组件之外，比如 ",(0,c.jsx)(e.code,{children:".svelte.js"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import { createCounter } from './counter.svelte.js'\n\n  let counter = createCounter()\n<\/script>\n\n<button onclick={() => {\n  counter.count += 1\n}}>\n  clicks: {counter.count}\n</button>\n\n\x3c!-- counter.svelte.js --\x3e\nexport function createCounter() {\n  let count = $state(0);\n  return {\n    get count() {\n      return count\n    },\n    set count(value) {\n      count = value\n    }\n  }\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE2VQ0U6EMBD8lU1jchAJp694kBg_w_qAvcX0hC1ptxcN6b-bUsBD-7Lp7Mzszk6i0z06Ub1OgtoBRSWex1EUgr_H-HFX7BlFIZzxVkXk5JTVIzeSAPQwGsswgbLYMr4YT4wWAnTWDHAojyohZbIpL-4gKQp7ZFh6UO_VWS7pdNyGSDq9e2ZDYEj1Wn3WU5ZD3cAUfVb_ucJ9DY-SQph3m8mugmnHCdE8GTaiEIM5607jWVRsPYZiO8J-8d97XNztLfBrzt95UqwN_Q2SdtyyQg13jlvG7CF_ih2L7C0lFsDHyluF8S2UGU9YKFJ1G_3a9h5vNOuwGV9EsQRJ4X_mt_ADbrVjNQQCAAA=",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE2VQ0U6EMBD8lU1jchAJp694kBg_w_qAvcX0hC1ptxcN6b-bUsBD-7Lp7Mzszk6i0z06Ub1OgtoBRSWex1EUgr_H-HFX7BlFIZzxVkXk5JTVIzeSAPQwGsswgbLYMr4YT4wWAnTWDHAojyohZbIpL-4gKQp7ZFh6UO_VWS7pdNyGSDq9e2ZDYEj1Wn3WU5ZD3cAUfVb_ucJ9DY-SQph3m8mugmnHCdE8GTaiEIM5607jWVRsPYZiO8J-8d97XNztLfBrzt95UqwN_Q2SdtyyQg13jlvG7CF_ih2L7C0lFsDHyluF8S2UGU9YKFJ1G_3a9h5vNOuwGV9EsQRJ4X_mt_ADbrVjNQQCAAA=",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果同上"})}),"\n",(0,c.jsx)(e.p,{children:"而在 Svelte 4 中，相同的功能我们需要借助 Store 来实现："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:'<script>\n  import { writable } from "svelte/store";\n  function createCounter() {\n    return writable(0)\n  }\n\n  let count = createCounter()\n<\/script>\n\n<button onclick={() => {\n  $count += 1\n}}>\n  clicks: {$count}\n</button>\n'})}),"\n",(0,c.jsxs)(e.p,{children:["这就是问题 3 反映的问题，原本很简单的功能，我们却需要完全改变代码的编写方式，导入 ",(0,c.jsx)(e.code,{children:"writeable"}),"，理解 Store 相关的 API，知道背后的 subscribe 和 update 功能，还要使用 ",(0,c.jsx)(e.code,{children:"$store"}),"实现自动订阅。这增加了很多需要理解的内容。所以使用符文后，对于初学者而言，学习成本更少，心智负担更小。"]}),"\n",(0,c.jsxs)(e.h3,{id:"34-好处-2细粒度响应式fine-grained-reactivity",children:["3.4. 好处 2：细粒度响应式（Fine-grained reactivity）",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#34-好处-2细粒度响应式fine-grained-reactivity",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"使用符文的另一大好处是细粒度的响应式，我们以问题 4 为例，现在我们将原本的代码改为："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-diff",children:"<script>\n+  let todos = $state([\n+    { done: false, text: 'finish Svelte tutorial' },\n+    { done: false, text: 'build an app' },\n+    { done: false, text: 'world domination' }\n+	]);\n\n-  let todos = [\n-    { done: false, text: 'finish Svelte tutorial' },\n-    { done: false, text: 'build an app' },\n-    { done: false, text: 'world domination' }\n-  ];\n\n  function remaining(todos) {\n    console.log('recalculating')\n    return todos.filter((t) => !t.done).length;\n  }\n<\/script>\n\n<ul class=\"todos\">\n  {#each todos as todo}\n    <li class:done={todo.done}>\n      <input\n        type=\"checkbox\"\n        bind:checked={todo.done}\n      />\n\n      <input\n        type=\"text\"\n        placeholder=\"What needs to be done?\"\n        bind:value={todo.text}\n      />\n    </li>\n\n  {/each}\n</ul>\n\n<p>未完成：{remaining(todos)}</p>\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE4WRv47UMBDGX2UwSLsrRbt9LgniGSgozld47cnGYnYc2ePjUJSegoIa8QQUPAGvw7W8AnLCwgHS0dnz55v5fjOp3hMmVV9Pis0ZVa1ejKOqlLwdyyfdIgmqSqWQoy2RJtnoR-k0AxAKSHAhQQvPkhjB7XWJA0zgAmMNvaGEFQjeSQ2b3rNPA7xcREGyhOgNbWCuHus6Zk8ODIMZx__VvgmRHLhw9mzEB97ArFnLze5Kc-nrM9sSh4hn49nzabsY2MG0ytrAKRDuKZy2m4jWkM1kxPNps1srIkqOvPre954E43YrO2g7eCL7stRuT8gnGa5Kw6y5OfxiprnJBJZMSq1Wi4ZWC8vpKRo7_MRp0vKY14kN-bWlLurtVFLLoLlbCwAaz2OWyw-gnK_Vyg5oXx_DnVa_U0fPrl4S6B5qXSoO3YrqEdkC-6HkSMbiEMhhbLV6NRgBRnTFBBxxOdTzf1a4NZQvZorgHwssww_kVzSHgmYBmWmFOHb3nz5_-_L-_t2H718_Tn9fc24OY6cqdQ7O9x6dqiVmnG_mH6t-pyDwAgAA",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE4WRv47UMBDGX2UwSLsrRbt9LgniGSgozld47cnGYnYc2ePjUJSegoIa8QQUPAGvw7W8AnLCwgHS0dnz55v5fjOp3hMmVV9Pis0ZVa1ejKOqlLwdyyfdIgmqSqWQoy2RJtnoR-k0AxAKSHAhQQvPkhjB7XWJA0zgAmMNvaGEFQjeSQ2b3rNPA7xcREGyhOgNbWCuHus6Zk8ODIMZx__VvgmRHLhw9mzEB97ArFnLze5Kc-nrM9sSh4hn49nzabsY2MG0ytrAKRDuKZy2m4jWkM1kxPNps1srIkqOvPre954E43YrO2g7eCL7stRuT8gnGa5Kw6y5OfxiprnJBJZMSq1Wi4ZWC8vpKRo7_MRp0vKY14kN-bWlLurtVFLLoLlbCwAaz2OWyw-gnK_Vyg5oXx_DnVa_U0fPrl4S6B5qXSoO3YrqEdkC-6HkSMbiEMhhbLV6NRgBRnTFBBxxOdTzf1a4NZQvZorgHwssww_kVzSHgmYBmWmFOHb3nz5_-_L-_t2H718_Tn9fc24OY6cqdQ7O9x6dqiVmnG_mH6t-pyDwAgAA",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"，仅仅使用 ",(0,c.jsx)(e.code,{children:"$state"})," 包裹一下 ",(0,c.jsx)(e.code,{children:"todos"}),"，你就会发现不再进行重复计算："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"这就是使用符文的好处，将响应式状态的颗粒度进一步细化，只会在需要的时候进行更新。"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"注：你可能会好奇，这些特点到底是怎么实现的？简单来说，就是借助了 Signals 这一概念，我们会在原理篇中详细介绍。"}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"4-最后",children:["4. 最后",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-最后",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"当然，Svelte5 的符文可不止这两个，本篇主要是为大家讲解符文所解决的问题，以及理解使用符文的必要性。符文改变了 Svelte 项目的开发方式，让你的应用程序更小、更快、代码更容易理解、更容易重构。下篇我们会详细介绍符文的完整用法。"})]})}function g(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(f,{...n})}):f(n)}let m=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F3-%E8%AF%AD%E6%B3%95%E7%AF%87%20%E2%9D%98%20%E4%BB%8E%20Svelte%204%20%E5%88%B0%E7%AC%A6%E6%96%87.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Svelte 4 中的问题",id:"2-svelte-4-中的问题",depth:2},{text:"2.1. 问题 1：状态与派生状态不一致",id:"21-问题-1状态与派生状态不一致",depth:3},{text:"2.2. 问题 2：依赖追踪只发生在编译时",id:"22-问题-2依赖追踪只发生在编译时",depth:3},{text:"2.3. 问题 3：学习成本高",id:"23-问题-3学习成本高",depth:3},{text:"2.4. 问题 4：重复计算",id:"24-问题-4重复计算",depth:3},{text:"3. Runes",id:"3-runes",depth:2},{text:"3.1. $state",id:"31-state",depth:3},{text:"3.2. $derived",id:"32-derived",depth:3},{text:"3.3. 好处 1：通用响应式（Universal reactivity ）",id:"33-好处-1通用响应式universal-reactivity-",depth:3},{text:"3.4. 好处 2：细粒度响应式（Fine-grained reactivity）",id:"34-好处-2细粒度响应式fine-grained-reactivity",depth:3},{text:"4. 最后",id:"4-最后",depth:2}],title:"3-语法篇 ❘ 从 Svelte 4 到符文",headingTitle:"3-语法篇 ❘ 从 Svelte 4 到符文",frontmatter:{}}}}]);