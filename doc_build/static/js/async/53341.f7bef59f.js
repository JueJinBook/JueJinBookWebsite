"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53341"],{516090:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var t=r(552676),s=r(740453);let i=r.p+"static/image/2a6d7ad37cd596117c24ab7dc98335d3.b8b06b82.webp",c=r.p+"static/image/8609eb4e6915d9ef6142123e09fcf948.7f4f67c6.webp",d=r.p+"static/image/13530499bb32cfbfb974ec4e551bc642.2628304d.webp",a=r.p+"static/image/6c895a4cc18594346b52a9f44080247b.65541962.webp",l=r.p+"static/image/8145bb8756e6f46581b6654d25d59601.9d853b1c.webp",o=r.p+"static/image/22a38a7bba67a17fb57cac64fefd6b1e.62658db9.webp",h=r.p+"static/image/3562fa019c8304d1a7ad93674b5a1e84.2c6f665f.webp",p=r.p+"static/image/bc8f3bec6ea755044061d35e5cad19ef.8134c88b.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",code:"code",pre:"pre",img:"img",ol:"ol",li:"li",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"11渲染篇-_-服务端组件和客户端组件",children:["11.渲染篇 _ 服务端组件和客户端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11渲染篇-_-服务端组件和客户端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"服务端组件和客户端组件是 Next.js 中非常重要的概念。如果没有细致的了解过，你可能会简单的以为所谓服务端组件就是 SSR，客户端组件就是 CSR，服务端组件在服务端进行渲染，客户端组件在客户端进行渲染等等，实际上并非如此。本篇就让我们深入学习和探究 Next.js 的双组件模型吧！"}),"\n",(0,t.jsxs)(n.h2,{id:"服务端组件",children:["服务端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-介绍",children:["1. 介绍",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-介绍",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在 Next.js 中，组件默认就是服务端组件。"}),"\n",(0,t.jsxs)(n.p,{children:["举个例子，新建 ",(0,t.jsx)(n.code,{children:"app/todo/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export default async function Page() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/todos')\n  const data = (await res.json()).slice(0, 10)\n  console.log(data)\n  return <ul>\n    {data.map(({ title, id }) => {\n      return <li key={id}>{title}</li>\n    })}\n  </ul>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"请求会在服务端执行，并将渲染后的 HTML 发送给客户端："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:"截屏2024-03-05 15.59.27.png"})}),"\n",(0,t.jsxs)(n.p,{children:["因为在服务端执行，",(0,t.jsx)(n.code,{children:"console"})," 打印的结果也只可能会出现在命令行中，而非客户端浏览器中。"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-优势",children:["2. 优势",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-优势",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"使用服务端渲染有很多好处："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"数据获取：通常服务端环境（网络、性能等）更好，离数据源更近，在服务端获取数据会更快。通过减少数据加载时间以及客户端发出的请求数量来提高性能"}),"\n",(0,t.jsx)(n.li,{children:"安全：在服务端保留敏感数据和逻辑，不用担心暴露给客户端"}),"\n",(0,t.jsx)(n.li,{children:"缓存：服务端渲染的结果可以在后续的请求中复用，提高性能"}),"\n",(0,t.jsx)(n.li,{children:"bundle 大小：服务端组件的代码不会打包到 bundle 中，减少了 bundle 包的大小"}),"\n",(0,t.jsx)(n.li,{children:"初始页面加载和 FCP：服务端渲染生成 HTML，快速展示 UI"}),"\n",(0,t.jsx)(n.li,{children:"Streaming：服务端组件可以将渲染工作拆分为 chunks，并在准备就绪时将它们流式传输到客户端。用户可以更早看到页面的部分内容，而不必等待整个页面渲染完毕"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["因为服务端组件的诸多好处，",(0,t.jsx)(n.strong,{children:"在实际项目开发的时候，能使用服务端组件就尽可能使用服务端组件"}),"。"]}),"\n",(0,t.jsxs)(n.h3,{id:"3-限制",children:["3. 限制",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-限制",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"虽然使用服务端组件有很多好处，但使用服务端组件也有一些限制，比如不能使用 useState 管理状态，不能使用浏览器的 API 等等。如果我们使用了 Next.js 会报错，比如我们将代码修改为："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\nexport default async function Page() {\n\n  const [title, setTitle] = useState('');\n\n  const res = await fetch('https://jsonplaceholder.typicode.com/todos')\n  const data = (await res.json()).slice(0, 10)\n  console.log(data)\n  return <ul>\n    {data.map(({ title, id }) => {\n      return <li key={id}>{title}</li>\n    })}\n  </ul>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时浏览器会报错："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"报错提示我们此时需要使用客户端组件。那么又该如何使用客户端组件呢？"}),"\n",(0,t.jsxs)(n.h2,{id:"客户端组件",children:["客户端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#客户端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-介绍-1",children:["1. 介绍",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-介绍-1",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["使用客户端组件，你需要在文件顶部添加一个 ",(0,t.jsx)(n.code,{children:'"use client"'})," 声明，修改 ",(0,t.jsx)(n.code,{children:"app/todo/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nimport { useEffect, useState } from 'react';\n\nfunction getRandomInt(min, max) {\n  const minCeiled = Math.ceil(min);\n  const maxFloored = Math.floor(max);\n  return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);\n}\n\nexport default function Page() {\n\n  const [list, setList] = useState([]);\n\n  const fetchData = async () => {\n    const res = await fetch('https://jsonplaceholder.typicode.com/todos')\n    const data = (await res.json()).slice(0, getRandomInt(1, 10))\n    setList(data)\n  }\n\n  useEffect(() => {\n    fetchData()\n  }, [])\n\n  return (\n    <>\n      <ul>\n        {list.map(({ title, id }) => {\n          return <li key={id}>{title}</li>\n        })}\n      </ul>\n      <button onClick={() => {\n        location.reload()\n      }}>换一批</button>\n    </>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"在这个例子中，我们使用了 useEffect、useState 等 React API，也给按钮添加了点击事件、使用了浏览器的 API。无论使用哪个都需要先声明为客户端组件。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["注意：",(0,t.jsx)(n.code,{children:'"use client"'}),"用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 ",(0,t.jsx)(n.code,{children:'"use client"'}),"，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。"]})}),"\n",(0,t.jsxs)(n.h3,{id:"2-优势-1",children:["2. 优势",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-优势-1",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"交互性：客户端组件可以使用 state、effects 和事件监听器，意味着用户可以与之交互"}),"\n",(0,t.jsx)(n.li,{children:"浏览器 API：客户端组件可以使用浏览器 API 如地理位置、localStorage 等"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"服务端组件-vs-客户端组件",children:["服务端组件 VS 客户端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端组件-vs-客户端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-如何选择使用",children:["1. 如何选择使用？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-如何选择使用",children:"#"})]}),"\n",(0,t.jsxs)(n.table,{children:["\n",(0,t.jsxs)(n.thead,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.th,{children:"如果你需要……"}),"\n",(0,t.jsx)(n.th,{children:"服务端组件"}),"\n",(0,t.jsx)(n.th,{children:"客户端组件"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.tbody,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"获取数据"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"访问后端资源（直接）"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"在服务端上保留敏感信息（访问令牌、API 密钥等）"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"在服务端使用依赖包，从而减少客户端 JavaScript 大小"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"添加交互和事件侦听器（onClick(), onChange() 等）"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"使用状态和生命周期（useState(), useReducer(), useEffect()等）"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"使用仅限浏览器的 API"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"使用依赖于状态、效果或仅限浏览器的 API 的自定义 hook"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"使用 React 类组件"}),"\n",(0,t.jsx)(n.td,{children:"❌"}),"\n",(0,t.jsx)(n.td,{children:"✅"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-渲染环境",children:["2. 渲染环境",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-渲染环境",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"服务端组件只会在服务端渲染，但客户端组件会在服务端渲染一次，然后在客户端渲染。"})}),"\n",(0,t.jsxs)(n.p,{children:["这是什么意思呢？让我们写个例子，新建 ",(0,t.jsx)(n.code,{children:"app/client/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nimport { useState } from 'react';\n\nconsole.log('client')\n\nexport default function Page() {\n\n  console.log('client Page')\n\n  const [text, setText] = useState('init text');\n\n  return (\n    <button onClick={() => {\n      setText('change text')\n    }}>{text}</button>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"console.log('server')\n\nexport default function Page() {\n\n  console.log('server Page')\n\n  return (\n    <button>button</button>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["现在运行 ",(0,t.jsx)(n.code,{children:"npm run build"}),"，会打印哪些数据呢？"]}),"\n",(0,t.jsx)(n.p,{children:"答案是无论客户端组件还是服务端组件，都会打印："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"截屏2024-03-05 21.46.46.png"})}),"\n",(0,t.jsxs)(n.p,{children:["而且根据输出的结果，无论是 ",(0,t.jsx)(n.code,{children:"/client"}),"还是 ",(0,t.jsx)(n.code,{children:"/server"}),"走的都是静态渲染。"]}),"\n",(0,t.jsxs)(n.p,{children:["当运行 ",(0,t.jsx)(n.code,{children:"npm run start"}),"的时候，又会打印哪些数据呢？"]}),"\n",(0,t.jsxs)(n.p,{children:["答案是命令行中并不会有输出，访问 ",(0,t.jsx)(n.code,{children:"/client"}),"的时候，浏览器会有打印："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["访问 ",(0,t.jsx)(n.code,{children:"/server"}),"的时候，浏览器不会有任何打印："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["客户端组件在浏览器中打印，这可以理解，毕竟它是客户端组件，当然要在客户端运行。可是客户端组件为什么在编译的时候会运行一次呢？让我们看下 ",(0,t.jsx)(n.code,{children:"/client"})," 的返回："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"截屏2024-03-05 22.00.58.png"})}),"\n",(0,t.jsxs)(n.p,{children:["你会发现 ",(0,t.jsx)(n.code,{children:"init text"}),"其实是来自于 useState 中的值，但是却依然输出在 HTML 中。这就是编译客户端组件的作用，为了第一次加载的时候能更快的展示出内容。"]}),"\n",(0,t.jsx)(n.p,{children:"所以其实所谓服务端组件、客户端组件并不直接对应于物理上的服务器和客户端。服务端组件运行在构建时和服务端，客户端组件运行在构建时、服务端（生成初始 HTML）和客户端（管理 DOM）。"}),"\n",(0,t.jsxs)(n.h3,{id:"3-交替使用服务端组件和客户端组件",children:["3. 交替使用服务端组件和客户端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-交替使用服务端组件和客户端组件",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"实际开发的时候，不可能纯用服务端组件或者客户端组件，当交替使用的时候，一定要注意一点，那就是："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"服务端组件可以直接导入客户端组件，但客户端组件并不能导入服务端组件"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \n// 这是不可以的\nimport ServerComponent from './Server-Component'\n \nexport default function ClientComponent({ children }) {\n  const [count, setCount] = useState(0)\n \n  return (\n    <>\n      <button onClick={() => setCount(count + 1)}>{count}</button>\n \n      <ServerComponent />\n    </>\n  )\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"但同时正如介绍客户端组件时所说："}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:'"use client"用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 "use client"，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"组件默认是服务端组件，但当组件导入到客户端组件中会被认为是客户端组件。客户端组件不能导入服务端组件，其实是在告诉你，如果你在服务端组件中使用了诸如 Node API 等，该组件可千万不要导入到客户端组件中。"}),"\n",(0,t.jsx)(n.p,{children:"但你可以将服务端组件以 props 的形式传给客户端组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport { useState } from 'react'\n \nexport default function ClientComponent({ children }) {\n  const [count, setCount] = useState(0)\n \n  return (\n    <>\n      <button onClick={() => setCount(count + 1)}>{count}</button>\n      {children}\n    </>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import ClientComponent from './client-component'\nimport ServerComponent from './server-component'\n \nexport default function Page() {\n  return (\n    <ClientComponent>\n      <ServerComponent />\n    </ClientComponent>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["使用这种方式，",(0,t.jsx)(n.code,{children:"<ClientComponent>"})," 和 ",(0,t.jsx)(n.code,{children:"<ServerComponent>"})," 代码解耦且独立渲染。"]}),"\n",(0,t.jsxs)(n.p,{children:["注：你可能会想为什么要这么麻烦的非要使用 ServerComponent 呢？这是因为 ServerComponent 有很多好处比如代码不会打包到 bundle 中。而为什么以 props 的形式就可以传递呢？在 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309111974141362202",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | 笔记搜索》"}),"中，我们会结合实战项目更具体的讲解。"]}),"\n",(0,t.jsxs)(n.h3,{id:"4-组件渲染原理",children:["4. 组件渲染原理",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-组件渲染原理",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在服务端："}),"\n",(0,t.jsx)(n.p,{children:"Next.js 使用 React API 编排渲染，渲染工作会根据路由和 Suspense 拆分成多个块（chunks），每个块分两步进行渲染："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["React 将服务端组件渲染成一个特殊的数据格式称为 ",(0,t.jsx)(n.strong,{children:"React Server Component Payload (RSC Payload)"})]}),"\n",(0,t.jsx)(n.li,{children:"Next.js 使用 RSC Payload 和客户端组件代码在服务端渲染 HTML"}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"RSC payload 中包含如下这些信息："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"服务端组件的渲染结果"}),"\n",(0,t.jsx)(n.li,{children:"客户端组件占位符和引用文件"}),"\n",(0,t.jsx)(n.li,{children:"从服务端组件传给客户端组件的数据"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"在客户端："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"加载渲染的 HTML 快速展示一个非交互界面（Non-interactive UI）"}),"\n",(0,t.jsx)(n.li,{children:"RSC Payload 会被用于协调（reconcile）客户端和服务端组件树，并更新 DOM"}),"\n",(0,t.jsx)(n.li,{children:"JavaScript 代码被用于水合客户端组件，使应用程序具有交互性（Interactive UI）"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"注意：上图描述的是页面初始加载的过程。其中 SC 表示 Server Components 服务端组件，CC 表示 Client Components 客户端组件。"}),"\n",(0,t.jsxs)(n.p,{children:["我们在上节",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7342436717142409242#heading-8",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | Suspense 与 Streaming》"}),"讲到 Suspense 和 Streaming 也有一些问题没有解决，比如该加载的 JavaScript 代码没有少、所有组件都必须水合，即使组件不需要水合。"]}),"\n",(0,t.jsx)(n.p,{children:"使用服务端组件和客户端组件就可以解决这个问题，服务端组件的代码不会打包到客户端 bundle 中。渲染的时候，只有客户端组件需要进行水合，服务端组件无须水合。"}),"\n",(0,t.jsx)(n.p,{children:"而在后续导航的时候："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"客户端组件完全在客户端进行渲染"}),"\n",(0,t.jsx)(n.li,{children:"React 使用 RSC Payload 来协调客户端和服务端组件树，并更新 DOM"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["线上查看代码和效果：",(0,t.jsx)(n.a,{href:"https://codesandbox.io/p/devbox/team-pm7qsz?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltfm0thd00073b6ihtzhdp7h%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltfm0thd00023b6iy9zjtjt7%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltfm0thd00043b6iv1i7b4xt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltfm0thd00063b6iygu09302%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltfm0thd00023b6iy9zjtjt7%2522%253A%257B%2522id%2522%253A%2522cltfm0thd00023b6iy9zjtjt7%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltfm0thd00063b6iygu09302%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltfm0thd00053b6i9mstj5l7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fteam%2522%257D%255D%252C%2522id%2522%253A%2522cltfm0thd00063b6iygu09302%2522%252C%2522activeTabId%2522%253A%2522cltfm0thd00053b6i9mstj5l7%2522%257D%252C%2522cltfm0thd00043b6iv1i7b4xt%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltfm0thd00033b6ii38rpxll%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522cltfm0thd00043b6iv1i7b4xt%2522%252C%2522activeTabId%2522%253A%2522cltfm0thd00033b6ii38rpxll%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D",target:"_blank",rel:"noopener noreferrer",children:"CodeSandbox Server Components And Client Components"})]}),"\n",(0,t.jsxs)(n.h2,{id:"最佳实践使用服务端组件",children:["最佳实践：使用服务端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践使用服务端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-共享数据",children:["1. 共享数据",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-共享数据",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"当在服务端获取数据的时候，有可能出现多个组件共用一个数据的情况。"}),"\n",(0,t.jsx)(n.p,{children:"面对这种情况，你不需要使用 React Context（当然服务端也用不了），也不需要通过 props 传递数据，直接在需要的组件中请求数据即可。这是因为 React 拓展了 fetch 的功能，添加了记忆缓存功能，相同的请求和参数，返回的数据会做缓存。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async function getItem() {\n  const res = await fetch('https://.../item/1')\n  return res.json()\n}\n \n// 函数被调用了两次，但只有第一次才执行\nconst item = await getItem() // cache MISS\n \n// 第二次使用了缓存\nconst item = await getItem() // cache HIT\n"})}),"\n",(0,t.jsx)(n.p,{children:"当然这个缓存也是有一定条件限制的，比如只能在 GET 请求中，具体的限制和原理我们会在缓存篇中具体讲解。"}),"\n",(0,t.jsxs)(n.h3,{id:"2-组件只在服务端使用",children:["2. 组件只在服务端使用",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-组件只在服务端使用",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"由于 JavaScript 模块可以在服务器和客户端组件模块之间共享，所以如果你希望一个模块只用于服务端，就比如这段代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n \n  return res.json()\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这个函数使用了 API_KEY，所以它应该是只用在服务端的。如果用在客户端，为了防止泄露，Next.js 会将私有环境变量替换为空字符串，所以这段代码可以在客户端导入并执行，但并不会如期运行。"}),"\n",(0,t.jsxs)(n.p,{children:["为了防止客户端意外使用服务器代码，我们可以借助 ",(0,t.jsx)(n.code,{children:"server-only"}),"包，这样在客户端意外使用的时候，会抛出构建错误。"]}),"\n",(0,t.jsxs)(n.p,{children:["使用 ",(0,t.jsx)(n.code,{children:"server-only"}),"，首先安装该包："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install server-only\n"})}),"\n",(0,t.jsx)(n.p,{children:"其次将该包导入只用在服务端的组件代码中："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import 'server-only'\n \nexport async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n \n  return res.json()\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["现在，任何导入 ",(0,t.jsx)(n.code,{children:"getData"}),"的客户端组件都会在构建的时候抛出错误，以保证该模块只能在服务端使用。"]}),"\n",(0,t.jsxs)(n.h3,{id:"3-使用三方包",children:["3. 使用三方包",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-使用三方包",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"毕竟 React Server Component 是一个新特性， React 生态里的很多包可能还没有跟上，这样就可能会导致一些问题。"}),"\n",(0,t.jsxs)(n.p,{children:["比如你使用了一个导出 ",(0,t.jsx)(n.code,{children:"<Carousel />"}),"组件的 ",(0,t.jsx)(n.code,{children:"acme-carousel"}),"包。这个组件使用了 useState，但是它并没有 ",(0,t.jsx)(n.code,{children:'"use client"'})," 声明。"]}),"\n",(0,t.jsx)(n.p,{children:"当你在客户端组件中使用的时候，它能正常工作："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport { useState } from 'react'\nimport { Carousel } from 'acme-carousel'\n \nexport default function Gallery() {\n  let [isOpen, setIsOpen] = useState(false)\n \n  return (\n    <div>\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\n \n      {/* Works, since Carousel is used within a Client Component */}\n      {isOpen && <Carousel />}\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"然而如果你在服务端组件中使用，它会报错："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Carousel } from 'acme-carousel'\n \nexport default function Page() {\n  return (\n    <div>\n      <p>View pictures</p>\n \n      {/* Error: `useState` can not be used within Server Components */}\n      <Carousel />\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这是因为 Next.js 并不知道 ",(0,t.jsx)(n.code,{children:"<Carousel />"}),"是一个只能用在客户端的组件，毕竟它是三方的，你也无法修改它的代码，为它添加 ",(0,t.jsx)(n.code,{children:'"use client"'})," 声明，Next.js 于是就按照服务端组件进行处理，结果它使用了客户端组件的特性 ",(0,t.jsx)(n.code,{children:"useState"}),"，于是便有了报错。"]}),"\n",(0,t.jsx)(n.p,{children:"为了解决这个问题，你可以自己包一层，将该三方组件包在自己的客户端组件中，比如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport { Carousel } from 'acme-carousel'\n \nexport default Carousel\n"})}),"\n",(0,t.jsxs)(n.p,{children:["现在，你就可以在服务端组件中使用 ",(0,t.jsx)(n.code,{children:"<Carousel />"}),"了："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import Carousel from './carousel'\n \nexport default function Page() {\n  return (\n    <div>\n      <p>View pictures</p>\n      <Carousel />\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["注：有的时候改为使用客户端组件也不能解决问题，如果遇到 document is not defined、window is not defined 这种报错，可以参考 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/post/7352342892785352755",target:"_blank",rel:"noopener noreferrer",children:"《Next.js v14 报 document is not defined 这种错怎么办？》"})," 解决"]}),"\n",(0,t.jsxs)(n.h3,{id:"4-使用-context-provider",children:["4. 使用 Context Provider",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-使用-context-provider",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上下文是一个典型的用于节点的特性，主要是为了共享一些全局状态，就比如当前的主题（实现换肤功能）。但服务端组件不支持 React context，如果你直接创建会报错："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { createContext } from 'react'\n \n//  服务端组件并不支持 createContext\nexport const ThemeContext = createContext({})\n \nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n      </body>\n    </html>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"为了解决这个问题，你需要在客户端组件中进行创建和渲染："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport { createContext } from 'react'\n \nexport const ThemeContext = createContext({})\n \nexport default function ThemeProvider({ children }) {\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后再在根节点使用："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import ThemeProvider from './theme-provider'\n \nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        <ThemeProvider>{children}</ThemeProvider>\n      </body>\n    </html>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样应用里的其他客户端组件就可以使用这个上下文。"}),"\n",(0,t.jsxs)(n.h2,{id:"最佳实践使用客户端组件",children:["最佳实践：使用客户端组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践使用客户端组件",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-客户端组件尽可能下移",children:["1. 客户端组件尽可能下移",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-客户端组件尽可能下移",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"为了尽可能减少客户端 JavaScript 包的大小，尽可能将客户端组件在组件树中下移。"}),"\n",(0,t.jsxs)(n.p,{children:["举个例子，当你有一个包含一些静态元素和一个交互式的使用状态的搜索栏的布局，没有必要让整个布局都成为客户端组件，将交互的逻辑部分抽离成一个客户端组件（比如",(0,t.jsx)(n.code,{children:"<SearchBar />"}),"），让布局成为一个服务端组件："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// SearchBar 客户端组件\nimport SearchBar from './searchbar'\n// Logo 服务端组件\nimport Logo from './logo'\n \n// Layout 依然作为服务端组件\nexport default function Layout({ children }) {\n  return (\n    <>\n      <nav>\n        <Logo />\n        <SearchBar />\n      </nav>\n      <main>{children}</main>\n    </>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["注：这点我们还会在实战篇的第一个项目",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309114608562733107#heading-5",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | 侧边栏笔记列表》"}),"讲解演示。"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-从服务端组件到客户端组件传递的数据需要序列化",children:["2. 从服务端组件到客户端组件传递的数据需要序列化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-从服务端组件到客户端组件传递的数据需要序列化",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"当你在服务端组件中获取的数据，需要以 props 的形式向下传给客户端组件，这个数据需要做序列化。"}),"\n",(0,t.jsx)(n.p,{children:"这是因为 React 需要先在服务端将组件树先序列化传给客户端，再在客户端反序列化构建出组件树。如果你传递了不能序列化的数据，这就会导致错误。"}),"\n",(0,t.jsx)(n.p,{children:"如果你不能序列化，那就改为在客户端使用三方包获取数据吧。"}),"\n",(0,t.jsxs)(n.p,{children:["注：这点我们还会在实战篇的第一个项目",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309114608562733107#heading-2",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | 侧边栏笔记列表》"}),"讲解演示。"]}),"\n",(0,t.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html",target:"_blank",rel:"noopener noreferrer",children:"Introducing Zero-Bundle-Size React Server Components – React Blog"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.plasmic.app/blog/how-react-server-components-work",target:"_blank",rel:"noopener noreferrer",children:"How React server components work: an in-depth guide"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/rendering/server-components",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Server Components"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/rendering/client-components",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Client Components"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Composition Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/reactwg/server-components/discussions/4",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/reactwg/server-components/discussions/4"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://news.ycombinator.com/item?id=25499171",target:"_blank",rel:"noopener noreferrer",children:"https://news.ycombinator.com/item?id=25499171"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a",target:"_blank",rel:"noopener noreferrer",children:"https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://twitter.com/dan_abramov/status/1342264337478660096",target:"_blank",rel:"noopener noreferrer",children:"https://twitter.com/dan_abramov/status/1342264337478660096"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering",target:"_blank",rel:"noopener noreferrer",children:"https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering"})}),"\n"]})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}let u=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F11.%E6%B8%B2%E6%9F%93%E7%AF%87%20_%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%84%E4%BB%B6.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"服务端组件",id:"服务端组件",depth:2},{text:"1. 介绍",id:"1-介绍",depth:3},{text:"2. 优势",id:"2-优势",depth:3},{text:"3. 限制",id:"3-限制",depth:3},{text:"客户端组件",id:"客户端组件",depth:2},{text:"1. 介绍",id:"1-介绍-1",depth:3},{text:"2. 优势",id:"2-优势-1",depth:3},{text:"服务端组件 VS 客户端组件",id:"服务端组件-vs-客户端组件",depth:2},{text:"1. 如何选择使用？",id:"1-如何选择使用",depth:3},{text:"2. 渲染环境",id:"2-渲染环境",depth:3},{text:"3. 交替使用服务端组件和客户端组件",id:"3-交替使用服务端组件和客户端组件",depth:3},{text:"4. 组件渲染原理",id:"4-组件渲染原理",depth:3},{text:"最佳实践：使用服务端组件",id:"最佳实践使用服务端组件",depth:2},{text:"1. 共享数据",id:"1-共享数据",depth:3},{text:"2. 组件只在服务端使用",id:"2-组件只在服务端使用",depth:3},{text:"3. 使用三方包",id:"3-使用三方包",depth:3},{text:"4. 使用 Context Provider",id:"4-使用-context-provider",depth:3},{text:"最佳实践：使用客户端组件",id:"最佳实践使用客户端组件",depth:2},{text:"1. 客户端组件尽可能下移",id:"1-客户端组件尽可能下移",depth:3},{text:"2. 从服务端组件到客户端组件传递的数据需要序列化",id:"2-从服务端组件到客户端组件传递的数据需要序列化",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"11.渲染篇 _ 服务端组件和客户端组件",headingTitle:"11.渲染篇 _ 服务端组件和客户端组件",frontmatter:{}}}}]);