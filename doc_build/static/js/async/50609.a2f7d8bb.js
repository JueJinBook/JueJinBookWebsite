"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50609"],{535090:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(552676),a=r(740453);let t=r.p+"static/image/1-3.8a70d165.png",c=r.p+"static/image/1-2.3fc961fd.png",o=r.p+"static/image/1-1.8742260f.png";function i(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",p:"p",img:"img",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsxs)(n.h1,{id:"1源码挖掘-webpack-中用到-node-的-10-个核心基础能力",children:["1源码挖掘： Webpack 中用到 Node 的 10 个核心基础能力",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1源码挖掘-webpack-中用到-node-的-10-个核心基础能力",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png | left | 747x353"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack v4.23.1"}),"，可以把 JS 文件中依赖的各种资源，分门别类的摘立出来，根据一定的配置规则，该编译编译，该合并合并，该压缩压缩，最终生成干干净净的静态资源文件，那么如此强大的 Webpack，又是站在 Node 的生态和能力之上，一定用到了 Node 的诸多能力，结合小册子，这里面我们可以看看它有用到哪些基础但核心的知识呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["首先我们安装一个命令到本地： ",(0,s.jsx)(n.code,{children:"npm i countapi -g"}),"，然后在 webpack 的目录下执行：",(0,s.jsx)(n.code,{children:"countapi ./"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"➜  countapi ./\nNode API Used Times\n┌────────────────┬───────┐\n│ module         │ count │\n├────────────────┼───────┤\n│ path           │ 134   │\n├────────────────┼───────┤\n│ fs             │ 121   │\n├────────────────┼───────┤\n│ util           │ 16    │\n├────────────────┼───────┤\n│ os             │ 8     │\n├────────────────┼───────┤\n│ vm             │ 8     │\n├────────────────┼───────┤\n│ child_process  │ 7     │\n├────────────────┼───────┤\n│ crypto         │ 5     │\n├────────────────┼───────┤\n│ assert         │ 5     │\n├────────────────┼───────┤\n│ events         │ 5     │\n├────────────────┼───────┤\n│ stream         │ 3     │\n├────────────────┼───────┤\n│ url            │ 2     │\n├────────────────┼───────┤\n│ zlib           │ 2     │\n├────────────────┼───────┤\n│ http           │ 2     │\n├────────────────┼───────┤\n│ https          │ 2     │\n├────────────────┼───────┤\n│ http           │ 2     │\n├────────────────┼───────┤\n│ readline       │ 1     │\n├────────────────┼───────┤\n│ dns            │ 1     │\n├────────────────┼───────┤\n│ inspector      │ 1     │\n├────────────────┼───────┤\n│ cluster        │ 1     │\n├────────────────┼───────┤\n│ net            │ 0     │\n├────────────────┼───────┤\n│ v8             │ 0     │\n├────────────────┼───────┤\n│ net            │ 0     │\n├────────────────┼───────┤\n│ http2          │ 0     │\n├────────────────┼───────┤\n│ repl           │ 0     │\n├────────────────┼───────┤\n│ perf_hooks     │ 0     │\n├────────────────┼───────┤\n│ dgram          │ 0     │\n├────────────────┼───────┤\n│ string_decoder │ 0     │\n├────────────────┼───────┤\n│ querystring    │ 0     │\n├────────────────┼───────┤\n│ worker_threads │ 0     │\n├────────────────┼───────┤\n│ async_hooks    │ 0     │\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里打印了 webpack 仓库源码中，用到的 Node 的一些核心 API 的引用次数，排名靠前的是需要我们关注的，但像断言 （assert） 我们当下并不关注，在本册中，我们会结合 webpack 的源码，会选择性的学习 Node 里面较为基础和常用的 API 知识点。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-javascript-语言基础",children:["1. Javascript 语言基础",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-javascript-语言基础",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"作为 Javascript 社区和 Node 社区的成果，毫无疑问，对于 Node 所支持的 Javascript 语法特性的使用，是搭建 Webpack 最核心的语言基础，那么我们需要关注的第一个核心知识就是：在 Node 里面对于 Javascript(ECMA) 的支持程度以及它主要语法特性的使用，在 Webpack 里面，Promise/Class/Arrow Function/Set/Symbol 等等这些现代的 JS 语法特性也是大规模的使用。"}),"\n",(0,s.jsx)(n.p,{children:"Webpack 有着庞大的开发者阵营和用户阵营，意味着他们无论是参与 Node 社区的建设，还是基于 Node 做工具栈技术栈拓展，Javascript 都是逃不掉的必备技能，Webpack 主仓库 6 万行的 JS 代码也说明了这一点。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png | left | 747x355"})}),"\n",(0,s.jsxs)(n.h2,{id:"2-node-的模块commonjs-规范",children:["2. Node 的模块/CommonJS 规范",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-node-的模块commonjs-规范",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们掌握了 Javascript 的主要语法知识，还不能在 Node 里面施展拳脚，像 Webpack 里面有 2000 多个 JS 文件，这样的数量级即便再缩小 10 倍，若没有一个机制来管理彼此错综复杂的关系，这个项目依然是梦魇一般的存在。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Compiler = require('./Compiler')\nconst MultiCompiler = require('./MultiCompiler')\nconst NodeEnvironmentPlugin = require('./node/NodeEnvironmentPlugin')\nconst WebpackOptionsApply = require('./WebpackOptionsApply')\nconst WebpackOptionsDefaulter = require('./WebpackOptionsDefaulter')\nconst validateSchema = require('./validateSchema')\nconst WebpackOptionsValidationError = require('./WebpackOptionsValidationError')\nconst webpackOptionsSchema = require('../schemas/WebpackOptions.json')\nconst RemovedPluginError = require('./RemovedPluginError')\n"})}),"\n",(0,s.jsx)(n.p,{children:"幸运的是 Node 面世那一年是 2009 年，Javascript 社区中也发展出了 CommonJS 规范，而使用了该规范的 Node 在社区大受欢迎，自此服务端 JS 的模块规范与浏览器端的模块规范走向了不同的道路。"}),"\n",(0,s.jsx)(n.p,{children:"简而言之，在 Node 里面写 JS 代码，CommonJS 的模块包关系如何组织是我们需要掌握的第二个核心知识。"}),"\n",(0,s.jsxs)(n.h2,{id:"3-node-的生态能力---npm",children:["3. Node 的生态能力 - NPM",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-node-的生态能力---npm",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除了在项目中彼此依赖的模块，Webpack 的主仓库包括它的实际配置场景中，还依赖许许多多的三方 Plugins 和 Loaders，这些三方的模块也会有他们自己的依赖，所有这些依赖会形成一颗深度嵌套的依赖树，源码都分布在 NPM Registry 上面，需要把他们都下载到本地才能使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"dependencies": {\n  "@webassemblyjs/ast": "1.7.8",\n  "@webassemblyjs/helper-module-context": "1.7.8",\n  "@webassemblyjs/wasm-edit": "1.7.8",\n  "@webassemblyjs/wasm-parser": "1.7.8",\n  "acorn": "^5.6.2",\n  "acorn-dynamic-import": "^3.0.0",\n  "ajv": "^6.1.0",\n  "ajv-keywords": "^3.1.0",\n  "chrome-trace-event": "^1.0.0",\n  "memory-fs": "~0.4.1",\n  "mkdirp": "~0.5.0",\n  "neo-async": "^2.5.0",\n  "uglifyjs-webpack-plugin": "^1.2.4",\n  "watchpack": "^1.5.0",\n  "webpack-sources": "^1.3.0"\n  ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这时候就需要用到 Node 包管理工具 - ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer",children:"NPM"})," 下载指定模块到当前项目中放到 node_modules 目录下配置使用，那么 NPM 对于 Node 到底是怎么样的一个存在呢，这又是我们学习 Node 必须熟练掌握的技能。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-node-的工具集---pathurlutilzlib",children:["4. Node 的工具集 - path/url/util/zlib",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-node-的工具集---pathurlutilzlib",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们扒开 Webpack 的源码库，如果把它的依赖也通过 npm install 后，在这些 node_modules 里面，随便点开一些代码，就能发现满屏的 util 和 path 的使用，比如:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'/webpack-master/lib/Compiler.js:\n336  if (targetFile.match(/\\/|\\\\/)) {\n337:   const dir = path.dirname(targetFile)\n\n/webpack-master/lib/ContextModuleFactory.js:\n191  files.filter(p => p.indexOf(".") !== 0),\n192  (segment, callback) => {\n193:   const subResource = path.join(directory, segment)\n\n/webpack-master/lib/ContextReplacementPlugin.js:\n84   if (resourceRegExp.test(result.resource)) {\n85     if (newContentResource !== undefined) {\n86:      result.resource = path.resolve(result.resource, newContentResource)\n87     }\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"201  function getFullPath(id, normalize) {\n202    if (normalize !== false) id = normalizeId(id)\n203    var p = url.parse(id, false, true)\n...\n220  function resolveUrl(baseId, id) {\n221    id = normalizeId(id)\n222:   return url.resolve(baseId, id)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'/Users/black/Downloads/webpack-master/lib/Chunk.js:\n755  Object.defineProperty(Chunk.prototype, "forEachModule", {\n756   configurable: false,\n757:  value: util.deprecate(\n758     /**\n759      * @deprecated\n'})}),"\n",(0,s.jsx)(n.p,{children:"这些常用的工具套件就像 Node 的贴心小助手，从琐碎杂烦的任务中解脱出来，无论是模块的代码结构，还是功能实现的便携程度，都有很大的提升，那么这些工具件方法也是我们需要掌握的，也是使用频次比较高的 API。"}),"\n",(0,s.jsxs)(n.h2,{id:"5-node-的文件操作能力---fs",children:["5. Node 的文件操作能力 - fs",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-node-的文件操作能力---fs",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["无论多么松散耦合的 JS 代码，Webpack 都能把它里面不同类型的文件抽离出来，最终经过一系列处理放到某个目标目录下，在这个过程中，就用到了 Node 非常重要的一个能力，就是文件操作能力，比如把文件写入到某个位置，或者复制移动到某个位置，我们可以到 Webpack 的仓库，找到 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/webpack/blob/4d3fe000b5f173a186c918eb1a9b0486e0fc3f5c/lib/webpack.js#L11",target:"_blank",rel:"noopener noreferrer",children:"/lib/webpack 第 11 行"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const WebpackOptionsDefaulter = require("./WebpackOptionsDefaulter")\n'})}),"\n",(0,s.jsx)(n.p,{children:"这样一层层找下去，就能发现："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Webpack 配置文件的读取，就用到了 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/webpack/blob/4d3fe000b5f173a186c918eb1a9b0486e0fc3f5c/lib/WebpackOptionsDefaulter.js#L306",target:"_blank",rel:"noopener noreferrer",children:"/lib/WebpackOptionsDefaulter"})]}),"\n",(0,s.jsxs)(n.li,{children:["在 WebpackOptionsDefaulter.js 里面，编译压缩的代码这里依赖了三方模块 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/uglifyjs-webpack-plugin/blob/master/src/TaskRunner.js#L73",target:"_blank",rel:"noopener noreferrer",children:"uglifyjs-webpack-plugin"})]}),"\n",(0,s.jsxs)(n.li,{children:["在 uglify 插件中的 src/TaskRunner.js 里面，用到了 ",(0,s.jsx)(n.a,{href:"https://github.com/zkat/cacache/blob/latest/put.js",target:"_blank",rel:"noopener noreferrer",children:"cacache/put.js"}),"， ",(0,s.jsx)(n.a,{href:"https://github.com/zkat/cacache/blob/latest/get.js",target:"_blank",rel:"noopener noreferrer",children:"cacache/get.js"})]}),"\n",(0,s.jsxs)(n.li,{children:["在 ",(0,s.jsx)(n.a,{href:"https://github.com/zkat/cacache/blob/latest/put.js",target:"_blank",rel:"noopener noreferrer",children:"cacache/put.js"})," 里面又用到了 ",(0,s.jsx)(n.a,{href:"https://github.com/zkat/cacache/blob/latest/lib/content/write.js#L7",target:"_blank",rel:"noopener noreferrer",children:"lib/content/write.js"}),", 以及 ",(0,s.jsx)(n.a,{href:"https://github.com/isaacs/node-graceful-fs/blob/master/graceful-fs.js#L65",target:"_blank",rel:"noopener noreferrer",children:"graceful-fs"})]}),"\n",(0,s.jsx)(n.li,{children:"在 write.js 及 graceful-fs 里面，则是 fs 能力的各种封装了"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"我们来用一张依赖关系图来展示 Webpack 文件操作能力吧："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png | left | 747x460"})}),"\n",(0,s.jsx)(n.p,{children:"可以发现，Node 的 fs 能力作为底层，最终在 webpack 里面，作为插件来支持文件的生成，跨目录的复制转移等等这些骚操作。"}),"\n",(0,s.jsx)(n.p,{children:"文件的操作能力，也就是本地文件资源的交互与操作能力，在 Node 里面是我们需要掌握的又一个核心能力，包括 Path 路径这些周边 API 的配套使用。"}),"\n",(0,s.jsxs)(n.h2,{id:"6-node-的缓冲与流",children:["6. Node 的缓冲与流",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-node-的缓冲与流",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"日常使用 Webpack，我们动辄会有几分钟的构建等待时间，这里面有大量的文件读写操作，需要有比较好的机制来保证数据操作效率，基于上面第 5 点的 Webpack 文件操作能力，在源码中其实就能看到大量的 stream 读写的封装了，比如第 5 点的关系图，里面的 cacache 其实还用到了移动复制文件的模块 move-concurrently，而 move-concurrently 则依赖于 copy-concurrently/copy.js 实现拷贝文件的 Promise  API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.createReadStream(from)\n  .once('error', onError)\n  .pipe(writeStreamAtomic(to, writeOpts))\n  .once('error', onError)\n  .once('close', function () {\n    if (errored) return\n    if (opts.mode != null) {\n      resolve(chmod(to, opts.mode))\n    } else {\n      resolve()\n    }\n  })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这个 API 里面，就是基于 ",(0,s.jsx)(n.code,{children:"fs.createReadStream"})," 来对文件内容以流的方式来输送数据，既然提到 stream， Buffer 也就是缓冲也需要了解，那么到底 Node 里面，Stream 和 Buffer 是怎样一个存在，如何使用，这也是一个比较核心的能力等我们掌握。"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-node-的事件机制---eventemitter",children:["7. Node 的事件机制 - EventEmitter",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-node-的事件机制---eventemitter",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["基于上面第 6 点，我们处理流的过程中，有 once('error|close') 这样的错误或者流结束这样的事件监听，来挂载对应的回调函数，为什么流的中转过程可以捕获到这样的触发事件呢，我们可以去查看 Node 仓库的源码 - ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/master/lib/internal/streams/legacy.js#L9",target:"_blank",rel:"noopener noreferrer",children:"lib/internal/streams/legacy.js"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const EE = require('events')\nconst util = require('util')\n\nfunction Stream () {\n  EE.call(this)\n}\nutil.inherits(Stream, EE)\n\nStream.prototype.pipe = function(dest, options) {\n  // 伪代码\n  source.on('data', ondata)\n  source.on('end', onend)\n  source.on('close', onclose)\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  source.on('error', onerror)\n\n  dest.on('drain', ondrain)\n  dest.on('error', onerror)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n  return dest\n}\n\nmodule.exports = Stream\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到最底层的这个 Stream，是继承 events 也就是 EventEmitter，那么自然所有继承了 Stream 的模块，都拥有了 EventEmitter 的特性，可以订阅事件发布事件，为特定事件注册回调函数，甚至我们也可以基于 EventEmitter 来封装我们自己的模块，那么 EventEmitter 这个非常核心的模块到底如何使用呢，我们也会在小册子中进行探讨。"}),"\n",(0,s.jsxs)(n.h2,{id:"8--node-的-http-处理---请求与响应",children:["8.  Node 的 HTTP 处理 - 请求与响应",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8--node-的-http-处理---请求与响应",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"以上的基础能力，大多跟跟客户端/本地/系统资源处理有关，一个前端工程师，差不多理解和掌握这几个模块就够用了，但是要继续夯实整个 Node 的基础，为前端开发提供更多可能性，我们就不可避免的会摸到服务端这个领域，也就是 HTTP 的另外一头，服务器上的请求与响应。"}),"\n",(0,s.jsx)(n.p,{children:"而且我们用 webpack 在本地起 dev 环境开发的时候，经常需要用到 Server 来代理静态资源，包括做接口转发，Webpack 插件用到的是 Express，我们基本是插件配置好，就开箱即用，如果想要定制改造，那么不可避免的还是要理解 Node 里面的 HTTP 整套流程。"}),"\n",(0,s.jsx)(n.p,{children:"所以关于 Node 里面 HTTP 的部分，无论是作为服务端响应请求，还是作为请求的发起方，向第三方请求 API，甚至是爬取网页，都逃不开 HTTP 的网络通信能力，那么这个技能的掌握对于我们扩充服务端领域的知识很有意义。"}),"\n",(0,s.jsxs)(n.h2,{id:"9-node-的事件循环---event-loop",children:["9. Node 的事件循环 - Event Loop",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-node-的事件循环---event-loop",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Webpack 的整个打包构建流里面，有着很多在执行的任务，这些任务有的是异步的有的是同步的，比如 webpack-master/lib/Compilation.js 里面等待构建结束时候检查是否有回调队列，如果没有就会定义一个新的 callback 动作去执行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"waitForBuildingFinished(module, callback) {\n  let callbackList = this._buildingModules.get(module)\n  if (callbackList) {\n    callbackList.push(() => callback())\n  } else {\n    process.nextTick(callback)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"除了 Process.nextTick，还有 setImmediate/Promise 等等这些任务， 到底这些任务到底是按照怎样的规则或者顺序来依次执行呢，答案就是 Event Loop - 事件循环，这也 Node 所谓高性能高并发卖点背后的任务调度机制，任务在哪个时机执行，哪些任务会优先执行，当给我们要深入学习 Node 的时候，事件循环整套流程和特点，就是我们需要掌握的，它会让我们更了解代码的底层运行状况，也是面试中最常问到的一个问题。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const EventEmitter = require('events')\nclass EE extends EventEmitter {}\nconst yy = new EE()\n\nyy.on('event', () => console.log('粗大事啦'))\nsetTimeout(() => console.log('0 毫秒后到期的定时器回调'), 0)\nsetTimeout(() => console.log('100 毫秒后到期的定时器回调'), 100)\nsetImmediate(() => console.log('immediate 立即回调'))\nprocess.nextTick(() => console.log('process.nextTick 的回调'))\n\nPromise.resolve().then(() => {\n  yy.emit('event')\n  process.nextTick(() => console.log('process.nextTick 的回调'))\n  console.log('promise 第一次回调')\n})\n.then(() => console.log('promise 第二次回调'))\n\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"10-node-的进程集群---cluster",children:["10. Node 的进程集群 - Cluster",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-node-的进程集群---cluster",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"基于上面的 HTTP，我们只要摸到服务端，就需要对所谓单线程事件驱动的高并发 Node IO 模型，能从自己嘴中讲出个所以然来，也要了解它的优劣势，那么如果再放大下场景，我们来对 Node 服务进行横向扩展，让它可以支持更多的并发，更好的利用 CPU，应该怎么做呢？那么 cluster 就是 Node 给出的答案，在小侧子里面，我们也会来探讨下 cluster 在 Node 中的使用，以及有哪些更成熟的工具，比如 PM2 的配套使用。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们拿 Webpack 只是个举个例子而已，其他前端构建框架也都类似，总而言之，现在前端的整个工程工具体系都是站在了 Node 的生态之上，而抛开生态就是 Node 的单兵作战能力，我们不会为了学 Node 而学 Node，而是通过学习 Node 让自己能摸到更多的知识领域，能带来更多视角和边界的觉醒，同时能给自己带来更多竞争力的知识积累，这就可以作为我们早期学习 Node 的动力，那接下来我们就针对 Webpack 刨出来的这些技能知识点开始学习和练习吧。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F1%E6%BA%90%E7%A0%81%E6%8C%96%E6%8E%98%EF%BC%9A%20Webpack%20%E4%B8%AD%E7%94%A8%E5%88%B0%20Node%20%E7%9A%84%2010%20%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B.md"]={toc:[{text:"",id:"",depth:3},{text:"1. Javascript 语言基础",id:"1-javascript-语言基础",depth:2},{text:"2. Node 的模块/CommonJS 规范",id:"2-node-的模块commonjs-规范",depth:2},{text:"3. Node 的生态能力 - NPM",id:"3-node-的生态能力---npm",depth:2},{text:"4. Node 的工具集 - path/url/util/zlib",id:"4-node-的工具集---pathurlutilzlib",depth:2},{text:"5. Node 的文件操作能力 - fs",id:"5-node-的文件操作能力---fs",depth:2},{text:"6. Node 的缓冲与流",id:"6-node-的缓冲与流",depth:2},{text:"7. Node 的事件机制 - EventEmitter",id:"7-node-的事件机制---eventemitter",depth:2},{text:"8.  Node 的 HTTP 处理 - 请求与响应",id:"8--node-的-http-处理---请求与响应",depth:2},{text:"9. Node 的事件循环 - Event Loop",id:"9-node-的事件循环---event-loop",depth:2},{text:"10. Node 的进程集群 - Cluster",id:"10-node-的进程集群---cluster",depth:2},{text:"总结",id:"总结",depth:2}],title:"1源码挖掘： Webpack 中用到 Node 的 10 个核心基础能力",headingTitle:"1源码挖掘： Webpack 中用到 Node 的 10 个核心基础能力",frontmatter:{}}}}]);