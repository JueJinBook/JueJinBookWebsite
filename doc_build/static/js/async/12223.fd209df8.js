"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12223"],{713465:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var r=s(552676),l=s(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",code:"code",strong:"strong",pre:"pre"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"37源码-5凌波微步--探索跳跃列表内部",children:["37源码 5：凌波微步 —— 探索「跳跃列表」内部",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37源码-5凌波微步--探索跳跃列表内部",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Redis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃列表」。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/27/164d9cd9064b556e?w=338&h=152&f=png&s=9604",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"zset 的内部实现是一个 hash 字典加一个跳跃列表 (skiplist)。hash 结构在讲字典结构时已经详细分析过了，它很类似于 Java 语言中的 HashMap 结构。本节我们来讲跳跃列表，它比较复杂，读者要有心理准备。"}),"\n",(0,r.jsxs)(n.h2,{id:"基本结构",children:["基本结构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本结构",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/27/164d9f96ed4e1a0d?w=1457&h=273&f=png&s=24714",alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["上图就是跳跃列表的示意图，图中只画了四层，Redis 的跳跃表共有 64 层，容纳 2^64 个元素应该不成问题。每一个 kv 块对应的结构如下面的代码中的",(0,r.jsx)(n.code,{children:"zslnode"}),"结构，kv header 也是这个结构，只不过 value 字段是 null 值——无效的，score 是 Double.MIN_VALUE，用来垫底的。kv 之间使用指针串起来形成了双向链表结构，它们是 ",(0,r.jsx)(n.strong,{children:"有序"})," 排列的，从小到大。不同的 kv 层高可能不一样，层数越高的 kv 越少。同一层的 kv 会使用指针串起来。每一个层元素的遍历都是从 kv header 出发。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct zslnode {\n  string value;\n  double score;\n  zslnode*[] forwards;  // 多层连接指针\n  zslnode* backward;  // 回溯指针\n}\n\nstruct zsl {\n  zslnode* header; // 跳跃列表头指针\n  int maxLevel; // 跳跃列表当前的最高层\n  map<string, zslnode*> ht; // hash 结构的所有键值对\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"查找过程",children:["查找过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#查找过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"设想如果跳跃列表只有一层会怎样？插入删除操作需要定位到相应的位置节点 (定位到最后一个比「我」小的元素，也就是第一个比「我」大的元素的前一个)，定位的效率肯定比较差，复杂度将会是 O(n)，因为需要挨个遍历。也许你会想到二分查找，但是二分查找的结构只能是有序数组。跳跃列表有了多层结构之后，这个定位的算法复杂度将会降到 O(lg(n))。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/27/164dc52ae7e6444c?w=1912&h=662&f=png&s=119691",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如图所示，我们要定位到那个紫色的 kv，需要从 header 的最高层开始遍历找到第一个节点 (最后一个比「我」小的元素)，然后从这个节点开始降一层再遍历找到第二个节点 (最后一个比「我」小的元素)，然后一直降到最底层进行遍历就找到了期望的节点 (最底层的最后一个比我「小」的元素)。"}),"\n",(0,r.jsx)(n.p,{children:"我们将中间经过的一系列节点称之为「搜索路径」，它是从最高层一直到最底层的每一层最后一个比「我」小的元素节点列表。"}),"\n",(0,r.jsx)(n.p,{children:"有了这个搜索路径，我们就可以插入这个新节点了。不过这个插入过程也不是特别简单。因为新插入的节点到底有多少层，得有个算法来分配一下，跳跃列表使用的是随机算法。"}),"\n",(0,r.jsxs)(n.h2,{id:"随机层数",children:["随机层数",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#随机层数",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。直观上期望的目标是 50% 的 Level1，25% 的 Level2，12.5% 的 Level3，一直到最顶层",(0,r.jsx)(n.code,{children:"2^-63"}),"，因为这里每一层的晋升概率是 50%。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/* Returns a random level for the new skiplist node we are going to create.\n * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL\n * (both inclusive), with a powerlaw-alike distribution where higher\n * levels are less likely to be returned. */\nint zslRandomLevel(void) {\n    int level = 1;\n    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))\n        level += 1;\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"不过 Redis 标准源码中的晋升概率只有 25%，也就是代码中的 ZSKIPLIST_P 的值。所以官方的跳跃列表更加的扁平化，层高相对较低，在单个层上需要遍历的节点数量会稍多一点。"}),"\n",(0,r.jsxs)(n.p,{children:["也正是因为层数一般不高，所以遍历的时候从顶层开始往下遍历会非常浪费。跳跃列表会记录一下当前的最高层数",(0,r.jsx)(n.code,{children:"maxLevel"}),"，遍历时从这个 maxLevel 开始遍历性能就会提高很多。"]}),"\n",(0,r.jsxs)(n.h2,{id:"插入过程",children:["插入过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插入过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"下面是插入过程的源码，它稍微有点长，不过整体的过程还是比较清晰的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/* Insert a new node in the skiplist. Assumes the element does not already\n * exist (up to the caller to enforce that). The skiplist takes ownership\n * of the passed SDS string 'ele'. */\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    // 存储搜索路径\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    // 存储经过的节点跨度\n    unsigned int rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    serverAssert(!isnan(score));\n    x = zsl->header;\n    // 逐步降级寻找目标节点，得到「搜索路径」\n    for (i = zsl->level-1; i >= 0; i--) {\n        /* store rank that is crossed to reach the insert position */\n        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];\n        // 如果score相等，还需要比较value\n        while (x->level[i].forward &&\n                (x->level[i].forward->score < score ||\n                    (x->level[i].forward->score == score &&\n                    sdscmp(x->level[i].forward->ele,ele) < 0)))\n        {\n            rank[i] += x->level[i].span;\n            x = x->level[i].forward;\n        }\n        update[i] = x;\n    }\n    // 正式进入插入过程\n    /* we assume the element is not already inside, since we allow duplicated\n     * scores, reinserting the same element should never happen since the\n     * caller of zslInsert() should test in the hash table if the element is\n     * already inside or not. */\n    // 随机一个层数\n    level = zslRandomLevel();\n    // 填充跨度\n    if (level > zsl->level) {\n        for (i = zsl->level; i < level; i++) {\n            rank[i] = 0;\n            update[i] = zsl->header;\n            update[i]->level[i].span = zsl->length;\n        }\n        // 更新跳跃列表的层高\n        zsl->level = level;\n    }\n    // 创建新节点\n    x = zslCreateNode(level,score,ele);\n    // 重排一下前向指针\n    for (i = 0; i < level; i++) {\n        x->level[i].forward = update[i]->level[i].forward;\n        update[i]->level[i].forward = x;\n\n        /* update span covered by update[i] as x is inserted here */\n        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);\n        update[i]->level[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    /* increment span for untouched levels */\n    for (i = level; i < zsl->level; i++) {\n        update[i]->level[i].span++;\n    }\n    // 重排一下后向指针\n    x->backward = (update[0] == zsl->header) ? NULL : update[0];\n    if (x->level[0].forward)\n        x->level[0].forward->backward = x;\n    else\n        zsl->tail = x;\n    zsl->length++;\n    return x;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"首先我们在搜索合适插入点的过程中将「搜索路径」摸出来了，然后就可以开始创建新节点了，创建的时候需要给这个节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度。"}),"\n",(0,r.jsxs)(n.h2,{id:"删除过程",children:["删除过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#删除过程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["删除过程和插入过程类似，都需先把这个「搜索路径」找出来。然后对于每个层的相关节点都重排一下前向后向指针就可以了。同时还要注意更新一下最高层数",(0,r.jsx)(n.code,{children:"maxLevel"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"更新过程",children:["更新过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当我们调用 zadd 方法时，如果对应的 value 不存在，那就是插入过程。如果这个 value 已经存在了，只是调整一下 score 的值，那就需要走一个更新的流程。假设这个新的 score 值不会带来排序位置上的改变，那么就不需要调整位置，直接修改元素的 score 值就可以了。但是如果排序位置改变了，那就要调整位置。那该如何调整位置呢？"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/* Remove and re-insert when score changes. */\n    if (score != curscore) {\n        zskiplistNode *node;\n        serverAssert(zslDelete(zs->zsl,curscore,ele,&node));\n        znode = zslInsert(zs->zsl,score,node->ele);\n        /* We reused the node->ele SDS string, free the node now\n        * since zslInsert created a new one. */\n        node->ele = NULL;\n        zslFreeNode(node);\n        /* Note that we did not removed the original element from\n        * the hash table representing the sorted set, so we just\n        * update the score. */\n        dictGetVal(de) = &znode->score; /* Update score ptr. */\n        *flags |= ZADD_UPDATED;\n        }\n    return 1;\n"})}),"\n",(0,r.jsx)(n.p,{children:"一个简单的策略就是先删除这个元素，再插入这个元素，需要经过两次路径搜索。Redis 就是这么干的。\n不过 Redis 遇到 score 值改变了就直接删除再插入，不会去判断位置是否需要调整，从这点看，Redis 的 zadd 的代码似乎还有优化空间。关于这一点，读者们可以继续讨论。"}),"\n",(0,r.jsxs)(n.h2,{id:"如果-score-值都一样呢",children:["如果 score 值都一样呢？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如果-score-值都一样呢",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在一个极端的情况下，zset 中所有的 score 值都是一样的，zset 的查找性能会退化为 O(n) 么？Redis 作者自然考虑到了这一点，所以 zset 的排序元素不只看 score 值，如果 score 值相同还需要再比较 value 值 (字符串比较)。"}),"\n",(0,r.jsxs)(n.h2,{id:"元素排名是怎么算出来的",children:["元素排名是怎么算出来的？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#元素排名是怎么算出来的",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面我们啰嗦了一堆，但是有一个重要的属性没有提到，那就是 zset 可以获取元素的排名 rank。那这个 rank 是如何算出来的？如果仅仅使用上面的结构，rank 是不能算出来的。Redis 在 skiplist 的 forward 指针上进行了优化，给每一个 forward 指针都增加了 span 属性，span 是「跨度」的意思，表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点。Redis 在插入删除操作时会小心翼翼地更新 span 值的大小。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"struct zslforward {\n  zslnode* item;\n  long span;  // 跨度\n}\n\nstruct zsl {\n  String value;\n  double score;\n  zslforward*[] forwards;  // 多层连接指针\n  zslnode* backward;  // 回溯指针\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样当我们要计算一个元素的排名时，只需要将「搜索路径」上的经过的所有节点的跨度 span 值进行叠加就可以算出元素的最终 rank 值。"}),"\n",(0,r.jsxs)(n.h2,{id:"思考",children:["思考",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"文中我们提到当 score 值的变化微小，不会带来位置上的调整时，是不是可以直接修改 score 后就返回？"}),"\n",(0,r.jsx)(n.p,{children:"请读者们对这个问题进行讨论。如果确实如此，可以考虑向 Redis 作者 Antirez 提 issue 了。"}),"\n",(0,r.jsxs)(n.h2,{id:"后记",children:["后记",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#后记",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["老钱于 2018 年 7 月 28 日向 Redis 的 Github Repo 提交了这个小优化的建议 ",(0,r.jsx)(n.a,{href:"https://github.com/antirez/redis/issues/5179",target:"_blank",rel:"noopener noreferrer",children:"《maybe an optimizable point for zadd operation》"}),"，5 天后，Redis 作者 Antirez 接受了这个建议，对 skiplist 的代码做了小修改并 merge 到了 master。"]}),"\n",(0,r.jsx)(n.p,{children:"Antirez 向老钱表达了感谢，作为小学生的我表示很激动，他告诉我这个小优化在某些应用场景下可以为 zset 带来 10% 以上性能的提升。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/8/5/1650a1dac220f24b?w=1600&h=738&f=png&s=168891",alt:""})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F37%E6%BA%90%E7%A0%81%205%EF%BC%9A%E5%87%8C%E6%B3%A2%E5%BE%AE%E6%AD%A5%20%E2%80%94%E2%80%94%20%E6%8E%A2%E7%B4%A2%E3%80%8C%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8%E3%80%8D%E5%86%85%E9%83%A8.md"]={toc:[{text:"基本结构",id:"基本结构",depth:2},{text:"查找过程",id:"查找过程",depth:2},{text:"随机层数",id:"随机层数",depth:2},{text:"插入过程",id:"插入过程",depth:2},{text:"删除过程",id:"删除过程",depth:2},{text:"更新过程",id:"更新过程",depth:2},{text:"如果 score 值都一样呢？",id:"如果-score-值都一样呢",depth:2},{text:"元素排名是怎么算出来的？",id:"元素排名是怎么算出来的",depth:2},{text:"思考",id:"思考",depth:2},{text:"后记",id:"后记",depth:2}],title:"37源码 5：凌波微步 —— 探索「跳跃列表」内部",headingTitle:"37源码 5：凌波微步 —— 探索「跳跃列表」内部",frontmatter:{}}}}]);