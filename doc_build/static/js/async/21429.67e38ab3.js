"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21429"],{739867:function(n,r,e){e.r(r),e.d(r,{default:()=>a});var i=e(552676),d=e(740453);function l(n){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",code:"code",pre:"pre",blockquote:"blockquote",ul:"ul",li:"li"},(0,d.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"第16章结构体三继承代码中的父与子",children:["第16章—结构体三｜继承，代码中的“父”与“子”",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#第16章结构体三继承代码中的父与子",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"\uFEFF在上一讲中，我们结合两只柴犬的例子介绍了如何构建独一无二的对象，以及如何让对象“动起来”的方法。本讲我们继续深入结构体的讲解，也是结构体部分的最后一讲——使用结构体实现继承。"}),"\n",(0,i.jsx)(r.p,{children:"我们已经知道，构造函数和方法是面向对象语言所具备的能力，继承亦然。Go语言的语法设计非常灵活、简单和易用，仅依靠结构体，便可实现上述所有能力。"}),"\n",(0,i.jsxs)(r.h2,{id:"什么是继承",children:["什么是继承",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是继承",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"继承在实际开发中用途同样非常广泛，甚至在现实生活中也有很多类似的应用。"}),"\n",(0,i.jsx)(r.p,{children:"举例而言，在任何一家公司，都是由很多人组成的，不同的人有不同的职务，比如总经理、部门经理、职员等等。发现了吗？无论是总经理、部门经理还是职员，都是由人派生出来的，他们首先属于“人”，然后再属于某个职务。"}),"\n",(0,i.jsx)(r.p,{children:"如果把“人”和总经理等等具有具体职务的人都看作是结构体的话，“人”便是他们的“父结构体”，无论是何种职务的人，都由这个父结构体派生出来，具有父结构体所有的属性。然后根据职务不同，拥有独特性的属性。可以看作是“子结构体”。"}),"\n",(0,i.jsxs)(r.p,{children:["从另一个角度看，这些 ",(0,i.jsx)(r.strong,{children:"“子结构体”扩展了“父结构体”"})," 。作为“子结构体”，",(0,i.jsx)(r.strong,{children:"不仅可以使用“父结构体”的属性，还拥有自己的属性"}),"。如果说 ",(0,i.jsx)(r.strong,{children:"“父结构体”是概括的，抽象的，那么“子结构体”就是具体的，详细的"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:"具体来说，假如“人”结构体具有较为通用的姓名、年龄、性别三个属性，可以执行吃饭、睡觉、走路、奔跑四个动作。作为派生出的“总经理”还额外具有持股比例属性，可以额外执行安排工作任务的动作……"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.code,{children:"\uD83D\uDCA1 提示：发现了吗？这个例子中，作为“父结构体”的“人”并没有直接使用，仅用它派生出的“子结构体”就能描述整个公司的组织架构了。但这并不表明“父结构体”永远不会直接使用，具体还需要根据实际开发需求的不同而定。"})}),"\n",(0,i.jsxs)(r.p,{children:["从本质上说，",(0,i.jsx)(r.strong,{children:"Go语言中继承，是通过结构体的嵌套来实现的。"})]}),"\n",(0,i.jsx)(r.p,{children:"为了让各位更好地理解，接下来我将使用动物（Animal）作为父结构体，鸟（Bird）和狗（Dog）作为子结构体，来介绍如何使用结构体实现面向对象中的继承特性。"}),"\n",(0,i.jsxs)(r.h2,{id:"结构体的嵌套",children:["结构体的嵌套",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#结构体的嵌套",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"我们先来实现作为父结构体的动物（Animal），这个结构体具有名字（Name）、年龄（Age）和性别（Gender）属性。"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.code,{children:"\uD83D\uDCA1 提示：请留意这三个属性也是本例中所有子结构体所具有的。"})}),"\n",(0,i.jsx)(r.p,{children:"示例代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"type Animal struct {\r\n   Name   int\r\n   Age    int\r\n   Gender string\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"接下来，以子结构体鸟（Bird）为例，它还具有翅膀颜色的属性。因此，Bird的结构体定义示例如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"type Bird struct {\r\n   WingColor    string\r\n   CommonAnimal Animal\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"很明显地，Bird结构体中包含了一个名为CommonAnimal的Animal类型成员，而Animal类型就是我们刚刚定义好的结构体。如此，便完成了结构体的嵌套，即把Animal嵌入Bird中。从此，Bird也具有了Animal中的Name、Age和Gender属性了。"}),"\n",(0,i.jsx)(r.p,{children:"继续使用上一讲中“构造函数”的知识，创建Bird类型的构造函数："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func NewBird(name string, age int, gender string, wingColor string) *Bird {\r\n   return &Bird{\r\n      WingColor: wingColor,\r\n      CommonAnimal: Animal{\r\n         Name:   name,\r\n         Age:    age,\r\n         Gender: gender,\r\n      },\r\n   }\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"接着，鸟还有“飞行”的动作。使用上一讲中“方法”的知识，创建Bird类型的“飞行”方法："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'func (b *Bird) Fly() {\r\n   fmt.Println("我起飞啦！")\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"关于“鸟”的结构体定义、构造函数和方法的实现到此先告一段落。我们回到main()函数中使用它们。"}),"\n",(0,i.jsx)(r.p,{children:"在main()函数中，首先声明一个变量，名为bird，使用NewBird()构造函数为其赋值，然后再调用Fly()方法，让小鸟执行飞行动作。完整的代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'type Animal struct {\r\n   Name   string\r\n   Age    int\r\n   Gender string\r\n}\r\n\r\ntype Bird struct {\r\n   WingColor    string\r\n   CommonAnimal Animal\r\n}\r\n\r\nfunc NewBird(name string, age int, gender string, wingColor string) *Bird {\r\n   return &Bird{\r\n      WingColor: wingColor,\r\n      CommonAnimal: Animal{\r\n         Name:   name,\r\n         Age:    age,\r\n         Gender: gender,\r\n      },\r\n   }\r\n}\r\n\r\nfunc (b *Bird) Fly() {\r\n   fmt.Println("我起飞啦！")\r\n}\r\n\r\nfunc main() {\r\n   bird := *NewBird("小鸟", 1, "公", "绿色")\r\n   fmt.Println(bird)\r\n   bird.Fly()\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"运行这段代码，可以看到控制台的输出内容如下所示："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"{绿色 {小鸟 1 公}}"}),"\n",(0,i.jsx)(r.p,{children:"我起飞啦！"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"从输出的格式上，我们也可看出，Animal类型确实被Bird类型嵌入其中。那么，问题也随之而来：若想访问Bird中的Animal中的Name属性值，该怎么做呢？"}),"\n",(0,i.jsx)(r.p,{children:"思路其实非常简单，也是层层嵌套地访问就可以了。就拿本例来说，bird.CommonAnimal访问到的是CommonAnimal属性，它是Animal类型；bird.CommonAnimal.Name，访问到的就是CommonAnimal中的Name属性了。"}),"\n",(0,i.jsx)(r.p,{children:"类似地，我们继续定义子结构体狗（Dog），它拥有毛色（Color）属性。还有犬吠（Bark）动作。请读者参考上面小鸟（Bird）部分的代码，独立完成狗（Dog）部分的代码，要求依然使用构造函数（NewDog()）和方法（Bark()）。"}),"\n",(0,i.jsx)(r.p,{children:"完整的代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'type Animal struct {\r\n   Name   string\r\n   Age    int\r\n   Gender string\r\n}\r\n\r\ntype Dog struct {\r\n   Color        string\r\n   CommonAnimal Animal\r\n}\r\n\r\nfunc NewDog(name string, age int, gender string, color string) *Dog {\r\n   return &Dog{\r\n      Color: color,\r\n      CommonAnimal: Animal{\r\n         Name:   name,\r\n         Age:    age,\r\n         Gender: gender,\r\n      },\r\n   }\r\n}\r\n\r\nfunc (d *Dog) Bark() {\r\n   fmt.Println("汪汪汪！")\r\n}\r\n\r\nfunc main() {\r\n   dog := *NewDog("小狗", 2, "公", "黄色")\r\n   fmt.Println(dog)\r\n   dog.Bark()\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"运行上述代码，控制台将输出："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"{黄色 {小狗 2 公}}"}),"\n",(0,i.jsx)(r.p,{children:"汪汪汪！"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"有了Bird，Dog的实现应该不会有问题吧？"}),"\n",(0,i.jsx)(r.p,{children:"在继续之前，我有个问题要考考大家：dog变量是Dog类型，bird变量是Bird类型。那么，dog可以执行Fly()方法吗？反过来，bird可以执行Bark()方法吗？为什么？"}),"\n",(0,i.jsxs)(r.p,{children:["答案是：统统",(0,i.jsx)(r.strong,{children:"不能"}),"。"]}),"\n",(0,i.jsxs)(r.p,{children:["因为Fly()方法的接收者是*Bird，Bark()方法的接收者是*Dog。",(0,i.jsx)(r.strong,{children:"动作的接收者不同，意味着发生或执行动作的对象不同，因此不能混用。"}),"（想想现实世界中，有谁见过小鸟犬吠，小狗起飞吗？）"]}),"\n",(0,i.jsx)(r.p,{children:"但是，有一些动作确实是小狗和小鸟同时具备的，比如：吃饭（Eat）。几乎没有哪种动物（Animal）能够不吃饭而存活吧？"}),"\n",(0,i.jsx)(r.p,{children:"那么，若要实现吃饭这个动作，继续为Bird和Dog分别创建方法当然是可行的。但又没有更好的实现方式呢？"}),"\n",(0,i.jsxs)(r.p,{children:["当然有！Bird和Dog都是由Animal派生而来，而吃饭（Eat）又是Animal所具有的公共动作。因此，我们便可为Animal创建一个方法，接收者是*Animal类型即可。这样一来，",(0,i.jsx)(r.strong,{children:"因为Bird和Dog都嵌入了Animal类型数据，自然也就可以执行Animal的动作了"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:"下面，创建一个接收者是*Animal类型的方法，名为Eat()。为了体现动作的作用对象，我们在Eat()方法中，将Name属性值一并输出到控制台中。具体代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'type Animal struct {\r\n   Name   string\r\n   Age    int\r\n   Gender string\r\n}\r\n\r\nfunc (a *Animal) Eat() {\r\n   fmt.Println(a.Name, "我要吃到饱！")\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"下面，回到main()函数中，使用bird和dog变量逐层调用Eat()方法。具体代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   bird := *NewBird("小鸟", 1, "公", "绿色")\r\n   bird.CommonAnimal.Eat()\r\n   dog := *NewDog("小狗", 2, "公", "黄色")\r\n   dog.CommonAnimal.Eat()\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"运行程序，控制台将输出："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"小鸟 我要吃到饱！"}),"\n",(0,i.jsx)(r.p,{children:"小狗 我要吃到饱！"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"通过上面的输出结果可以看出：虽然它们调用的是公共方法，但由于执行该动作的变量不同，最终的输出结果也会随之变化。这便是我们想要的效果。"}),"\n",(0,i.jsxs)(r.h2,{id:"匿名结构体嵌套",children:["匿名结构体嵌套",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#匿名结构体嵌套",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"Go语言语法还允许开发者以一种更为简单的方式嵌套结构体使用，这种更简单的方式便是嵌套匿名结构体。在后期使用时，也会被简化。以Bird类型结构体为例，下面的写法是完全合法的："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'type Animal struct {\r\n   Name   string\r\n   Age    int\r\n   Gender string\r\n}\r\n\r\nfunc (a *Animal) Eat() {\r\n   fmt.Println(a.Name, "我要吃到饱！")\r\n}\r\n\r\ntype Bird struct {\r\n   string\r\n   Animal\r\n}\r\n\r\nfunc NewBird(name string, age int, gender string, wingColor string) *Bird {\r\n   return &Bird{\r\n      wingColor,\r\n      Animal{\r\n         name,\r\n         age,\r\n         gender,\r\n      },\r\n   }\r\n}\r\n\r\nfunc (b *Bird) Fly() {\r\n   fmt.Println("我起飞啦！")\r\n}\r\n\r\nfunc main() {\r\n   bird := *NewBird("小鸟", 1, "公", "绿色")\r\n   //访问string类型成员\r\n   fmt.Println(bird.string)\r\n   //访问Name成员\r\n   fmt.Println(bird.Name)\r\n   bird.Eat()\n'})}),"\n",(0,i.jsx)(r.p,{children:"上述代码运行后，控制台将输出："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"绿色"}),"\n",(0,i.jsx)(r.p,{children:"小鸟"}),"\n",(0,i.jsx)(r.p,{children:"小鸟 我要吃到饱！"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"请大家将这种简化写法与普通的写法对比，重点关注Bird结构体的定义方式、NewBird()构造函数的实现方式以及main()函数中，bird变量的字段取值和方法调用方式。"}),"\n",(0,i.jsxs)(r.h2,{id:"总结",children:["总结",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,i.jsx)(r.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"使用结构体实现继承。"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"本讲是结构体系列专题的第三篇，也是这个专题的最后一篇。在本讲中，需要重点掌握的就是“继承”了。首先要明确继承中“父”与“子”的概念，知道它们之间的关系——“子结构体”扩展了“父结构体” 。以及它们之间的区别：“父结构体”是概括的，抽象的，那么“子结构体”就是具体的、详细的。接着便是利用Go语言中的结构体来实现继承的语法知识了。"}),"\n",(0,i.jsx)(r.p,{children:"最后，从Go语言的语法设计中，我们还可得到如下结论："}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Go语言中的继承是通过内嵌或组合来实现的，在Go语言中，相比较于继承，组合更受青睐。"})}),"\n",(0,i.jsxs)(r.p,{children:["灵活地使用结构体，通过嵌套的方式可以描述结构非常复杂的数据。在执行网络请求场景中，解析服务端返回的JSON格式通常会用到结构体嵌套的技能。有关这部分的扩展阅读资料请参考：",(0,i.jsx)(r.a,{href:"http://c.biancheng.net/view/76.html",target:"_blank",rel:"noopener noreferrer",children:"Go语言使用匿名结构体解析JSON数据 (biancheng.net)"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:"➡️ 在下次课程中，我们会介绍Go语言中接口的使用技巧，具体内容是："}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"接口的定义和使用"}),"\n"]})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,d.ah)(),n.components);return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}let a=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC16%E7%AB%A0%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%89%EF%BD%9C%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E2%80%9C%E7%88%B6%E2%80%9D%E4%B8%8E%E2%80%9C%E5%AD%90%E2%80%9D.md"]={toc:[{text:"什么是继承",id:"什么是继承",depth:2},{text:"结构体的嵌套",id:"结构体的嵌套",depth:2},{text:"匿名结构体嵌套",id:"匿名结构体嵌套",depth:2},{text:"总结",id:"总结",depth:2}],title:"第16章—结构体三｜继承，代码中的“父”与“子”",headingTitle:"第16章—结构体三｜继承，代码中的“父”与“子”",frontmatter:{}}}}]);