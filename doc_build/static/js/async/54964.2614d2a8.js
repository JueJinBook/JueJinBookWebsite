"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["54964"],{925292:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(552676),d=s(740453);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",h3:"h3",pre:"pre",code:"code"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"18webpack-性能优化",children:["18.Webpack 性能优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18webpack-性能优化",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在这一的章节中，我不会浪费篇幅给大家讲如何写配置文件。",(0,r.jsx)(n.strong,{children:"如果你想学习这方面的内容，那么完全可以去官网学习"}),"。在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"有哪些方式可以减少 Webpack 的打包时间"}),"\n",(0,r.jsx)(n.li,{children:"有哪些方式可以让 Webpack 打出来的包更小"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"减少-webpack-打包时间",children:["减少 Webpack 打包时间",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#减少-webpack-打包时间",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"优化-loader",children:["优化 Loader",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化-loader",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，",(0,r.jsx)(n.strong,{children:"转换代码越多，效率就越低"}),"。当然了，我们是有办法优化的。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们可以",(0,r.jsx)(n.strong,{children:"优化 Loader 的文件搜索范围"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  module: {\n    rules: [\n      {\n        // js 文件才使用 babel\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        // 只在 src 文件夹下查找\n        include: [resolve('src')],\n        // 不会去查找的路径\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 ",(0,r.jsx)(n.code,{children:"node_modules"})," 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。"]}),"\n",(0,r.jsxs)(n.p,{children:["当然这样做还不够，我们还可以将 Babel 编译过的文件",(0,r.jsx)(n.strong,{children:"缓存"}),"起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"loader: 'babel-loader?cacheDirectory=true'\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"happypack",children:["HappyPack",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#happypack",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"HappyPack 可以将 Loader 的同步执行转换为并行的"}),"，这样就能充分利用系统资源来加快打包效率了"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module: {\n  loaders: [\n    {\n      test: /\\.js$/,\n      include: [resolve('src')],\n      exclude: /node_modules/,\n      // id 后面的内容对应下面\n      loader: 'happypack/loader?id=happybabel'\n    }\n  ]\n},\nplugins: [\n  new HappyPack({\n    id: 'happybabel',\n    loaders: ['babel-loader?cacheDirectory'],\n    // 开启 4 个线程\n    threads: 4\n  })\n]\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"dllplugin",children:["DllPlugin",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dllplugin",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"DllPlugin 可以将特定的类库提前打包然后引入"}),"。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。"]}),"\n",(0,r.jsx)(n.p,{children:"接下来我们就来学习如何使用 DllPlugin"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 单独配置在一个文件中\n// webpack.dll.conf.js\nconst path = require('path')\nconst webpack = require('webpack')\nmodule.exports = {\n  entry: {\n    // 想统一打包的类库\n    vendor: ['react']\n  },\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].dll.js',\n    library: '[name]-[hash]'\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      // name 必须和 output.library 一致\n      name: '[name]-[hash]',\n      // 该属性需要与 DllReferencePlugin 中一致\n      context: __dirname,\n      path: path.join(__dirname, 'dist', '[name]-manifest.json')\n    })\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 ",(0,r.jsx)(n.code,{children:"DllReferencePlugin"})," 将依赖文件引入项目中"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack.conf.js\nmodule.exports = {\n  // ...省略其他配置\n  plugins: [\n    new webpack.DllReferencePlugin({\n      context: __dirname,\n      // manifest 就是之前打包出来的 json 文件\n      manifest: require('./dist/vendor-manifest.json'),\n    })\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"代码压缩",children:["代码压缩",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码压缩",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 Webpack3 中，我们一般使用 ",(0,r.jsx)(n.code,{children:"UglifyJS"})," 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 ",(0,r.jsx)(n.code,{children:"webpack-parallel-uglify-plugin"})," 来并行运行 ",(0,r.jsx)(n.code,{children:"UglifyJS"}),"，从而提高效率。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 Webpack4 中，我们就不需要以上这些操作了，只需要将 ",(0,r.jsx)(n.code,{children:"mode"})," 设置为 ",(0,r.jsx)(n.code,{children:"production"})," 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 ",(0,r.jsx)(n.code,{children:"console.log"})," 这类代码的功能。"]}),"\n",(0,r.jsxs)(n.h3,{id:"一些小的优化点",children:["一些小的优化点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一些小的优化点",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们还可以通过一些小的优化点来加快打包速度"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"resolve.extensions"}),"：用来表明文件后缀列表，默认查找顺序是 ",(0,r.jsx)(n.code,{children:"['.js', '.json']"}),"，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"resolve.alias"}),"：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"module.noParse"}),"：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"减少-webpack-打包后的文件体积",children:["减少 Webpack 打包后的文件体积",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#减少-webpack-打包后的文件体积",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-!",children:"注意：该内容也属于性能优化领域。\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"按需加载",children:["按需加载",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#按需加载",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，",(0,r.jsx)(n.strong,{children:"这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件"}),"。当然不仅仅路由可以按需加载，对于 ",(0,r.jsx)(n.code,{children:"loadash"})," 这种大型类库同样可以使用这个功能。"]}),"\n",(0,r.jsxs)(n.p,{children:["按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 ",(0,r.jsx)(n.code,{children:"Promise"}),"，当 ",(0,r.jsx)(n.code,{children:"Promise"})," 成功以后去执行回调。"]}),"\n",(0,r.jsxs)(n.h3,{id:"scope-hoisting",children:["Scope Hoisting",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scope-hoisting",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。"})}),"\n",(0,r.jsx)(n.p,{children:"比如我们希望打包两个文件"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// test.js\nexport const a = 1\n// index.js\nimport { a } from './test.js'\n"})}),"\n",(0,r.jsx)(n.p,{children:"对于这种情况，我们打包出来的代码会类似这样"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  },\n  /* 1 */\n  function (module, exports, require) {\n    //...\n  }\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:"但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  }\n]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 ",(0,r.jsx)(n.code,{children:"optimization.concatenateModules"})," 就可以了。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  optimization: {\n    concatenateModules: true\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"tree-shaking",children:["Tree Shaking",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tree-shaking",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tree Shaking 可以实现删除项目中未被引用的代码"}),"，比如"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// test.js\nexport const a = 1\nexport const b = 2\n// index.js\nimport { a } from './test.js'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["对于以上情况，",(0,r.jsx)(n.code,{children:"test"})," 文件中的变量 ",(0,r.jsx)(n.code,{children:"b"})," 如果没有在项目中使用到的话，就不会被打包到文件中。"]}),"\n",(0,r.jsx)(n.p,{children:"如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在这一章节中，我们学习了如何使用 Webpack 去进行性能优化以及如何减少打包时间。"}),"\n",(0,r.jsxs)(n.p,{children:["Webpack 的版本更新很快，各个版本之间实现优化的方式可能都会有区别，所以我没有使用过多的代码去展示如何实现一个功能。",(0,r.jsx)(n.strong,{children:"这一章节的重点是学习到我们可以通过什么方式去优化，具体的代码实现可以查找具体版本对应的代码即可。"})]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F18.Webpack%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md"]={toc:[{text:"减少 Webpack 打包时间",id:"减少-webpack-打包时间",depth:2},{text:"优化 Loader",id:"优化-loader",depth:3},{text:"HappyPack",id:"happypack",depth:3},{text:"DllPlugin",id:"dllplugin",depth:3},{text:"代码压缩",id:"代码压缩",depth:3},{text:"一些小的优化点",id:"一些小的优化点",depth:3},{text:"减少 Webpack 打包后的文件体积",id:"减少-webpack-打包后的文件体积",depth:2},{text:"按需加载",id:"按需加载",depth:3},{text:"Scope Hoisting",id:"scope-hoisting",depth:3},{text:"Tree Shaking",id:"tree-shaking",depth:3},{text:"小结",id:"小结",depth:2}],title:"18.Webpack 性能优化",headingTitle:"18.Webpack 性能优化",frontmatter:{}}}}]);