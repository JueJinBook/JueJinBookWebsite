"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97757"],{153878:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var c=s(552676),d=s(740453);let t=s.p+"static/image/b7326c8e168ec000f0346fcbfdec4504.cbe3bd98.webp",r=s.p+"static/image/131f9fdc3f51bdc2de7b8bdf24f491e1.6792112d.webp",i=s.p+"static/image/667e01be8e9784c65c293f1f839d1477.6c6b8ec9.webp",l=s.p+"static/image/768605a06321dc5f0905f534cfa03d3e.bf0ef77c.webp",o=s.p+"static/image/37a950267fb7dfc547ef50f805d8dc93.5594deca.webp",h=s.p+"static/image/5f71ed9f3886a01e7f7769a842716c30.2b159542.webp",p=s.p+"static/image/fad7494cf618e6a7cafccad5c3d4f437.95b13732.webp",a=s.p+"static/image/2bac32e89e7f47753cd3f5b608188d70.679f86ed.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img",blockquote:"blockquote",h4:"h4"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"6vue3-组合-api-入口-setup-浅析",children:["6.Vue3 组合 API 入口 Setup 浅析",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6vue3-组合-api-入口-setup-浅析",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本章节将通过实例代码的形式，深入分析 ",(0,c.jsx)(n.code,{children:"setup"})," 的使用技巧。对标 ",(0,c.jsx)(n.code,{children:"Vue 2.x"})," 模式下同样形式的新写法，如子组件如何接收父组件的传值及注意事项、子组件如何触发父组件的方法等。"]}),"\n",(0,c.jsxs)(n.h2,{id:"setup-简介",children:["setup 简介",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#setup-简介",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["介绍 ",(0,c.jsx)(n.code,{children:"setup"})," 之前，我们先来解释一下什么叫组合 API（Composition API）。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Vue3"})," 将 ",(0,c.jsx)(n.code,{children:"Vue 2.0"})," 的选项 API（options API）制作成一个个 ",(0,c.jsx)(n.code,{children:"hook"})," （钩子）函数，如 ",(0,c.jsx)(n.code,{children:"watch"}),"、",(0,c.jsx)(n.code,{children:"computed"})," 等方法，在 ",(0,c.jsx)(n.code,{children:"Vue 2.0"})," 中是以选项 API 的形式出现，如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// options API\nexport default {\n  name: 'App',\n  watch: {\n\n  },\n  computed: {\n\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["而 ",(0,c.jsx)(n.code,{children:"Vue3"})," 新增的 ",(0,c.jsx)(n.code,{children:"setup"})," 方法，也是以选项的形式出现在抛出的对象中，但是诸如上述代码中的 ",(0,c.jsx)(n.code,{children:"watch"}),"、",(0,c.jsx)(n.code,{children:"computed"})," 等属性，都变成 ",(0,c.jsx)(n.code,{children:"hook"})," 函数的形式，通过 ",(0,c.jsx)(n.code,{children:"vue"})," 解构出来，在 ",(0,c.jsx)(n.code,{children:"setup"})," 方法中使用，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// Composition API\nimport { watch, computed } from 'vue'\nexport default {\n  name: 'App',\n  setup() {\n    watch(() => {\n      // do something\n    }, () => {\n      // do something\n    })\n    const a = computed(() => {\n      // do something\n    })\n  }\n}\n\n// Vue 3.2.x 推出的特有语法\n<script setup>\n  import { watch, computed } from 'vue'\n  watch(() => {\n    // do something\n  }, () => {\n    // do something\n  })\n  const a = computed(() => {\n    // do something\n  })\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"setup"})," 存在的意义，就是为了让你能够使用新增的组合 API。并且这些组合 API 只能在 ",(0,c.jsx)(n.code,{children:"setup"})," 函数内使用。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"setup"})," 调用的时机是创建组件实例，然后初始化 ",(0,c.jsx)(n.code,{children:"props"}),"，紧接着就是调用 ",(0,c.jsx)(n.code,{children:"setup"})," 函数。从生命周期钩子的角度来看，它会在 ",(0,c.jsx)(n.code,{children:"beforeCreate"})," 钩子之前被调用，所以 ",(0,c.jsx)(n.code,{children:"setup"})," 内是拿不到 ",(0,c.jsx)(n.code,{children:"this"})," 上下文的，这在后面的会详细分析。"]}),"\n",(0,c.jsx)(n.p,{children:"不妨先看看生命周期的对照表："}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{children:"Vue 2.0"}),"\n",(0,c.jsx)(n.th,{children:"Vue3"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"beforeCreate"}),"\n",(0,c.jsx)(n.td,{children:"setup()"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"created"}),"\n",(0,c.jsx)(n.td,{children:"setup()"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"beforeMount"}),"\n",(0,c.jsx)(n.td,{children:"onBeforeMount"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"mounted"}),"\n",(0,c.jsx)(n.td,{children:"onMounted"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"beforeUpdate"}),"\n",(0,c.jsx)(n.td,{children:"onBeforeUpdate"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"updated"}),"\n",(0,c.jsx)(n.td,{children:"onUpdated"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"beforeDestroy"}),"\n",(0,c.jsx)(n.td,{children:"onBeforeUnmount"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"destroyed"}),"\n",(0,c.jsx)(n.td,{children:"onUnmounted"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"activated"}),"\n",(0,c.jsx)(n.td,{children:"onActivated"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"deactivated"}),"\n",(0,c.jsx)(n.td,{children:"onDeactivated"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"errorCaptured"}),"\n",(0,c.jsx)(n.td,{children:"onErrorCaptured"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["除去 ",(0,c.jsx)(n.code,{children:"beforeCreate"})," 和 ",(0,c.jsx)(n.code,{children:"created"})," 之外，在我们的 ",(0,c.jsx)(n.code,{children:"setup"})," 方法中，有 9 个旧的生命周期钩子，我们可以在 ",(0,c.jsx)(n.code,{children:"setup"})," 方法中访问。"]}),"\n",(0,c.jsxs)(n.p,{children:["1、setup()：开始创建组件之前，在 ",(0,c.jsx)(n.code,{children:"beforeCreate"})," 和 ",(0,c.jsx)(n.code,{children:"created"})," 之前执行。创建的是",(0,c.jsx)(n.code,{children:"data"})," 和 ",(0,c.jsx)(n.code,{children:"method"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"2、onBeforeMount()： 组件挂载到节点上之前执行的函数。"}),"\n",(0,c.jsx)(n.p,{children:"3、onMounted()：组件挂载完成后执行的函数。"}),"\n",(0,c.jsx)(n.p,{children:"4、onBeforeUpdate()：组件更新之前执行的函数。"}),"\n",(0,c.jsx)(n.p,{children:"5、onUpdated()：组件更新完成之后执行的函数。"}),"\n",(0,c.jsx)(n.p,{children:"6、onBeforeUnmount()：组件卸载之前执行的函数。"}),"\n",(0,c.jsx)(n.p,{children:"7、onUnmounted()：组件卸载完成后执行的函数。"}),"\n",(0,c.jsxs)(n.p,{children:["8、onActivated()：被 ",(0,c.jsx)(n.code,{children:"keep-alive"})," 缓存的组件激活时调用。"]}),"\n",(0,c.jsx)(n.p,{children:"9、onDeactivated()：被 keep-alive 缓存的组件停用时调用，比如从 A 组件，切换到 B 组件，A 组件消失时执行。"}),"\n",(0,c.jsx)(n.p,{children:"10、onErrorCaptured()：当捕获一个来自子孙组件的异常时激活钩子函数。"}),"\n",(0,c.jsxs)(n.h2,{id:"template-模板中使用-setup",children:["template 模板中使用 setup",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#template-模板中使用-setup",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在上一章节中我们介绍过了如何初始化 ",(0,c.jsx)(n.code,{children:"Vue3"})," 项目，本小册我们采用 ",(0,c.jsx)(n.code,{children:"Vite"})," 做初始化工作，温故一下命令行："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"npm init vite-app vue3-setup\n"})}),"\n",(0,c.jsxs)(n.p,{children:["创建成功之后，安装依赖，通过 ",(0,c.jsx)(n.code,{children:"npm run dev"})," 启动项目，如下所示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们修改 ",(0,c.jsx)(n.code,{children:"src/App.vue"})," 文件如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ count }} {{ state.foo }}</div>\n</template>\n\n<script setup>\n  import { ref, reactive } from 'vue'\n  const count = ref(0)\n  const state = reactive({ foo: 'bar' })\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上述代码，通过 ",(0,c.jsx)(n.code,{children:"ref"}),"、",(0,c.jsx)(n.code,{children:"reactive"})," 创建两个变量，给 ",(0,c.jsx)(n.code,{children:"script"})," 标签附上 ",(0,c.jsx)(n.code,{children:"setup"})," 属性后，内部将不再通过 ",(0,c.jsx)(n.code,{children:"export default"})," 抛出方式的语法。",(0,c.jsx)(n.code,{children:"template"})," 模板可以直接拿到 ",(0,c.jsx)(n.code,{children:"script"})," 标签内声明的变量，并且支持响应式，这将使得代码变得简洁明了。"]}),"\n",(0,c.jsxs)(n.p,{children:["这里插播一则小知识，通过 ",(0,c.jsx)(n.code,{children:"ref"}),"、",(0,c.jsx)(n.code,{children:"reactive"})," 方法包裹的变量，会被赋予响应式的能力，也就是说你改变他们的值，模板内也会响应展示改变后的值，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ count }} {{ state.foo }}</div>\n</template>\n\n<script setup>\n  import { ref, reactive } from 'vue'\n  const count = ref(0)\n  const state = reactive({ foo: 'bar' })\n  setTimeout(() => {\n    // 通过 ref 包裹的变量，需要通过 .value 的形式修改变量，在模板中使用无需使用 .value ，因为在 setup 内 return 的时候，已经帮你接开。\n    count.value = 1\n    state.foo = 'foo'\n  }, 2000)\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"h-渲染函数中使用-setup",children:["h 渲染函数中使用 setup",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#h-渲染函数中使用-setup",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"h 函数是 createElement 的别名。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"setup"})," 也可以返回一个函数，函数中也能使用当前 ",(0,c.jsx)(n.code,{children:"setup"})," 函数作用域中的响应式数据，我们将代码修改为如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<script>\n  import { ref, reactive, h } from 'vue'\n\n  export default {\n    setup() {\n      const count = ref(1)\n      const object = reactive({ foo: 'bar' })\n      return () => h('h1', [count.value, object.foo])\n    },\n  }\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["通过 ",(0,c.jsx)(n.code,{children:"h"})," 函数，将 ",(0,c.jsx)(n.code,{children:"count.value"}),"（在 setup 函数作用域内，需要使用 .value 获取值） 和 ",(0,c.jsx)(n.code,{children:"object.foo"})," 渲染到 ",(0,c.jsx)(n.code,{children:"h1"})," 标签内。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"组件如何接受外部传入的参数",children:["组件如何接受外部传入的参数",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件如何接受外部传入的参数",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Vue 3.2 为我们在 ",(0,c.jsx)(n.code,{children:"script"})," 内默认添加了三个方法，这三个方法分别是",(0,c.jsx)(n.code,{children:"defineProps"})," 、 ",(0,c.jsx)(n.code,{children:"defineEmits"})," 和  ",(0,c.jsx)(n.code,{children:"defineExpose"})]}),"\n",(0,c.jsxs)(n.h4,{id:"defineprops",children:["defineProps",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#defineprops",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们现在需要一个父子组件的传值例子，修改上述 ",(0,c.jsx)(n.code,{children:"src/App.vue"})," 文件如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <Test :count=\"count\"></Test>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Test from './components/Test.vue'\n\nconst count = ref(0)\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"src/components"})," 下新增 ",(0,c.jsx)(n.code,{children:"Test.vue"})," 组件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ props.count }}</div>\n</template>\n\n<script setup>\nconst props = defineProps({ count: Number })\nconsole.log('props', props)\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在页面中我们打印了 ",(0,c.jsx)(n.code,{children:"props"}),"，可以发现它被 ",(0,c.jsx)(n.code,{children:"Proxy"})," 代理过，这是 ",(0,c.jsx)(n.code,{children:"Vue3"})," 实现响应式的核心 API，也就是说从父亲组件传到子组件的 ",(0,c.jsx)(n.code,{children:"count"})," 变量，已经是响应式数据。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["并且在子组件内，可以通过 ",(0,c.jsx)(n.code,{children:"watchEffect"})," 和 ",(0,c.jsx)(n.code,{children:"watch"})," 观察到数据的变化情况，我们来试试让数据在父组件变化起来，分别做如下修改："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"// App.vue\n<template>\n  <Test :count=\"count\"></Test>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Test from './components/Test.vue'\n\nconst count = ref(0)\nsetTimeout(() => {\n  count.value = 100\n}, 2000)\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"// Test.vue\n<template>\n  <div>{{ props.count }}</div>\n</template>\n\n<script setup>\nimport { watchEffect } from 'vue'\nconst props = defineProps({ count: Number })\nwatchEffect(() => {\n    console.log('props.count = ', props.count)\n  })\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.h4,{id:"defineemits",children:["defineEmits",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#defineemits",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["该属性的作用是在子组件获取父组件传递进来的方法，我们同样用一个例子来演示该属性的作用，在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 添加一个 ",(0,c.jsx)(n.code,{children:"add"})," 方法如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <Test :count=\"count\" @add=\"add\"></Test>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Test from './components/Test.vue'\n\nconst count = ref(0)\nconst add = () => {\n  count.value += 1\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里声明 ",(0,c.jsx)(n.code,{children:"add"})," 方法，就不用再像 ",(0,c.jsx)(n.code,{children:"setup"})," 函数那样，将其 ",(0,c.jsx)(n.code,{children:"return"})," 出去。\n在子组件内，通过 ",(0,c.jsx)(n.code,{children:"defineEmits"})," 接受方法，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ props.count }}</div>\n  <button @click=\"add\">+1</button>\n</template>\n\n<script setup>\nconst props = defineProps({ count: Number })\n// 获取父组件传进来的add方法\nconst emit = defineEmits(['add'])\n\nconst add = () => {\n  // 执行父组件传进来的add方法\n  emit('add')\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["使用上，和 ",(0,c.jsx)(n.code,{children:"Vue 2"})," 的区别不大，主要区别在于如何获取上。执行效果如下所示：\n",(0,c.jsx)("img",{src:"data:image/webp;base64,UklGRsACAABXRUJQVlA4ILQCAABQIgCdASr4AbYAPp1OpE2lpCOiIHQIYLATiWlu4XYBG/ORMzu1KU3GB57Ocr8r0QAFRCYAqxrZTly5cuXLly5cuXLly5cuXLly5cuXLly5cuXLly5cuXLly5cuXLly5cuXCYlSTQJQwXqgtSEwBVjWynLly4ULb42I8y3orGtlOXLly5cuXKyuIeqDs5eGIgwy9P4VBEdQEdwx0hMAVY1spy5cuE8J8/UH1FXiAGc+Bu5YTy5cuXLly5cuXLlwoy0EnFLVUQl6ajembb+ktlOXLly5cueCxcuaKEUF9uL/JKODGTbzxWNbKcuXLly5cuXDKa45cn96KtQehBjpCYAqxrZTly5cuXO05cuXLly5cuXLly5cuXLly4QAAP7/k5gAABQ/h7bA6d218/6o94o6DCXkLJKBkKWL+1J/yci1vj1UMqvTr0pFnHXzyoABCZUCaGflHuJwwtsNvJv7oaLEK6X3fUCGN3bwwuGrwdpGKVfggg3D3px2E5DbvvlmW3ZtT6OKFaNZnZSarCt0uoqMKMV1OeVcfu60obhhlhCdX8E9NPvDYYf4eIdpFCV0wuxe39yWDDEPMBNt2PTZc/ylIUiydoJReGu9OcIuNRmsswCxcvY7Sqx0pUjrz8MHe07ljxt5+YVlKj0rDHbGDDDZcKSRDWhXlmuSL7K9Rc5c6rsKJdnTtbSlxA/+iGaV2/jM/MxUd48q8/zGJrdAj4ER4xfnhYIpb/7Q45SfccJccdSSq5UWdY/x/M1EDfAhgjzlm5WNNQhfiEla+pYhtBv54k8iLzZ/y9Cbm/tKUT/0SUsbPn47/RRBLHkXHX390kDVxhqmRqkzKRjkvMiCJV5PlnPbs22k3ld0RPjJj+PY1b1P0f3CBfuhV/re7p0sQ53Uk29PVS77cBZln+3hX9gAAAAAAA==",alt:""})]}),"\n",(0,c.jsxs)(n.h4,{id:"defineexpose",children:["defineExpose",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#defineexpose",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"Vue 3.2.x"})," 版本出来前，我们使用 ",(0,c.jsx)(n.code,{children:"Vue3"})," 开发项目都是用 ",(0,c.jsx)(n.code,{children:"setup"})," 函数的方式，在这种方式下，父组件通过 ",(0,c.jsx)(n.code,{children:"ref"})," 去获取子组件 ",(0,c.jsx)(n.code,{children:"return"})," 出来的方法是比较方便的，我们修改 ",(0,c.jsx)(n.code,{children:"App.vue"})," 和 ",(0,c.jsx)(n.code,{children:"Test.vue"})," 组件如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"// App.vue\n<template>\n  <Test :count=\"count\" ref=\"TestRef\"></Test>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport Test from './components/Test.vue'\n\nconst count = ref(1)\nconst TestRef = ref()\nconsole.log('TestRef', TestRef)\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"// Test.vue\n<template>\n  <div>{{ props.count }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'Test',\n  props: {\n    count: Number\n  },\n  setup(props) {\n    const testFn = () => {\n      console.log('我是测试方法')\n    }\n    return {\n      props,\n      testFn // 将这个测试方法 return 出去\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"查看浏览器的打印结果如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["上图显示 ",(0,c.jsx)(n.code,{children:"TestRef"})," 的打印结果，也就意味着 ",(0,c.jsx)(n.code,{children:"App.vue"})," 可以拿到 ",(0,c.jsx)(n.code,{children:"Test.vue"})," 内部的方法。这个特性能帮我们实现很多有趣的组件。"]}),"\n",(0,c.jsxs)(n.p,{children:["但是到了 ",(0,c.jsx)(n.code,{children:"Vue 3.2.x"})," 版本，使用 ",(0,c.jsx)(n.code,{children:"script setup"})," 后，父组件就拿不到子组件的内部方法了，修改",(0,c.jsx)(n.code,{children:"Test.vue"})," 如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"// Test.vue\n<template>\n  <div>{{ props.count }}</div>\n</template>\n\n<script setup>\nconst props = defineProps({ count: Number })\nconst testFn = () => {\n  console.log('这是测试方法')\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器打印结果如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["此时，",(0,c.jsx)(n.code,{children:"defineExpose"})," 的作用就得以体现了。在 ",(0,c.jsx)(n.code,{children:"Test.vue"})," 中，将想要往外抛出的方法作为参数放到 ",(0,c.jsx)(n.code,{children:"defineExpose"})," 中，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"defineExpose({ testFn })\n"})}),"\n",(0,c.jsx)(n.p,{children:"刷新浏览器，查看控制台如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"Vue3"})," 的迭代过程中，书写形式会变得越来越优雅，这从 ",(0,c.jsx)(n.code,{children:"setup"})," 函数写法，到 ",(0,c.jsx)(n.code,{children:"script setup"})," 写法的转变就能看出，老的写法比较累赘，每声明一个变量或者方法都要通过 ",(0,c.jsx)(n.code,{children:"return"})," 方法返回给模板才能使用，而 ",(0,c.jsx)(n.code,{children:"script setup"})," 则简洁明了，甚至引入的组件都帮你自动注册。这说明我们需要不断的学习才能更上时代的步伐。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(x,{...e})}):x(e)}let j=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F6.Vue3%20%E7%BB%84%E5%90%88%20API%20%E5%85%A5%E5%8F%A3%20Setup%20%E6%B5%85%E6%9E%90.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"setup 简介",id:"setup-简介",depth:2},{text:"template 模板中使用 setup",id:"template-模板中使用-setup",depth:2},{text:"h 渲染函数中使用 setup",id:"h-渲染函数中使用-setup",depth:2},{text:"组件如何接受外部传入的参数",id:"组件如何接受外部传入的参数",depth:2},{text:"defineProps",id:"defineprops",depth:4},{text:"defineEmits",id:"defineemits",depth:4},{text:"defineExpose",id:"defineexpose",depth:4},{text:"总结",id:"总结",depth:2}],title:"6.Vue3 组合 API 入口 Setup 浅析",headingTitle:"6.Vue3 组合 API 入口 Setup 浅析",frontmatter:{}}}}]);