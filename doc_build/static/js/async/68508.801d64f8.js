"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["68508"],{429648:function(e,n,d){d.r(n),d.d(n,{default:()=>_});var s=d(552676),c=d(740453);let o=d.p+"static/image/1840386a492a176c2b00061453743eef.7c72ad47.webp",r=d.p+"static/image/67d50ab3e08bb25e7689554c2d41b719.921a175f.webp",a=d.p+"static/image/d69304213b9fe161fbf4d0eb578c9fd3.7b4460e7.webp",t=d.p+"static/image/b206f0b3105e2ceeb167457d19175151.23b23bd8.webp",l=d.p+"static/image/9a62e6e86fdccb7c9afb146424449a88.0bf05303.webp",i=d.p+"static/image/d293f3315997771301198e8ee5a5c4d6.dc569919.webp",h=d.p+"static/image/6a024593dff6f5a43a76cfa7a2dfbeb5.cdc5f0fd.webp",p=d.p+"static/image/2a850ff69f46a9d84f822159c938ae57.e7b8c411.webp",j=d.p+"static/image/23101009db52f68944c5f9be40573578.ec944a5d.webp",m=d.p+"static/image/fbdb425da2b4f5ee33103b4389b4394c.61b37f7b.webp",x=d.p+"static/image/9cd4e56c36fc82651cb2d5480adcae5d.eae25697.webp",b=d.p+"static/image/31c189decea2f2a308528ff65291f362.308c8d27.webp",f=d.p+"static/image/712058022e6f5b4ec1aaabf17351d8a8.9c6e6024.webp",g=d.p+"static/image/005794253b5c8729e40b4799b41b9f93.ad9ceace.webp",D=d.p+"static/image/47932305dffd245b40ccdc08c6786fb3.3f274f54.webp",u=d.p+"static/image/53bf6f10374bb379e000c7192fc0bf46.f249ecbc.webp",C=d.p+"static/image/8f08429a1c42cef22e2325cc090377aa.7ec700a1.webp",v=d.p+"static/image/963c2eb7c4a21f5d70a069e2aee83366.50143146.webp",w=d.p+"static/image/95b6b641cdd4e9db8f41e2597847db8e.7a8c0927.webp",N=d.p+"static/image/5a75ea8146dd9fc9d6fe38064c3da75a.766b9374.webp",k=d.p+"static/image/9c89ad01b00a6fde57690c83cb5cba48.1d40980c.webp",P=d.p+"static/image/7df8c315fc0095ade3ae82318d5a6351.7f354aeb.webp",T=d.p+"static/image/7799856bf94ae839cb897a019a554386.431632b5.webp",E=d.p+"static/image/5432ffff7d63304933fd1c1bb3832ec9.1e22ffc5.webp",M=d.p+"static/image/d23575f7d64ed6613ad86c90762ba6d9.f439552d.webp",I=d.p+"static/image/70d94be2b35f8118dfb87571cb034167.a4df74fa.webp";function O(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",pre:"pre",code:"code",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"45手动对接-cdp-来理解-chrome-devtools-实现原理",children:["45.手动对接 CDP 来理解 Chrome DevTools 实现原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#45手动对接-cdp-来理解-chrome-devtools-实现原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面学习了 Chrome DevTools 的各种工具的使用，从这节开始深入下它的实现原理。"}),"\n",(0,s.jsx)(n.p,{children:"调试工具都包含 frontend、backend、调试协议、信道这四个部分："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而在 Chrome DevTools 里这个调试协议就是 Chrome DevTools Protocol，简称 CDP。"}),"\n",(0,s.jsxs)(n.p,{children:["打开 ",(0,s.jsx)(n.a,{href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer",children:"CDP 的文档"}),"，可以看到 CDP 协议分为了不同的 Domain："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如 DOM、CSS、Debugger 等，这个很容易理解，各种工具的数据通信总不能混到一起吧，所以分成了不同的域来管理。"}),"\n",(0,s.jsx)(n.p,{children:"每个 Domain 下都包含了 Methods 和 Events："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Method 就是 frontend 向 backend 请求数据，backend 给它返回相应的数据"}),"\n",(0,s.jsx)(n.li,{children:"Event 就是 backend 推送给 frontend 的一些数据。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"你可以在 Chrome DevTools 的设置里开启 Protocol Monitor 面板："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 More Tools 里打开："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后你就可以看到当前页面所有的 CDP 数据交互："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"双向箭头的就是 Method，单向箭头的就是 backend 推给 frontend 的 Event。"}),"\n",(0,s.jsx)(n.p,{children:"你可以在下面的 send a raw CDP method 的输入框里输入协议数据，Chrome DevTools 会把它发给 backend:"}),"\n",(0,s.jsx)(n.p,{children:"比如发送 DOM.getDocument 的 method："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"method": "DOM.getDocument","params": {}}\n'})}),"\n",(0,s.jsx)(n.p,{children:"就会返回整个 DOM 的信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如发送 CSS.getComputedStyleForNode 的 method，带上某个 nodeId："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"method": "CSS.getComputedStyleForNode","params": {"nodeId": 920}}\n'})}),"\n",(0,s.jsx)(n.p,{children:"就可以拿到这个 node 的所有计算后的样式："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Chrome DevTools 里展示的所有内容都是从 backend 那里拿到的，他只是一个展示和交互的 UI 而已。"}),"\n",(0,s.jsx)(n.p,{children:"这个 UI 是可以换的，比如我们可以用 VSCode Debugger 对接 CDP 调试协议来调试网页。"}),"\n",(0,s.jsx)(n.p,{children:"Chrome DevTools frontend 也是一个独立的项目，我们可以从 npm 仓库下载 chrome-devtools-frontend 的代码，我这里用的是 1.0.672485 版本的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install chrome-devtools-frontend@1.0.672485\n"})}),"\n",(0,s.jsx)(n.p,{children:"下载下来的代码有个 front_end 目录，这个就是 Chrome DevTools 的前端代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它下面有几个 html："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:'我们在 node_modules/chrome-devtools-frontend 下执行 "npx http-server ." 起个静态服务看一下：'}),"\n",(0,s.jsx)(n.p,{children:"devtools_app.html 就是网页的那个调试页面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"node_app.html 就是 node 的那个调试页面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 Chrome DevTools 的 frontend 部分。"}),"\n",(0,s.jsx)(n.p,{children:"那怎么用这个独立的 frontend 呢？"}),"\n",(0,s.jsx)(n.p,{children:"给它配个 WebSocket 的 backend 就行."}),"\n",(0,s.jsx)(n.p,{children:"用 node 创建个 WebSocket 服务端，打印下收到的消息："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ws = require('ws');\n\nconst wss = new ws.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n    ws.on('message', function message(data) {\n        console.log('received: %s', data);  \n    });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 devtools_app.html 后面加上 ws=localhost:8080 的参数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"启动 ws 服务，你就会发现控制台打印了一系列收到的消息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 CDP 协议的数据。"}),"\n",(0,s.jsx)(n.p,{children:"那我们对接一下这个协议，返回相应格式的数据，能在 Chrome DevTools 里做显示么？"}),"\n",(0,s.jsx)(n.p,{children:"我们试一下。"}),"\n",(0,s.jsx)(n.p,{children:"我们找个网络相关的协议："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在 Protocol Monitor 里看看 NetWork 部分都是怎么通过 CDP 交互的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后你会发现每次发请求前，backend 都会给 frontend 传一个 Network.requestWillBeSent 的消息，带上这次请求的信息。"}),"\n",(0,s.jsx)(n.p,{children:"那我们能不能也发一个这样的消息呢？"}),"\n",(0,s.jsx)(n.p,{children:"我模拟构造了一个类似的 CDP 消息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后在 frontend 的页面看一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现 Network 面板显示了我们发过来的消息！"}),"\n",(0,s.jsx)(n.p,{children:"这就是 Chrome DevTools 的原理。"}),"\n",(0,s.jsxs)(n.p,{children:["（代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize/tree/main/react-source-debug",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:"测试了下 Network 部分的协议之后，我们再来试下 DOM 的。"}),"\n",(0,s.jsx)(n.p,{children:"我用 Protocol Monitor 观察了下 DOM 部分的 CDP 交互："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"首先通过 DOM.getDocument 获取 root 的信息，这一级返回的 node 只到 body。"}),"\n",(0,s.jsx)(n.p,{children:"然后后面再发 DOM.requestChildNodes 的消息，服务端会回一个 DOM.setChildNodes 的消息来返回子节点的信息。"}),"\n",(0,s.jsx)(n.p,{children:"我们也这样实现一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"收到 DOM.getDocument 的消息的时候，我们返回 root 的信息，只到 body 那一级。"}),"\n",(0,s.jsx)(n.p,{children:"然后发送 DOM.setChildNotes 来返回子节点的信息。"}),"\n",(0,s.jsx)(n.p,{children:"还要处理下 DOM.requestChildNodes 的消息，返回空就行。"}),"\n",(0,s.jsx)(n.p,{children:"完整代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'ws.on(\'message\', function message(data) {\n        console.log(\'received: %s\', data);\n\n        const message = JSON.parse(data);\n        if (message.method === \'DOM.getDocument\') {\n            ws.send(JSON.stringify({\n                id: message.id,\n                result: {\n                    root: {\n                        nodeId: 1,\n                        backendNodeId: 1,\n                        nodeType: 9,\n                        nodeName: "#document",\n                        localName: "",\n                        nodeValue: "",\n                        childNodeCount: 2,\n                        children: [\n                            {\n                                nodeId: 2,\n                                parentId: 1,\n                                backendNodeId: 2,\n                                nodeType: 10,\n                                nodeName: "html",\n                                localName: "",\n                                nodeValue: "",\n                                publicId: "",\n                                systemId: ""\n                            },\n                            {\n                                nodeId: 3,\n                                parentId: 1,\n                                backendNodeId: 3,\n                                nodeType: 1,\n                                nodeName: "HTML",\n                                localName: "html",\n                                nodeValue: "",\n                                childNodeCount: 2,\n                                children: [\n                                    {\n                                        nodeId: 4,\n                                        parentId: 3,\n                                        backendNodeId: 4,\n                                        nodeType: 1,\n                                        nodeName: "HEAD",\n                                        localName: "head",\n                                        nodeValue: "",\n                                        childNodeCount: 5,\n                                        attributes: []\n                                    },\n                                    {\n                                        nodeId: 5,\n                                        parentId: 3,\n                                        backendNodeId: 5,\n                                        nodeType: 1,\n                                        nodeName: "BODY",\n                                        localName: "body",\n                                        nodeValue: "",\n                                        childNodeCount: 1,\n                                        attributes: []\n                                    }\n                                ],\n                                attributes: [\n                                    "lang",\n                                    "en"\n                                ],\n                                frameId: "3A70524AB6D85341B3B613D81FDC2DDE"\n                            }\n                        ],\n                        documentURL: "http://127.0.0.1:8085/",\n                        baseURL: "http://127.0.0.1:8085/",\n                        xmlVersion: "",\n                        compatibilityMode: "NoQuirksMode"\n                    }\n                }\n            }));\n\n            ws.send(JSON.stringify({\n                method: "DOM.setChildNodes",\n                params: {\n                    nodes: [\n                        {\n                            attributes: [\n                                "class",\n                                "guang"\n                            ],\n                            backendNodeId: 6,\n                            childNodeCount: 0,\n                            children: [\n                                {\n                                    backendNodeId: 6,\n                                    localName: "",\n                                    nodeId: 7,\n                                    nodeName: "#text",\n                                    nodeType: 3,\n                                    nodeValue: "光光光",\n                                    parentId: 6,\n                                }\n                            ],\n                            localName: "p",\n                            nodeId: 6,\n                            nodeName: "P",\n                            nodeType: 1,\n                            nodeValue: "",\n                            parentId: 5\n                        }\n                    ],\n                    parentId: 5\n                }\n            }));\n        } else if (message.method === \'DOM.requestChildNodes\') {\n            ws.send(JSON.stringify({\n                id: message.id,\n                result: {}\n            }));\n        }\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:"返回的内容如上，我们返回了一个 P 标签，有 class 属性，还有一个文本节点。"}),"\n",(0,s.jsx)(n.p,{children:"重启下 backend 服务，在 frontend 里重连一下，你就会发现 frontend 显示了我们返回的 DOM 信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"经过这两个案例，我们就搞明白了 Chrome DevTools frontend 是怎么和 backend 交互的。"}),"\n",(0,s.jsx)(n.p,{children:"看到自己模拟 DOM 信息这部分，不知道你是否会想到跨端引擎呢。"}),"\n",(0,s.jsx)(n.p,{children:"跨端引擎就是通过前端的技术来描述界面（比如也是通过 DOM），实际上用安卓和 IOS 的原生组件来做渲染。"}),"\n",(0,s.jsx)(n.p,{children:"它的调试工具也是需要显示 DOM 树的信息的，但是因为并不是网页，所以不能直接用 Chrome DevTools。"}),"\n",(0,s.jsx)(n.p,{children:"那如何用 Chrome DevTools 来调试跨端引擎呢？"}),"\n",(0,s.jsx)(n.p,{children:"看完上面两个案例，相信你就会有答案了。只要对接了 CDP，自己实现一个 backend，把 DOM 树的信息，通过 CDP 的格式传给 frontend 就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"自定义的调试工具基本都是前端部分集成下 Chrome DevTools frontend，后端部分实现下对接 CDP 的 ws 服务来实现的。"}),"\n",(0,s.jsxs)(n.p,{children:["比如有很多",(0,s.jsx)(n.a,{href:"https://github.com/ChromeDevTools/awesome-chrome-devtools",target:"_blank",rel:"noopener noreferrer",children:"用 Chrome DevTools 的backend 调试其他代码的工具"}),"："]}),"\n",(0,s.jsxs)(n.p,{children:["比如监听系统级别的（包括浏览器之外）的 http 请求，用 chrome devtools 的Network面板展示的工具 ",(0,s.jsx)(n.a,{href:"https://github.com/kdzwinel/betwixt",target:"_blank",rel:"noopener noreferrer",children:"betwixt"}),"："]}),"\n",(0,s.jsxs)(n.p,{children:["比如用 Chrome DevTools 调试 ios 的网络和数据的工具",(0,s.jsx)(n.a,{href:"https://github.com/square/PonyDebugger",target:"_blank",rel:"noopener noreferrer",children:"PonyDebugger"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"frontend 只是一个对接了 CDP 的独立的客户端 UI，自己实现 CDP 的 backend 就可以用它来调试各种东西。"}),"\n",(0,s.jsx)(n.p,{children:"对前端来说，常见的就是跨端引擎、小程序引擎的调试工具："}),"\n",(0,s.jsx)(n.p,{children:"小程序引擎的调试工具更简单，因为它实际上渲染是用的网页，有 CDP 的 backend，可以直接和 frontend 对接，不用自己实现 CDP 交互。"}),"\n",(0,s.jsx)(n.p,{children:"比如 vivo 的快应用开发工具，它有编辑器、调试器、模拟器这几部分："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"模拟器渲染的内容能够在调试器里调试，就是调试器集成的 frontend 对接了模拟器的 CDP backend。"}),"\n",(0,s.jsx)(n.p,{children:"当然，这里就不是通过 WebSocket 的信道了，而是通过其它方式："}),"\n",(0,s.jsx)(n.p,{children:"Chrome DevTools 支持多种信道："}),"\n",(0,s.jsx)(n.p,{children:"比如 WebSocket 时的通信实现是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而 electron 环境下是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"嵌入到一个环境的时候是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而且，像上面那种在一个窗口里渲染，在另一个窗口里调试的这种需求，electron 直接提供了 api 来支持。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"使用 setDevToolsWebContents 的 api，就可以让 devtools 的 frontend 显示在任意的窗口里。"}),"\n",(0,s.jsx)(n.p,{children:"所以，小程序的调试工具实现起来还是很简单的，不但 CDP 交互不用自己实现，而且一个窗口渲染，一个窗口显示 Chrome DevTools frontend 这种功能 electron 都已经提供了。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们探究了下 Chrome DevTools 的实现原理，它只是一个对接了 CDP 的 UI，完全可以用来调试别的 target，只要实现对应的 CDP backend 即可。"}),"\n",(0,s.jsx)(n.p,{children:"CDP 协议可以在 Protocol Monitor 里看到，分成了多个 Domain，每个 Domain 下有很多 Method 和 Event。"}),"\n",(0,s.jsx)(n.p,{children:"有很多用 Chrome DevTools 调试别的目标的工具，而前端领域的跨端引擎、小程序引擎也是通过这种方式实现的。"}),"\n",(0,s.jsx)(n.p,{children:"跨端引擎要自己实现 CDP 协议的对接，而小程序引擎简单一些，本来就有了 CDP backend，对接到 frontend 即可。"})]})}function S(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}let _=S;S.__RSPRESS_PAGE_META={},S.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F45.%E6%89%8B%E5%8A%A8%E5%AF%B9%E6%8E%A5%20CDP%20%E6%9D%A5%E7%90%86%E8%A7%A3%20Chrome%20DevTools%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"45.手动对接 CDP 来理解 Chrome DevTools 实现原理",headingTitle:"45.手动对接 CDP 来理解 Chrome DevTools 实现原理",frontmatter:{}}}}]);