"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31599"],{469926:function(e,n,o){o.r(n),o.d(n,{default:()=>d});var s=o(552676),t=o(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",strong:"strong"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"13编译器ast-是如何被转换成-js-ast-的",children:["13.编译器：AST 是如何被转换成 JS AST 的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13编译器ast-是如何被转换成-js-ast-的",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一小节我们介绍完了关于模版是如何编译成 ",(0,s.jsx)(n.code,{children:"AST"})," 的结构的，接下来进入模版编译的第二步 ",(0,s.jsx)(n.code,{children:"transform"}),"，",(0,s.jsx)(n.code,{children:"transform"})," 的目标是为了生成 ",(0,s.jsx)(n.code,{children:"JavaScript AST"}),"。因为渲染函数是一堆 ",(0,s.jsx)(n.code,{children:"js"})," 代码构成的，编译器最终产物就是渲染函数，所以理想中的 ",(0,s.jsx)(n.code,{children:"AST"})," 应该是用来描述渲染函数的 ",(0,s.jsx)(n.code,{children:"JS"})," 代码。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么接下来，我们一起看看 ",(0,s.jsx)(n.code,{children:"transfrom"})," 转换的实现细节吧！"]}),"\n",(0,s.jsxs)(n.h2,{id:"transform",children:["Transform",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#transform",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function baseCompile(template, options) {\n  const isModuleMode = options.mode === 'module'\n  // 用来标记代码生成模式\n  const prefixIdentifiers =\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\n  // 获取节点和指令转换的方法\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset()\n  // AST 转换成 Javascript AST\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || [])\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {}\n      )\n    })\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中第一个参数 ",(0,s.jsx)(n.code,{children:"prefixIdentifiers"})," 是用于标记前缀代码生成模式的。举个例子，以下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<div>\n  {{msg}}\n</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"module"})," 模式下，生成的渲染函数是一个通过 ",(0,s.jsx)(n.code,{children:"with(_ctx) { ... }"})," 包裹后的，大致为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'return function render(_ctx) {\n  with (_ctx) {\n    const { toDisplayString, openBlock, createElementBlock } = Vue\n    return (openBlock(), createElementBlock("div", null, toDisplayString(msg), 1 /* TEXT */))\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["而在 ",(0,s.jsx)(n.code,{children:"function"})," 模式下，生成的渲染函数中的动态内容，则会被转成 ",(0,s.jsx)(n.code,{children:"_ctx.msg"})," 的模式："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { toDisplayString, openBlock, createElementBlock } from "vue"\nexport function render(_ctx) {\n  return (openBlock(), createElementBlock("div", null, toDisplayString(ctx.msg), 1 /* TEXT */))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["而参数 ",(0,s.jsx)(n.code,{children:"nodeTransforms"})," 和 ",(0,s.jsx)(n.code,{children:"directiveTransforms"})," 对象则是由 ",(0,s.jsx)(n.code,{children:"getBaseTransformPreset"})," 生成的一系列预设函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getBaseTransformPreset(prefixIdentifiers) {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformFor,\n      transformExpression,\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nodeTransforms"})," 涵盖了特殊节点的转换函数，比如文本节点、",(0,s.jsx)(n.code,{children:"v-if"})," 节点等等， ",(0,s.jsx)(n.code,{children:"directiveTransforms"})," 则包含了一些指令的转换函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["这些转换函数的细节，不是这里的核心，我们将在下文进行几个重点函数的介绍，其余的有兴趣的小伙伴可以自行翻阅 ",(0,s.jsx)(n.code,{children:"vue3"})," 源码查看实现的细节。接下来我们将核心介绍 ",(0,s.jsx)(n.code,{children:"transform"})," 函数的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function transform(root, options) {\n  // 生成 transform 上下文\n  const context = createTransformContext(root, options)\n  // 遍历处理 ast 节点\n  traverseNode(root, context)\n  // 静态提升\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  // 创建根代码生成节点\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // 最终确定元信息\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"1-生成-transform-上下文",children:["1. 生成 transform 上下文",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-生成-transform-上下文",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在正式开始 ",(0,s.jsx)(n.code,{children:"transform"})," 前，需要创建生成一个 ",(0,s.jsx)(n.code,{children:"transformContext"}),"，即 ",(0,s.jsx)(n.code,{children:"transform"})," 上下文。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export function createTransformContext(root, TransformOptions) {\n  const context = {\n    // 选项配置\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    // ...\n    // 状态数据\n    root,\n    helpers: new Map(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    // ....\n    // 一些函数\n    helper(name) {},\n    removeHelper(name) {},\n    helperString(name) {},\n    replaceNode(node) {},\n    removeNode(node) {},\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {},\n    removeIdentifiers(exp) {},\n    hoist(exp) {},\n    cache(exp, isVNode = false) {}\n  }\n\n  return context\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到这个上下文对象 ",(0,s.jsx)(n.code,{children:"context"})," 内主要包含三部分：",(0,s.jsx)(n.code,{children:"tansform"})," 过程中的一些配置属性，一些状态数据，以及在 ",(0,s.jsx)(n.code,{children:"transform"})," 过程中可能会调用的一些辅助函数。"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-遍历ast节点",children:["2. 遍历AST节点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-遍历ast节点",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function traverseNode(node, context) {\n  context.currentNode = node\n  // 节点转换函数\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    // 执行节点转换函数，返回得到一个退出函数\n    const onExit = nodeTransforms[i](node, context)\n    // 收集所有退出函数\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // 节点被移除\n      return\n    } else {\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      if (!context.ssr) {\n        // context 中 helpers 添加 CREATE_COMMENT 辅助函数\n        context.helper(CREATE_COMMENT)\n      }\n      break\n    case NodeTypes.INTERPOLATION:\n      // context 中 helpers 添加 TO_DISPLAY_STRING 辅助函数\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING)\n      }\n      break\n    case NodeTypes.IF:\n      // 递归遍历每个分支节点\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseNode(node.branches[i], context)\n      }\n      break\n    case NodeTypes.IF_BRANCH:\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      // 遍历子节点\n      traverseChildren(node, context)\n      break\n  }\n  \n  context.currentNode = node\n  // 执行上面收集到的所有退出函数\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"traverseNode"})," 递归的遍历 ",(0,s.jsx)(n.code,{children:"ast"})," 中的每个节点，然后执行一些转换函数 ",(0,s.jsx)(n.code,{children:"nodeTransforms"}),"，这些转换函数就是我们上面介绍的通过 ",(0,s.jsx)(n.code,{children:"getBaseTransformPreset"})," 生成的对象，值得注意的是：",(0,s.jsx)(n.code,{children:"nodeTransforms"})," 返回的是一个数组，说明这些转换函数是有序的，顺序代表着优先级关系，比如对于",(0,s.jsx)(n.code,{children:"if"}),"的处理优先级就比 ",(0,s.jsx)(n.code,{children:"for"})," 要高，因为如果条件不满足很可能有大部分内容都没必要进行转换。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，如果转换函数执行完成后，有返回退出函数 ",(0,s.jsx)(n.code,{children:"onExit"})," 的话，那么会被统一存贮到 ",(0,s.jsx)(n.code,{children:"exitFns"})," 当中，在所有字节点处理完成统一执行调用。"]}),"\n",(0,s.jsxs)(n.h3,{id:"transformelement",children:["transformElement",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#transformelement",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["根据上文我们知道了对节点进行处理，就是通过一系列函数对节点的的各个部分的内容分别进行处理。鉴于这些函数很多内容也很庞杂，我们拿其中一个函数",(0,s.jsx)(n.code,{children:"transformElement"}),"进行分析，理解对",(0,s.jsx)(n.strong,{children:"AST"}),"的转化过程："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const transformElement = (node, context) => {\n  // 这里就是返回了一个退出函数\n  return function postTransformElement() {\n    // ...\n    node.codegenNode = createVNodeCall(\n      context,\n      vnodeTag,\n      vnodeProps,\n      vnodeChildren,\n      vnodePatchFlag,\n      vnodeDynamicProps,\n      vnodeDirectives,\n      !!shouldUseBlock,\n      false /* disableTracking */,\n      isComponent,\n      node.loc\n    )\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，",(0,s.jsx)(n.code,{children:"transformElement"})," 的核心目的就是通过调用",(0,s.jsx)(n.code,{children:"createVNodeCall"}),"函数获取 ",(0,s.jsx)(n.code,{children:"VNodeCall"})," 对象，并赋值给 ",(0,s.jsx)(n.code,{children:"node.codegenNode"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["到这里，我们就大致明白了，我们前面一直提到需要把 ",(0,s.jsx)(n.code,{children:"AST"})," 转成 ",(0,s.jsx)(n.code,{children:"JavaScript AST"}),"，实际上就是给 ",(0,s.jsx)(n.code,{children:"AST"})," 的",(0,s.jsx)(n.code,{children:"codegenNode"})," 属性赋值。接下来，我们接着看 ",(0,s.jsx)(n.code,{children:"createVNodeCall"})," 函数的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK)\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES)\n    }\n  }\n\n  return {\n    type: NodeTypes.VNODE_CALL,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    loc\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["该函数也非常容易理解，本质就是为了返回一个 ",(0,s.jsx)(n.code,{children:"VNodeCall"})," 对象，该对象是用来描述 ",(0,s.jsx)(n.code,{children:"js"})," 代码的。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里的函数 ",(0,s.jsx)(n.code,{children:"context.helper"})," 是会把一些 ",(0,s.jsx)(n.code,{children:"Symbol"})," 对象添加到 ",(0,s.jsx)(n.code,{children:"context.helpers Set"})," 的数据结构当中，在接下来的代码生成阶段，会判断当前 ",(0,s.jsx)(n.code,{children:"JS AST"})," 中是否存在 ",(0,s.jsx)(n.code,{children:"helpers"})," 内容，如果存在，则会根据 ",(0,s.jsx)(n.code,{children:"helpers"})," 中标记的 ",(0,s.jsx)(n.code,{children:"Symbol"})," 对象，来生成辅助函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来看一下之前的这样一个 ",(0,s.jsx)(n.code,{children:"demo"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  \x3c!-- 这是一段注释 --\x3e\n  <p>{{ msg }}</p>\n</template>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经过遍历",(0,s.jsx)(n.code,{children:"AST"}),"节点 ",(0,s.jsx)(n.code,{children:"traverseNode"})," 函数调用之后之后的结果大致如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": 0,\n  "children": [\n    {\n      "type": 1,\n      "ns": 0,\n      "tag": "p",\n      "tagType": 0,\n      "props": [],\n      "isSelfClosing": false,\n      "children": [],\n      "loc": {},\n      "codegenNode": {\n        "type": 13,\n        "tag": "\\"p\\"",\n        "children": {\n          "type": 5,\n          "content": {\n            "type": 4,\n            "isStatic": false,\n            "constType": 0,\n            "content": "msg",\n            "loc": {\n              "start": {},\n              "end": {},\n              "source": "msg"\n            }\n          },\n          "loc": {\n            "start": {},\n            "end": {},\n            "source": "{{ msg }}"\n          }\n        },\n        "patchFlag": "1 /* TEXT */",\n        "isBlock": false,\n        "disableTracking": false,\n        "isComponent": false,\n        "loc": {\n          "start": {},\n          "end": {},\n          "source": "<p>{{ msg }}</p>"\n        }\n      }\n    }\n  ],\n  "helpers": [],\n  "components": [],\n  "directives": [],\n  "hoists": [],\n  "imports": [],\n  "cached": 0,\n  "temps": 0,\n  "loc": {\n    "start": {},\n    "end": {},\n    "source": "\\n  <p>{{ msg }}</p>\\n"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，相比原节点，转换后的节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。"}),"\n",(0,s.jsxs)(n.h2,{id:"3-静态提升",children:["3. 静态提升",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-静态提升",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["经过上一步的遍历 ",(0,s.jsx)(n.code,{children:"AST"})," 节点后，我们接着来看一下静态提升做了哪些工作。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function hoistStatic(root, context) {\n  walk(\n    root,\n    context,\n    // 根节点是不可提升的\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hoistStatic"})," 核心调用的就是 ",(0,s.jsx)(n.code,{children:"walk"})," 函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function walk(node, context, doNotHoistNode = false) {\n  const { children } = node\n  // 记录那些被静态提升的节点数量\n  let hoistedCount = 0\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // 普通元素节点可以被提升\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      // 根据 doNotHoistNode 判断是否可以提升\n      // 设置 constantType 的值\n      const constantType = doNotHoistNode\n        ? ConstantTypes.NOT_CONSTANT\n        : getConstantType(child, context)\n      // constantType = CAN_SKIP_PATCH || CAN_HOIST || CAN_STRINGIFY\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\n        // constantType = CAN_HOIST || CAN_STRINGIFY\n        if (constantType >= ConstantTypes.CAN_HOIST) {\n          // 可提升状态中，codegenNode = PatchFlags.HOISTED\n          child.codegenNode.patchFlag =\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\n  \n          // 提升节点，将节点存储到 转换上下文context 的 hoist 数组中\n          child.codegenNode = context.hoist(child.codegenNode!)\n          // 提升节点数量自增 1\n          hoistedCount++\n          continue\n        }\n      } else {\n        // 动态子节点可能存在一些静态可提升的属性\n        const codegenNode = child.codegenNode!\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\n          // 判断 props 是否可提升\n          const flag = getPatchFlag(codegenNode)\n          if (\n            (!flag ||\n              flag === PatchFlags.NEED_PATCH ||\n              flag === PatchFlags.TEXT) &&\n            getGeneratedPropsConstantType(child, context) >=\n              ConstantTypes.CAN_HOIST\n          ) {\n            // 提升 props\n            const props = getNodeProps(child)\n            if (props) {\n              codegenNode.props = context.hoist(props)\n            }\n          }\n          // 将节点的动态 props 添加到转换上下文对象中\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\n          }\n        }\n      }\n    }\n\n    if (child.type === NodeTypes.ELEMENT) {\n      // 组件是 slot 的情况\n      const isComponent = child.tagType === ElementTypes.COMPONENT\n      if (isComponent) {\n        context.scopes.vSlot++\n      }\n      // 如果节点类型是组件，则进行递归判断操作\n      walk(child, context)\n      if (isComponent) {\n        context.scopes.vSlot--\n      }\n    } else if (child.type === NodeTypes.FOR) {\n      // 再循环节点中，只有一个子节点的情况下，不需要提升\n      walk(child, context, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        // 在 v-if 这样的条件节点上，如果也只有一个分支逻辑的情况\n        walk(\n          child.branches[i],\n          context,\n          child.branches[i].children.length === 1\n        )\n      }\n    }\n  }\n  // 预字符串化\n  if (hoistedCount && context.transformHoist) {\n    context.transformHoist(children, context, node)\n  }\n  // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["该函数看起来比较复杂，其实就是通过 ",(0,s.jsx)(n.code,{children:"walk"})," 这个递归函数，不断的判断节点是否符合可以静态提升的条件：只有普通的元素节点是可以提升的。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果满足条件，则会给节点的 ",(0,s.jsx)(n.code,{children:"codegenNode"})," 属性中的 ",(0,s.jsx)(n.code,{children:"patchFlag"})," 的值设置成 ",(0,s.jsx)(n.code,{children:"PatchFlags.HOISTED"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["接着执行转换器上下文中的 ",(0,s.jsx)(n.code,{children:"context.hoist"})," 方法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function hoist(exp) {\n  // 存储到 hoists 数组中\n  context.hoists.push(exp);\n  const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, true)\n  identifier.hoisted = exp\n  return identifier\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["该函数的作用就是将这个可以被提升的节点存储到转换上下文 ",(0,s.jsx)(n.code,{children:"context"})," 的 ",(0,s.jsx)(n.code,{children:"hoist"})," 数组中。这个数据就是用来存储那些可被提升节点的列表。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们再来说一下，为什么要做静态提升呢？ 如下模板所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<div>\n  <p>text</p>\n</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"在没有被提升的情况下其渲染函数相当于："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", null, [\n    _createElementVNode("p", null, "text")\n  ]))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["很明显，",(0,s.jsx)(n.code,{children:"p"}),"\xa0标签是静态的，它不会改变。但是如上渲染函数的问题也很明显，如果组件内存在动态的内容，当渲染函数重新执行时，即使\xa0",(0,s.jsx)(n.code,{children:"p"}),"\xa0标签是静态的，那么它对应的\xa0",(0,s.jsx)(n.code,{children:"VNode"}),"\xa0也会重新创建。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"所谓的 “静态提升”，就是将一些静态的节点或属性提升到渲染函数之外"}),"。如下面的代码所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "text", -1 /* HOISTED */)\nconst _hoisted_2 = [\n  _hoisted_1\n]\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", null, _hoisted_2))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这就实现了减少\xa0",(0,s.jsx)(n.code,{children:"VNode"}),"\xa0创建的性能消耗。"]}),"\n",(0,s.jsxs)(n.p,{children:["而这里的静态提升步骤生成的 ",(0,s.jsx)(n.code,{children:"hoists"}),"，会在 ",(0,s.jsx)(n.code,{children:"codegenNode"})," 会在生成代码阶段帮助我们生成静态提升的相关代码。"]}),"\n",(0,s.jsxs)(n.h3,{id:"预字符串化",children:["预字符串化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#预字符串化",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["注意到在 ",(0,s.jsx)(n.code,{children:"walk"})," 函数结束时，进行了静态提升节点的 ",(0,s.jsx)(n.code,{children:"预字符串化"}),"。什么是预字符串化呢？一起来看个示例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"<template>\n  <p></p>\n  ... 共 20+ 节点\n  <p></p>\n</template>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对于这样有大量静态提升的模版场景，如果不考虑 ",(0,s.jsx)(n.code,{children:"预字符串化"})," 那么生成的渲染函数将会包含大量的 ",(0,s.jsx)(n.code,{children:"createElementVNode"})," 函数：假设如上模板中有大量连续的静态的 ",(0,s.jsx)(n.code,{children:"p"})," 标签，此时渲染函数生成的结果如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'const _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, null, -1 /* HOISTED */)\n// ...\nconst _hoisted_20 = /*#__PURE__*/_createElementVNode("p", null, null, -1 /* HOISTED */)\nconst _hoisted_21 = [\n  _hoisted_1,\n  // ...\n  _hoisted_20,\n]\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", null, _hoisted_21))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createElementVNode"})," 大量连续性创建 ",(0,s.jsx)(n.code,{children:"vnode"})," 也是挺影响性能的，所以可以通过 ",(0,s.jsx)(n.code,{children:"预字符串化"})," 来一次性创建这些静态节点，采用 ",(0,s.jsx)(n.code,{children:"与字符串化"})," 后，生成的渲染函数如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const _hoisted_1 = /*#__PURE__*/_createStaticVNode("<p></p>...<p></p>", 20)\nconst _hoisted_21 = [\n  _hoisted_1\n]\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", null, _hoisted_21))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这样一方面降低了 ",(0,s.jsx)(n.code,{children:"createElementVNode"})," 连续创建带来的性能损耗，也降侧面减少了代码体积。关于 ",(0,s.jsx)(n.strong,{children:"预字符串化"})," 实现的细节函数 ",(0,s.jsx)(n.code,{children:"transformHoist"})," 有兴趣的小伙伴可以再去深入了解。"]}),"\n",(0,s.jsxs)(n.h2,{id:"4-创建根代码生成节点",children:["4. 创建根代码生成节点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-创建根代码生成节点",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["介绍完了静态提升后，我们还剩最后一个 ",(0,s.jsx)(n.code,{children:"createRootCodegen"})," 创建根代码生成节点，接下来一起看一下 ",(0,s.jsx)(n.code,{children:"createRootCodegen"})," 函数的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createRootCodegen(root, context) {\n  const { helper } = context\n  const { children } = root\n  if (children.length === 1) {\n    const child = children[0]\n    // 如果子节点是单个元素节点，则将其转换成一个 block\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      const codegenNode = child.codegenNode\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\n        makeBlock(codegenNode, context)\n      }\n      root.codegenNode = codegenNode\n    } else {\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // 如果子节点是多个节点，则返回一个 fragement 的代码生成节点\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\n    \n    root.codegenNode = createVNodeCall(\n      context,\n      helper(FRAGMENT),\n      undefined,\n      root.children,\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\n      undefined,\n      undefined,\n      true,\n      undefined,\n      false /* isComponent */\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，",(0,s.jsx)(n.code,{children:"Vue3"})," 中是可以在 ",(0,s.jsx)(n.code,{children:"template"})," 中写多个字节点的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>1</p>\n  <p>2</p>\n</template>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createRootCodegen"}),"，核心就是创建根节点的 ",(0,s.jsx)(n.code,{children:"codegenNode"})," 对象。所以当有多个子节点时，也就是 ",(0,s.jsx)(n.code,{children:"children.length > 1"})," 时，调用 ",(0,s.jsx)(n.code,{children:"createVNodeCall"})," 来创建一个新的 ",(0,s.jsx)(n.code,{children:"fragement"})," 根节点 ",(0,s.jsx)(n.code,{children:"codegenNode"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["否则，就代表着只有一个根节点，直接让根节点的 ",(0,s.jsx)(n.code,{children:"codegenNode"})," 等于第一个子节点的根节点的",(0,s.jsx)(n.code,{children:"codegenNode"}),"即可。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createRootCodegen"})," 完成之后，接着把 ",(0,s.jsx)(n.code,{children:"transform"})," 上下文在转换 ",(0,s.jsx)(n.code,{children:"AST"})," 节点过程中创建的一些变量赋值给 ",(0,s.jsx)(n.code,{children:"root"})," 节点对应的属性，这样方便在后续代码生成的过程中访问到这些变量。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"root.helpers = [...context.helpers.keys()]\nroot.components = [...context.components]\nroot.directives = [...context.directives]\nroot.imports = context.imports\nroot.hoists = context.hoists\nroot.temps = context.temps\nroot.cached = context.cached\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这里我们介绍了关于 ",(0,s.jsx)(n.code,{children:"transform"})," 相关的知识，再来回顾一下，",(0,s.jsx)(n.code,{children:"transform"})," 节点的核心功能就是语法分析阶段，把 ",(0,s.jsx)(n.code,{children:"AST"})," 节点做进一层转换，构造出语义化更强，信息更加丰富的 ",(0,s.jsx)(n.code,{children:"codegenCode"}),"。便于在下一小节 ",(0,s.jsx)(n.code,{children:"generate"})," 中使用。"]})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let d=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F13.%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9AAST%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%BD%AC%E6%8D%A2%E6%88%90%20JS%20AST%20%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Transform",id:"transform",depth:2},{text:"1. 生成 transform 上下文",id:"1-生成-transform-上下文",depth:2},{text:"2. 遍历AST节点",id:"2-遍历ast节点",depth:2},{text:"transformElement",id:"transformelement",depth:3},{text:"3. 静态提升",id:"3-静态提升",depth:2},{text:"预字符串化",id:"预字符串化",depth:3},{text:"4. 创建根代码生成节点",id:"4-创建根代码生成节点",depth:2},{text:"总结",id:"总结",depth:2}],title:"13.编译器：AST 是如何被转换成 JS AST 的？",headingTitle:"13.编译器：AST 是如何被转换成 JS AST 的？",frontmatter:{}}}}]);