"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["93405"],{260057:function(e,n,s){e.exports=s.p+"static/image/7f107170006483f071d16e3a9071bd84.4486adf8.webp"},509406:function(e,n,s){s.r(n),s.d(n,{default:()=>w});var r=s(552676),c=s(740453),a=s(260057);let l=s.p+"static/image/7d3af57ade8dfd378faf36fb503ae381.a4f4ac26.webp",d=s.p+"static/image/3c68565ba220419e9b3797f0e51c38f2.c7d73973.webp",i=s.p+"static/image/98f618af371c1d23781f59190c96242a.8d956b52.webp",t=s.p+"static/image/b5c47cfd1a6331670f54f5ba4d73cb73.e5a1fcfc.webp",o=s.p+"static/image/3f5b31654008728a9018d935c0ffa261.a84a14a1.webp",h=s.p+"static/image/3e9273b368bea789a4a4c2e84ab5d020.931c85c9.webp",p=s.p+"static/image/ca5b651a68b6c1c456c02d8b72da68aa.0857dc5f.webp",j=s.p+"static/image/4f835d1c2be9991a1a8aef9e56e6b93a.e05d921b.webp",x=s.p+"static/image/c98197db53882e960f8d41152ab45dc7.488fe172.webp",m=s.p+"static/image/bad561e8fabc37019277a07076c6cf34.9d84d5b7.webp",g=s.p+"static/image/9894b7d9c61358eb6ae4347527811c5a.6c65ffe0.webp",u=s.p+"static/image/9f09160669002cbdd17d9bb9d3316c28.c8300c5b.webp",b=s.p+"static/image/2ee11dc1a547a7ab8e52ea66db8d034d.7a4b1e71.webp",f=s.p+"static/image/ff17ed682dadd3f92db6351b1bb5797e.74ce6f8f.webp";function v(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",blockquote:"blockquote",strong:"strong",code:"code",pre:"pre",img:"img",h3:"h3",ul:"ul",li:"li",h4:"h4"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"4环境篇-动手搭建我们的简历平台",children:["4.环境篇-动手搭建我们的简历平台",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4环境篇-动手搭建我们的简历平台",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["前章节通过对 Electron 的介绍，想必你对它有了基础的了解，在阅读了",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962435230061821952",target:"_blank",rel:"noopener noreferrer",children:"需求功能设计与数据存储方案设计"}),"之后，也许在你的脑海中已经勾勒出了整个应用的整体结构，先不急！我们先打好基建，一步一步将项目环境搭建起来。"]}),"\n",(0,r.jsx)(n.p,{children:"本章节将会将 Electron 环境搭建起来，丢掉 CRA 脚手架，通过一步步的动手实践，并将 TypeScript、ESLint、Prettier 引入，最后搭起我们的 React 项目。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Electron 与 React 是独立的，并不互相影响，不要将其捆绑在一块"}),"。你可以通过此小节只搭建 Electron，然后结合自己喜欢的 React 环境（也许你更想用 CRA）"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"如果你不想做PC端，想做成 Web 端可以跳过 Electron 环节，直接进入第二阶段"}),"，⚠️ 请注意，PC 端和 Web 端会在 Webpack 的 target 属性处有所区别。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["\uD83E\uDDE8  如果你阅读完之后，对其中每一环节都已了解，但出于时间成本，想直接开箱即用，你可以通过项目地址的: ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/init-cli",target:"_blank",rel:"noopener noreferrer",children:"init-cli"}),"，完整配置的分支代码，可以基于此分支直接进行项目开发，代码拉取之后安装一下即可开发。"]})}),"\n",(0,r.jsxs)(n.h2,{id:"开发前必读electron-与-react-的关系",children:["开发前必读！Electron 与 React 的关系",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开发前必读electron-与-react-的关系",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["小伙伴们可能会有些困惑，",(0,r.jsx)(n.strong,{children:"到底 Electron 与 React 的关系是什么"}),"，在没搞清楚的情况下，贸然去开发实践，问题频发。为了在动手搭建之前，让我们来捋清楚，这些讲不清道不明的关系。"]}),"\n",(0,r.jsxs)(n.p,{children:["抛开 Electron，纯 Web 的开发，那么大家都比较熟悉，最核心的永远是 ",(0,r.jsx)(n.code,{children:"HTML/CSS/JS"}),"，所谓的 React、Vue、Angular 都是框架，那些 Less、Sass、Stylus 等都是 CSS 的“衍生物”。"]}),"\n",(0,r.jsx)(n.p,{children:"在没有这些框架、预处理库出现之前，我们写代码，均是这样的"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    // \uD83D\uDC47 加载a.js 和 a.css\n    <script type="text/javascript" src="./a.js"><\/script>\n    <link rel="stylesheet" type="text/css" href="a.css"></link>\n  </head>\n  <body>\n    <div id="root"></div>\n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// a.js\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// a.css\n"})}),"\n",(0,r.jsx)(n.p,{children:"相比大家对此并不陌生，那么当这些框架出现之后，有什么变化吗？万变不离其宗，如 Vue、React 等框架，经过 Babel 编译、Webpack 打包之后，最终的产物是 JS。既然是 JS，那么我们 HTML 如何加载 JS？你细品细品"}),"\n",(0,r.jsx)(n.p,{children:"再说说 Less、Sass 等，经过 Webpakc 的 Loader 处理之后，最终产物是什么？CSS，既然是 CSS，那么我们 HTML 如何加载 CSS？你再细品细品"}),"\n",(0,r.jsx)(n.p,{children:"所以说，万变不离其宗，下面是来自掘金的 HTML 所加载的文件，再仔细品尝"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"传统的 Web 开发就是写完代码，Ctrl + S 保存，刷新页面，如果你用 React 框架进行开发，那么你需要每次改动代码之后，进行一次 build 打包，将打包之后的 JS 文件，在 HTML 页面中重新加载，刷新页面，看到最终效果。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["强烈建议你搭配",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6961585436967829516",target:"_blank",rel:"noopener noreferrer",children:"第二章-Electron 认识"}),"与",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962895331730620423",target:"_blank",rel:"noopener noreferrer",children:"彩蛋篇-Webpack 认识"}),"一起阅读，效果更佳。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["一来二去，你怕是会口喷芬芳，于是我们都会在本地起一个 dev-server 服务，具体表现就是：在浏览器中通过 ",(0,r.jsx)(n.code,{children:"IP + Port"}),"，就能访问到我们的应用页面，比如 ",(0,r.jsx)(n.code,{children:"http://127.0.0.1:7001"})," 就能本地访问简历平台。"]}),"\n",(0,r.jsx)(n.p,{children:"这就是我们的 Web 开发以及在浏览器上如何访问、调试。"}),"\n",(0,r.jsxs)(n.p,{children:["想明白之后，我们继续往下看，到底 Electron 是什么玩意，它跟 React 有什么关系？如果你认真阅读了",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6961585436967829516",target:"_blank",rel:"noopener noreferrer",children:"第二章-Electron 认识"}),"，应该知道，Electron 是一个让你采用 Web 技术去开发原生应用的框架。"]}),"\n",(0,r.jsx)(n.p,{children:"这么说有些抽象，我举个例子"}),"\n",(0,r.jsx)(n.p,{children:"你是一位做中餐的厨师（纯 Web 技术），你想开一个快餐店（做一个原生应用），但你没有钱（自身不具备原生能力）也没人手（自身不具备多端能力），这时候天降正义，有个大老板（Electron 框架）跟你说，你尽管开，其他问题我帮你搞定（所有原生问题、多端问题我都帮你解决），你很高兴，乐呵乐呵就同意了（安装了 Electron），接着大老板拍了拍手，叫了一个管家（主进程）过来，指了指你说，在我们的商场里给这位厨师分配一个档口铺面（创建一个渲染进程，对应一个浏览器窗口），于是你在这个档口铺面（渲染进程）中，利用你精通中餐技术（Web 技术）大展身手，大老板还对你说，我们商场里的公共财产（Electron API、NodeJS 模块），大部分情况下，你都能无条件使用（渲染进程只能用部分 ElectronAPI）。"}),"\n",(0,r.jsx)(n.p,{children:"通过这么一个通俗易懂的例子，想必大家对于 Electron 和 Web 技术已经分清楚关系了。在创建渲染进程时，会对应一个浏览器窗口，这个浏览器窗口，你可以理解为 Chrome 浏览器中的一个 Tab 标签。这里就会涉及到浏览器的进程模型，不再多说。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"暂且我们将 Chrome 浏览器的一个 Tab 标签比做一个渲染进程"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"那么在你点击 “+” 号新增 Tab 时，本质上是新增一个渲染进程。如果将其比作 Electron，等价于在 Electron 中新增了一个渲染进程，并对应了一个浏览器窗口。从展示形式上看，Chrome 浏览器是一个窗口放多个 Tab；而在 Electron 看到的是，多个窗口的对应多个 Tab（一个窗口对应一个 Tab）"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"有小伙伴问，为什么我不能在 Electron 生成的浏览器窗口中新增 Tab，你不是说 Electron 继承了 Chromium 架构吗？这问题我想你看了上段讲述之后，再自己思考思考"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["再说回来，在 Chrome 中，我们如何显示 HTML 页面？通过链接 URL 的形式，比如 ",(0,r.jsx)(n.code,{children:"http/https"}),"，或者 ",(0,r.jsx)(n.code,{children:"file://"})," 。那么在 Electorn 中，也是如此，每一个渲染进程的入口文件就是一个 HTML 或者 URL 链接，这也就是我们代码中都会这么写"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Electron 主进程\nconst mainWindow = new BrowserWindow({\n  width: 1200,\n  height: 800,\n  webPreferences: {\n    devTools: true,\n    nodeIntegration: true,\n  },\n});\nif (isDev()) {\n  mainWindow.loadURL(`http://127.0.0.1:7001/index.html`);\n} else {\n  mainWindow.loadURL(`file://${path.join(__dirname, '../dist/index.html')}`);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["到此关系应该很直白了，小伙伴们应该都能明白，不明白的就多看两遍。最后一点，有小伙伴问，能否在 Chrome 中通过 ",(0,r.jsx)(n.code,{children:"http://127.0.0.1:7001/index.html"})," 访问应用页面呢？答案是：不一定可以！因为 Electron 对于渲染进程赋予了部分原生能力，比如说你可以调用 Electron API、NodeJS 模块，这些只有在 Electern 生成的浏览器窗口中才能正常访问不报错。如果你跑到 Chrome 浏览器去访问，Chrome 浏览器能识别 Node 中的 fs 是什么吗？path 模块干什么用 Chrome 知道吗？",(0,r.jsx)(n.strong,{children:"就好比我给你一张广州市 A 店的会员卡，你非跑去 B 店大声嚷囊说打折，人家能愿意吗？"})]}),"\n",(0,r.jsx)(n.p,{children:"什么时候可以在 Chrome 浏览器访问？就是你的 React 部分代码中，没有 ElectronAPI 相关代码，没有 NodeJS 相关代码，这时候就可以了。"}),"\n",(0,r.jsxs)(n.h2,{id:"第一阶段electron-搭建",children:["第一阶段：Electron 搭建",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一阶段electron-搭建",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"官方对于应用搭建有详细的文档说明，下面基于官方文档，讲解一下 Electron 的搭建"}),"\n",(0,r.jsxs)(n.h3,{id:"1-安装-node-环境",children:["1. 安装 Node 环境",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-安装-node-环境",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在搭建 Electron 应用前，请先确保你的 ",(0,r.jsx)(n.a,{href:"https://nodejs.org/en/download/",target:"_blank",rel:"noopener noreferrer",children:"Node.js"})," 已经安装，接下来在终端输入命令"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"node -v\nnpm -v\n"})}),"\n",(0,r.jsx)(n.p,{children:"这两个命令应输出了 Node.js 和 npm 的版本信息。 如果这两个命令都执行成功，那就接着往下走"}),"\n",(0,r.jsxs)(n.h3,{id:"2-安装-electron",children:["2. 安装 Electron",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-安装-electron",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们创建一个新文件夹，名为 ",(0,r.jsx)(n.code,{children:"visResumeMook"}),"，进入文件夹并安装 Electron"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"由于这个项目在写小册之前就已经开发，所以如果是最新版本，会出现一些兼容问题，所以这里先限定 ^11.1.1 版本"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir visResumeMook\ncd visResumeMook\nnpm install electron@11.1.1\n"})}),"\n",(0,r.jsx)(n.p,{children:"⚠️ 提示：由于网络问题，往往安装 Electron 会很慢，此时可以考虑换个淘宝源"}),"\n",(0,r.jsxs)(n.h3,{id:"3-基本框架结构",children:["3. 基本框架结构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-基本框架结构",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面说了，Electron 是基于 Chromium + Node.js 开发的，也就是说 Electron 本质上就是一个 Node.js 应用。这意味着您的 Electron 应用程序的起点将是一个 package.json 文件。"}),"\n",(0,r.jsxs)(n.p,{children:["我们创建一个 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件，并且创建主进程脚本 ",(0,r.jsx)(n.code,{children:"electron.js"}),"，该脚本就是应用程序的入口。为了区分主进程模块和渲染进程模块，我以文件夹形式进行区分。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"├── visResumeMook\n│ ├── app\n│ │ ├── main      // 主进程模块\n│ │ │    ├── electron.js\n│ │ │    └── index.html\n│ │ ├── renderer  // 渲染进程模块\n│ │ └──\n│ ├── package.json\n│ └──\n└──\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-编写-packagejson",children:["4. 编写 package.json",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-编写-packagejson",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"编写一下我们的 package.json 配置。我们将应用程序的入口文件配置为主进程脚本"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "visResumeMook",\n  "version": "0.0.1",\n  "author": "彭道宽",\n  "description": "从0到1实现一款轻巧适用的简历平台桌面应用。",\n  "main": "./app/main/electron.js",\n  "scripts": {\n    "start:main": "electron ./app/main/electron.js",\n    "install:electron": "ELECTRON_MIRROR=https://cdn.npm.taobao.org/dist/electron/ npm install electron"\n  },\n  "dependencies": {\n    "electron": "^11.1.1"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"5-定义-html",children:["5. 定义 html",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-定义-html",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们编写创建一个 HTML，等会加载此页面"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>VisResumeMook</title>\n  </head>\n  <body>\n    <div id="root">简历平台应用搭建起来啦！</div>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"6-编写主进程",children:["6. 编写主进程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-编写主进程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在主进程脚本中，通过 ",(0,r.jsx)(n.code,{children:"BrowserWindow"})," 创建浏览器窗口（也就是一个渲染进程），你可以将其看成浏览器的一个 Tab。请注意 ",(0,r.jsx)(n.code,{children:"BrowserWindow"})," 还有一个配置参数叫做 webPreferences，我们需要将其选项中的 ",(0,r.jsx)(n.code,{children:"nodeIntegration"})," 设置为 true，这样我们才能在渲染进程中就能使用 node。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/**\n * @desc electron 主入口\n */\nconst path = require('path');\nconst { app, BrowserWindow } = require('electron');\n\nfunction createWindow() {\n  // 创建浏览器窗口\n  const mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      nodeIntegration: true, // 注入node模块\n    },\n  });\n\n  mainWindow.loadFile('index.html');\n}\n\napp.whenReady().then(() => {\n  createWindow();\n  app.on('activate', function () {\n    if (BrowserWindow.getAllWindows().length === 0) createWindow();\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"7-启动应用程序",children:["7. 启动应用程序",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-启动应用程序",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["最后我们执行 ",(0,r.jsx)(n.code,{children:"npm run start:main"}),"，就能看到我们搭建的简历应用啦～"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"最后我们看看文件结构"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["\uD83E\uDDE8 第一阶段的代码对应 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/electron-init",target:"_blank",rel:"noopener noreferrer",children:"electron-init"})]}),"\n",(0,r.jsxs)(n.h2,{id:"第二阶段react-搭建",children:["第二阶段：React 搭建",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二阶段react-搭建",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"由于这个项目在写小册之前就已经开发，大版本升级肯定会出现一些兼容问题，为此，以目前的版本为主"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来我们通过动手实践，一步步来搭建我们的 React 项目，如果你觉得繁琐，也可以通过 CRA 搭建，或者用其他脚手架生成。"}),"\n",(0,r.jsxs)(n.h3,{id:"1-安装-react",children:["1. 安装 React",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-安装-react",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们打开终端，此时先安装 ",(0,r.jsx)(n.code,{children:"React"}),"，并且安装它相应的兄弟姐妹"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install react@17.0.2\nnpm install react-router@5.2.0 react-router-dom@5.2.0 react-dom@17.0.2\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-安装-babel",children:["2. 安装 Babel",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-安装-babel",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接着安装一下 ",(0,r.jsx)(n.code,{children:"Babel"}),"，它是 JS 编译器，能将 ES6 代码转成 ES5，让我们使用最近的语言特性，而不需要担心兼容性的问题。关于 ",(0,r.jsx)(n.code,{children:"install"})," 的库，接下来会讲其作用"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @babel/polyfill@7.12.1 --save\nnpm install @babel/core@7.14.3 @babel/cli@7.14.3 --save-dev\nnpm install @babel/preset-env@7.14.2 @babel/preset-react@7.13.13 @babel/preset-typescript@7.13.0 --save-dev\n\nnpm install @babel/plugin-transform-runtime@7.14.3 --save-dev\nnpm install @babel/plugin-transform-modules-commonjs@7.14.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["安装完成之后，根据 ",(0,r.jsx)(n.a,{href:"https://babeljs.io/docs/en/usage#overview",target:"_blank",rel:"noopener noreferrer",children:"Babel 官网"}),"的教程，我们创建 ",(0,r.jsx)(n.code,{children:"babel.config.js"}),"，配置一下我们常用的插件 plugins 和 预设值 presets"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  presets: [\n    '@babel/preset-env', // \uD83D\uDC49 根据配置的目标浏览器或者运行环境，选择对应的语法包，从而将代码进行转换\n    '@babel/preset-react', // \uD83D\uDC49 react 语法包，让我们可以使用 React ES6 Class Component 的写法，支持JSX、TSX语法格式\n    '@babel/preset-typescript', // \uD83D\uDC49 https://github.com/babel/babel/issues/10570\n  ],\n  plugins: [\n    '@babel/plugin-transform-runtime', // \uD83D\uDC49 官方提供的插件，作用是减少冗余的代码\n    [\n      '@babel/plugin-transform-modules-commonjs', // \uD83D\uDC49 将 ECMAScript modules 转成 CommonJS.\n      {\n        allowTopLevelThis: true,\n        loose: true,\n        lazy: true,\n      },\n    ],\n  ],\n};\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-安装-webpack",children:["3. 安装 Webpack",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-安装-webpack",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\uD83C\uDF08 如果你对 Webpack 还存在疑问，强烈建议你看一下",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962895331730620423",target:"_blank",rel:"noopener noreferrer",children:"彩蛋篇-Webpack基础介绍与两大利器"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["我们安装一下 ",(0,r.jsx)(n.code,{children:"Webpack"}),"，关于它的",(0,r.jsx)(n.code,{children:"传奇"}),"故事和核心灵魂已在前边章节有介绍，忘记了的小伙伴可以回去再看一遍。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install webpack@4.44.1 --save-dev\nnpm install webpack-cli@3.3.12 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们期望监听文件的变化，能够自动刷新网页，做到实时预览，而不是改动一个字母，一个文字都需要重新打包。业界较为成熟的解决方案是通过：",(0,r.jsx)(n.code,{children:"webpack-dev-server"})," 插件，OK，我们安装它。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install webpack-dev-server@3.11.2 --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"对于主进程和渲染进程来讲，webpack的配置是会存在差异的。比如渲染进程可能需要 less-loader、htmlWebpackPlugins 等“专属”配置，而这些配置对于主进程来讲，是无用的。"}),"\n",(0,r.jsxs)(n.p,{children:["存在差异的同时又会有相同点，比如 alias 别名配置等，当我们不采用 webpack-merge 时，会导致每份配置会存在重复的“配置”代码。其次在 dev 和 prod 环境下，配置会存在一些小差别，这时我们代码中会充斥着一些三元运算符来判断环境。",(0,r.jsx)(n.strong,{children:"最后的结果为每一份配置的可读性相对较差"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"为此我们通过 webpack-merge 插件进行处理（\uD83D\uDC49 评论区有解答）"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install webpack-merge --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们不想每次打包都需要手动修改 HTML 中的文件引用，并且期望采用自己写的 HTML 文件为模版，生成打包之后的入口 HTML，为此我们采用 ",(0,r.jsx)(n.code,{children:"html-webpack-plugin"})," 插件进行处理。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"npm install html-webpack-plugin@4.3.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["因为每次打包的文件会不同，我们需要先删除之前的 dist 文件，再重新打包，为此我们可以通过 ",(0,r.jsx)(n.code,{children:"clean-webpack-plugin"})," 进行解决"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install clean-webpack-plugin --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["由于 Babel 用于编译，Webpack 用于打包输出，两者各司其职，我们通过 ",(0,r.jsx)(n.code,{children:"babel-loader"})," 打通他们的联系。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install babel-loader --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在上面都安装好相关库之后，接下来到动手环节，首先我们创建一个 ",(0,r.jsx)(n.code,{children:"webpack"})," 文件夹，专门存放 webpack 相关配置，这里主要分为三个文件："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"webpack.base.js"}),"：基础公共配置"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"webpack.main.dev.js"}),"：主进程开发环境配置"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"webpack.render.dev.js"}),"：渲染进程开发环境配置"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"31-webpackbasejs",children:["3.1 webpack.base.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-webpackbasejs",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们先来创建 ",(0,r.jsx)(n.code,{children:"webpack.base.js"})," 基础公共配置文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const path = require('path');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n    alias: {\n      '@src': path.join(__dirname, '../', 'app/renderer'),\n    },\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin()],\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["解读一下这段代码，Webpack 在启动后会从配置的入口模块出发，找到所有依赖的模块，",(0,r.jsx)(n.code,{children:"resolve"})," 配置 Webpack 如何寻找模块所对应的文件。我们配置了 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/resolve/#resolveextensions",target:"_blank",rel:"noopener noreferrer",children:"extensions"}),"，表示在导入语句中没带文件后缀时，Webpack 会自动带上后缀去尝试访问文件是否存在。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们配置中，配置了 ",(0,r.jsx)(n.code,{children:"extensions: ['.js', '.jsx', '.ts', '.tsx']"}),"，意味着当遇到 ",(0,r.jsx)(n.code,{children:"import A from './A'"})," 时，会先寻找 A.js、找不到就去找 ",(0,r.jsx)(n.code,{children:"A.jsx"}),"，按照规则找，最后还是找不到，就会报错。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/resolve/#resolvealias",target:"_blank",rel:"noopener noreferrer",children:"alias"})," 代表别名，因为我们经常写 ",(0,r.jsx)(n.code,{children:"import A from '../../../../../A'"}),"这种导入路径，特别恶心，所以通过配置别名处理。关于 Loader，我们前边小节已介绍，它就是模块打包方案，上述代码即表示：当匹配到 ",(0,r.jsx)(n.code,{children:"/\\.(js|jsx|ts|tsx)$/"})," 文件时，使用 ",(0,r.jsx)(n.code,{children:"babel-loader"})," 去处理一下。"]}),"\n",(0,r.jsxs)(n.h4,{id:"32-webpackmaindevjs",children:["3.2 webpack.main.dev.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-webpackmaindevjs",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们看看主进程的配置，新增 ",(0,r.jsx)(n.code,{children:"webpack.main.dev.js"})," 文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const path = require('path');\nconst baseConfig = require('./webpack.base.js');\nconst webpackMerge = require('webpack-merge');\n\nconst mainConfig = {\n  entry: path.resolve(__dirname, '../app/main/electron.js'),\n  target: 'electron-main',\n  output: {\n    filename: 'electron.js',\n    path: path.resolve(__dirname, '../dist'),\n  },\n  devtool: 'inline-source-map',\n  mode: 'development',\n};\n\nmodule.exports = webpackMerge.merge(baseConfig, mainConfig);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["解读一下这段代码，我们定义入口文件为 ",(0,r.jsx)(n.code,{children:"/app/main/electron.js"}),"，并且定义打包出来的文件目录为 dist，文件名为 electron.js。"]}),"\n",(0,r.jsxs)(n.p,{children:["需要注意的一点是：",(0,r.jsx)(n.strong,{children:"由于 JS 的应用场景日益增长，从浏览器到 Node，运行在不同环境下的 JS 代码存在一些差异。target 配置项可以让 Webpack 构建出不同运行环境的代码"})]}),"\n",(0,r.jsxs)(n.p,{children:["关于 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/target/#target",target:"_blank",rel:"noopener noreferrer",children:"target 的可选项"}),"，可从官网查阅，这里我们将其配置成 ",(0,r.jsx)(n.code,{children:"electron-main"}),"，至于主进程的 plugins，我们定义了一些构建变量。最后通过 webpack-merge 合并导出一份完整的配置。"]}),"\n",(0,r.jsxs)(n.h4,{id:"33-webpackrenderdevjs",children:["3.3 webpack.render.dev.js",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-webpackrenderdevjs",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在说配置之前，我们先来创建一个渲染进程对应的代码文件夹。我们在 ",(0,r.jsx)(n.code,{children:"app"})," 文件夹下新增一个名为 ",(0,r.jsx)(n.code,{children:"renderer"})," 文件夹。"]}),"\n",(0,r.jsxs)(n.p,{children:["回顾一下之前 Electron 部分是不是有一个 ",(0,r.jsx)(n.code,{children:"index.html"})," 文件，我们我们将其移动到 ",(0,r.jsx)(n.code,{children:"renderer"})," 文件夹下，并修改它"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>VisResumeMook</title>\n    <style>\n      * {\n        margin: 0;\n      }\n    </style>\n  </head>\n  <body>\n    <div id="root"></div>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["接着我们在 ",(0,r.jsx)(n.code,{children:"renderer"})," 下创建一个 React 的 ",(0,r.jsx)(n.code,{children:"app.jsx"})," 文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { HashRouter as Router, Route, Switch } from 'react-router-dom';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\">\n          <div>可视化简历平台</div>\n          <div>这是 Electron + React </div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们再来修改一下渲染进程的相关配置，新增 ",(0,r.jsx)(n.code,{children:"webpack.render.dev.js"})," 文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const path = require('path');\nconst webpackMerge = require('webpack-merge');\nconst baseConfig = require('./webpack.base.js');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nconst devConfig = {\n  mode: 'development',\n  entry: {\n    // \uD83D\uDC47 对应渲染进程的 app.jsx 入口文件\n    index: path.resolve(__dirname, '../app/renderer/app.jsx'),\n  },\n  output: {\n    filename: '[name].[hash].js',\n    path: path.resolve(__dirname, '../dist'),\n  },\n  target: 'electron-renderer',\n  devtool: 'inline-source-map',\n  devServer: {\n    contentBase: path.join(__dirname, '../dist'),\n    compress: true,\n    host: '127.0.0.1', // webpack-dev-server启动时要指定ip，不能直接通过localhost启动，不指定会报错\n    port: 7001, // 启动端口为 7001 的服务\n    hot: true,\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      // \uD83D\uDC47 以此文件为模版，自动生成 HTML\n      template: path.resolve(__dirname, '../app/renderer/index.html'),\n      filename: path.resolve(__dirname, '../dist/index.html'),\n      chunks: ['index'],\n    }),\n  ],\n};\n\nmodule.exports = webpackMerge.merge(baseConfig, devConfig);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["解读一下这段代码，以 ",(0,r.jsx)(n.code,{children:"/app/renderer/app.jsx"})," 为入口，并配置了本地开发 devServer，通过 ",(0,r.jsx)(n.code,{children:"HtmlWebpackPlugin"})," 自动生成一份以 ",(0,r.jsx)(n.code,{children:"/app/renderer/index.html"})," 为模版的 HTML 文件。注意此时的 ",(0,r.jsx)(n.strong,{children:"target"}),"是针对 Electron 渲染进程。最后通过 ",(0,r.jsx)(n.code,{children:"webpack-merge"})," 合并导出一份完整配置。"]}),"\n",(0,r.jsxs)(n.h3,{id:"5-electron-与-react-结合起来",children:["5. Electron 与 React 结合起来",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-electron-与-react-结合起来",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"对于 Webpack 相关配置已经搭建完毕，我们来看看现在我们的文件目录都有哪些？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们让 Electron 和 React 结合起来，前面讲到，Electron 可以理解为页面添加了一个壳，由于我们将主进程中的 ",(0,r.jsx)(n.code,{children:"index.html"})," 移到了渲染进程，所以我们需要修改一下 ",(0,r.jsx)(n.code,{children:"electron.js"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/**\n * @desc electron 主入口\n */\nimport path from 'path';\nimport { app, BrowserWindow } from 'electron';\n\nfunction isDev() {\n  // \uD83D\uDC49 还记得我们配置中通过 webpack.DefinePlugin 定义的构建变量吗\n  return process.env.NODE_ENV === 'development';\n}\n\nfunction createWindow() {\n  // 创建浏览器窗口\n  const mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      devTools: true,\n      nodeIntegration: true,\n    },\n  });\n\n  if (isDev()) {\n    // \uD83D\uDC47 看到了吗，在开发环境下，我们加载的是运行在 7001 端口的 React\n    mainWindow.loadURL(`http://127.0.0.1:7001`);\n  } else {\n    mainWindow.loadURL(`file://${path.join(__dirname, '../dist/index.html')}`);\n  }\n}\n\napp.whenReady().then(() => {\n  createWindow();\n  app.on('activate', function () {\n    if (BrowserWindow.getAllWindows().length === 0) createWindow();\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["\uD83C\uDF89 接着进入 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件中，修改一下启动脚本命令，添加渲染进程的启动方式"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"scripts": {\n    "start:main": "webpack --config ./webpack/webpack.main.dev.js && electron ./dist/electron.js",\n    "start:render": "webpack-dev-server --config ./webpack/webpack.render.dev.js"\n  },\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"6-跑起来",children:["6. 跑起来",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-跑起来",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们开两个终端，一个跑 ",(0,r.jsx)(n.code,{children:"npm run start:render"}),"，另一个跑 ",(0,r.jsx)(n.code,{children:"npm run start:main"}),"，看看结果"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"请注意，这里是同时开两个终端，不是先跑一个，再跑另一个。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"\uD83D\uDC4F 不出意外，结果很棒，Electron 和 React 这环境终于打通！"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["如果出现报错：",(0,r.jsx)(n.code,{children:"Uncaught ReferenceError: require is not defined"}),"，请检查你是否在主进程中添加这行代码，如果添加了，请确保你搭建项目的 Electron 与本应用的版本一致(当前项目的 Electron@^11.1.1)"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"请自检查一下你的版本是否正确，进入 node_modules，找到 electron，看看 package.json 中的 version 是否是 11.1.1。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 创建浏览器窗口\n   const mainWindow = new BrowserWindow({\n     // ... \n     webPreferences: {\n       // \uD83D\uDC47 请确保添加此配置\n       nodeIntegration: true,\n     },\n   });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["\uD83E\uDDE8 第二阶段的代码对应 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/electron-react-init",target:"_blank",rel:"noopener noreferrer",children:"electron-react-init"})]}),"\n",(0,r.jsxs)(n.h2,{id:"第三阶段引入更多技术点",children:["第三阶段：引入更多技术点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三阶段引入更多技术点",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来引入 TypeScript、ESLint、Prettier，让整个项目看起来更加丰富。"}),"\n",(0,r.jsxs)(n.h3,{id:"1-安装-typescript",children:["1. 安装 TypeScript",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-安装-typescript",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["关于 TS 的入门学习，我建议小伙伴们去看",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"，结合项目去上手写 TS，项目中的 TS 不会有很多复杂难以理解的地方，写着写着，你会发现其实 TS 没那么难，如果你想提升 TS，也可以看看 ",(0,r.jsx)(n.a,{href:"https://github.com/type-challenges/type-challenges",target:"_blank",rel:"noopener noreferrer",children:"type-challenges"})," 这个库"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["先安装 ",(0,r.jsx)(n.code,{children:"TypeScript"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install typescript --save-dev \n"})}),"\n",(0,r.jsxs)(n.p,{children:["装完之后，",(0,r.jsx)(n.strong,{children:"我们将项目中的 js、jsx 文件都改造成 ts、tsx"})]}),"\n",(0,r.jsxs)(n.p,{children:["由于我们将 ",(0,r.jsx)(n.code,{children:"renderer/app.jsx"})," 作为入口文件，所以修改后，前往 ",(0,r.jsx)(n.code,{children:"webpack.render.dev.js"})," 文件修改 ",(0,r.jsx)(n.code,{children:"entry"})," ，避免项目启动报异常"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"entry: {\n  // \uD83D\uDC47 这里改成.tsx\n  index: path.resolve(__dirname, '../app/renderer/app.tsx'),\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["同时对于主进程 ",(0,r.jsx)(n.code,{children:"main/electron.js"})," 也需要去 ",(0,r.jsx)(n.code,{children:"webpack.main.dev.js"})," 修改一下 ",(0,r.jsx)(n.code,{children:"entry"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"entry: {\n  // \uD83D\uDC47 这里改成.ts\n  entry: path.resolve(__dirname, '../app/main/electron.ts'),\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们在 ",(0,r.jsx)(n.code,{children:"renderer"})," 文件夹下新增一个文件夹取名为 title，在此文件夹下新增 index.tsx 文件，让我们来写一下该组件，并定义组件的 Props"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"我们会发现，TS 提示错误，原来我们还没安装 React 对应的 TS 包，安装一下"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @types/react --save-dev\nnpm install @types/react-dom --save-dev\nnpm install @types/react-redux --save-dev\nnpm install @types/react-router-dom --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"装好之后，我们继续写组件"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\n\ninterface IProps {\n  /**\n   * @description 标题\n   */\n  text: string;\n  /**\n   * @description 样式\n   */\n  styles?: React.CSSProperties;\n}\n\nfunction Title({\n    text,styles\n}: IProps) {\n    return (\n        <div  style={styles}>{text}</div>\n    )\n}\n\nexport default Title;\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们在 app.tsx 下引入此组件，看看是不是会有提示"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"一切如我们的预期，这表示我们可以很愉快的使用 TS 开发了。"}),"\n",(0,r.jsxs)(n.h3,{id:"2-安装-eslint--prettier",children:["2. 安装 ESLint + Prettier",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-安装-eslint--prettier",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们看上面的 ",(0,r.jsx)(n.code,{children:"<Title />"})," 组件，看着有点膈应，好像不该换行的它换行了，该换行的没换行。我们总不能手动的去按回车、删空格吧？"]}),"\n",(0,r.jsxs)(n.p,{children:["这时我们使用 ",(0,r.jsx)(n.code,{children:"Prettier"})," 进行代码格式化，相比于 ESLint 中的代码格式规则，它更加专业。同时我们采用 ",(0,r.jsx)(n.code,{children:"ESLint"})," 来统一代码风格，提高我们的代码质量。"]}),"\n",(0,r.jsx)(n.p,{children:"ESLint 将我们的代码解析成 AST，通过检测 AST 来判断代码是否符合我们设置的规则，往往不同公司团队会自定义一套自己的 ESLint 规范。"}),"\n",(0,r.jsxs)(n.p,{children:["我们先来安装一下 ",(0,r.jsx)(n.code,{children:"Prettier"})," 和 ",(0,r.jsx)(n.code,{children:"ESLint"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install eslint@^7.26.0 --save-dev\nnpm install prettier@^2.3.0 --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"接着安装一些对应的插件信息，具体信息大家可去查询这些库都做了什么工作"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install eslint-config-alloy@^4.1.0 --save-dev\nnpm install eslint-config-prettier@^8.3.0 --save-dev\nnpm install eslint-plugin-prettier@^3.4.0 --save-dev\nnpm install eslint-plugin-react@^7.23.2 --save-dev\nnpm install eslint-plugin-react-hooks@^4.2.0 --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"可能有人会问，有 ESLint，是不是也有 TSLint，答案是：有。但我并不推荐。"}),"\n",(0,r.jsxs)(n.p,{children:["由于现在 ESLint 的生态比较完善，而 TSLint 首先是不能使用 ESLint 社区的一些成果，其次 TSLint 在生态上也相对较差，所以 TSLint 的作者已经宣布会逐渐放弃 TSLint ，而去支持 typescript-eslint-parser ，同时 ",(0,r.jsx)(n.a,{href:"https://github.com/microsoft/TypeScript/issues/30553",target:"_blank",rel:"noopener noreferrer",children:"Typescript 团队也宣布会将自己开发的 lint 工具从 tslint 迁移到 typescript-eslint-parser"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @typescript-eslint/parser@^4.24.0 --save-dev\nnpm install @typescript-eslint/eslint-plugin@^4.24.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["安装好之后，我们在项目根目录下创建 ",(0,r.jsx)(n.code,{children:"tsconfig.json"}),"、",(0,r.jsx)(n.code,{children:".prettierrc"})," 、\n",(0,r.jsx)(n.code,{children:".eslintrc.js"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'// tsconfig.json\n{\n  "compilerOptions": {\n    "target": "ES2016" /* 编译结果使用的版本标准: \'ES3\' (default), \'ES5\', \'ES2015\', \'ES2016\', \'ES2017\', \'ES2018\', \'ES2019\', \'ES2020\', or \'ESNEXT\'. */,\n    "module": "commonjs" /* 编译结果使用的模块化标准: \'none\', \'commonjs\', \'amd\', \'system\', \'umd\', \'es2015\', \'es2020\', or \'ESNext\'. */,\n    "lib": [\n      "ESNext",\n      "DOM"\n    ] /* 在写ts的时候支持的环境，默认是浏览器环境。如需要支持node，安装@type/node */,\n    "jsx": "react" /* Specify JSX code generation: \'preserve\', \'react-native\', or \'react\'. */,\n    "sourceMap": true,\n    "strict": true,\n    "declaration": true,\n    "removeComments": true /* 编译结果把ts的注释移除掉 */,\n    "esModuleInterop": true /* es6的模块化和非es6的模块化标准互通 */,\n    "allowSyntheticDefaultImports": true,\n    "baseUrl": "./",\n    "paths": {\n      "@src/*": ["./app/renderer/*"] // webpack 配置别名，但在TS中会报红找不到，所以tslint也需要配置\n    },\n    "moduleResolution": "node"\n  },\n  "exclude": ["dist", "node_modules"], // 这里需要排除掉 dist 目录和 node_modules 目录，不进行检查\n  "include": ["app/**/*.ts", "app/**/*.tsx", "app/**/*.d.ts"]\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'// .prettierrc\n{\n  "eslintIntegration": true,\n  "printWidth": 120,\n  "tabWidth": 2,\n  "useTabs": false,\n  "singleQuote": true,\n  "endOfLine": "auto"\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'alloy',\n    'alloy/react',\n    'alloy/typescript',\n    'plugin:react-hooks/recommended',\n    'plugin:prettier/recommended',\n  ],\n  globals: {\n    // 这里填入你的项目需要的全局变量\n    // 这里值为 false 表示这个全局变量不允许被重新赋值，比如：\n    __dirname: false,\n  },\n  rules: {\n    'no-undefined': 'warn',\n    'no-debugger': 'off',\n    complexity: ['error', { max: 99 }],\n    // 这里填入你的项目需要的个性化配置，比如：\n    // @fixable 一个缩进必须用两个空格替代\n    indent: [\n      1,\n      2,\n      {\n        SwitchCase: 1,\n        flatTernaryExpressions: true,\n      },\n    ],\n    // @fixable jsx 的 children 缩进必须为两个空格\n    'react/jsx-indent': [1, 2],\n    // @fixable jsx 的 props 缩进必须为两个空格\n    'react/jsx-indent-props': [1, 2],\n    'react/no-string-refs': 1, // 不要使用ref\n    'no-template-curly-in-string': 1, // 在string里面不要出现模板符号\n    '@typescript-eslint/prefer-optional-chain': 'off',\n    '@typescript-eslint/explicit-member-accessibility': 'off',\n    '@typescript-eslint/no-duplicate-imports': 'off',\n    'react/no-unsafe': 'off',\n    '@typescript-eslint/no-invalid-this': 'off',\n    'react/jsx-key': 0,\n    'no-undef': 0,\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这时候我们再去看前边写的代码，会发现一堆报红，我们只需 ",(0,r.jsx)(n.code,{children:"Ctrl+S"})," 保存一下即可。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"⚠️ 提示：如果发现未生效，可以重新打开一下 vscode"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-css-modules-问题",children:["3. CSS Modules 问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-css-modules-问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["大家都知道，CSS 的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。为了解决此情况，CSS Modules 的解决方案就是：使用一个独一无二的 class 的名字，不会与其他选择器重名。所以我们一般会看到，很多类命都是 ",(0,r.jsx)(n.code,{children:"hash 值 + 组件名"}),"，下面说说如何在 Webpack 中配置 CSS Module"]}),"\n",(0,r.jsxs)(n.p,{children:["在此项目中，我们采用 ",(0,r.jsx)(n.code,{children:"less"})," 进行样式相关的编写，安装它"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install less@3.12.2 --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们进入 Webpack 官网 Loader 配置，看看它提供处理样式类型的打包方案，关于这些 Loader 的具体介绍可在官网查阅"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"npm install less-loader@6.2.0 --save-dev\nnpm install postcss-loader@3.0.0 --save-dev\nnpm install css-loader@3.0.0 --save-dev\n// \uD83D\uDC47 将我们的样式通过style标签插入到页面head中\nnpm install style-loader@2.0.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["前面我们说了，Loader 就是模块打包方案，我们去 ",(0,r.jsx)(n.code,{children:"webpack.render.dev.js"})," 中添加配置"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack.render.dev.js\nconst devConfig = {\n  // \uD83D\uDC47 追加这段代码，关于Loader与Plugin了解可以去看彩蛋篇\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.less$/,\n        exclude: /node_modules/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              modules: {\n                localIdentName: '[name]__[local]__[hash:base64:5]',\n              },\n            },\n          },\n          'postcss-loader',\n          'less-loader',\n        ],\n      },\n    ],\n  }\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这时候我们在 ",(0,r.jsx)(n.code,{children:"<Title />"})," 组件下编写一个 ",(0,r.jsx)(n.code,{children:"index.less"})," 文件，看其样式否如我们所愿？"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react'; \nimport lessStyle from './index.less';\n\nfunction Title() {\n  return (\n    <div style={styles} className={lessStyle.title}>\n      {text}\n    </div>\n  )\n}\n\nexport default Title;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-less",children:".title {\n  color: red;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"有可能会出现下面问题，我们手动安装一下就可以了"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install autoprefixer@9.0.0 --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"再次运行，看看是否可行？发现还是不行，我们看看报什么错？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["解决此问题需要我们在项目根目录下创建 ",(0,r.jsx)(n.code,{children:"postcss.config.js"}),"，添加一下配置"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  plugins: {\n    autoprefixer: {\n      overrideBrowserslist: ['> 0.5%', 'last 5 versions'],\n    },\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["再次运行，看看效果，我们可以看到，类名的格式为",(0,r.jsx)(n.code,{children:"[组件名]_[当前类名]_[哈希值取5位]"}),"，从而形成独一无二的 class 名字，不会与其他选择器重名。至此我们完成了样式相关的配置处理。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-stylename",children:["4. styleName",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-stylename",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 React 中 CSS Modules 会使得我们写代码都要通过 styles 的形式"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport lessStyle from './index/less';\n\nfunction Title() {\n  return <div className={lessStyle.box} />;\n}\n\nexport default Title;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["特别繁琐，所以通过插件 ",(0,r.jsx)(n.a,{href:"https://github.com/gajus/react-css-modules",target:"_blank",rel:"noopener noreferrer",children:"react-css-modules"})," 实现 styleName 的形式，但是每次都需要写成这样"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport CSSModules from 'react-css-modules';\nimport lessStyle from './index.less';\n\nclass Title extends React.Component {\n  render() {\n    return (\n      <div styleName=\"box\">\n        <div styleName=\"cell\">test</div>\n      </div>\n    );\n  }\n}\nexport default CSSModules(Title, lessStyle);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["也是很蛋疼，所以作者又写了个插件",(0,r.jsx)(n.a,{href:"https://github.com/gajus/babel-plugin-react-css-modules",target:"_blank",rel:"noopener noreferrer",children:"babel-plugin-react-css-modules"}),"，这个插件更加好用"]}),"\n",(0,r.jsx)(n.p,{children:"为了改造成这种形式，我们进行配置修改，我们先安装插件"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// \uD83D\uDC47 不安装会在使用 styleName 时 TS 报错\nnpm install @types/react-css-modules@4.6.2 --save-dev\n// \uD83D\uDC47 让我们更好的使用 CSS Module\nnpm install babel-plugin-react-css-modules@5.2.6 --save-dev\nnpm install postcss-less@3.1.4 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后在 ",(0,r.jsx)(n.code,{children:"babel.config.js"})," 文件中添加一下配置"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  plugins: [\n    ...// css-modules\n    [\n      'babel-plugin-react-css-modules',\n      {\n        exclude: 'node_modules',\n        webpackHotModuleReloading: true,\n        generateScopedName: '[name]__[local]__[hash:base64:5]',\n        autoResolveMultipleImports: true,\n        filetypes: {\n          '.less': { syntax: 'postcss-less' },\n        },\n      },\n    ],\n  ],\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"最后再看看组件的代码是怎样的"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport './index.less';\n\ninterface IProps {\n  /**\n   * @description 标题\n   */\n  text: string;\n  /**\n   * @description 样式\n   */\n  styles?: React.CSSProperties;\n}\n\nfunction Title({ text, styles }: IProps) {\n  return (\n    <div style={styles} styleName=\"title\">\n      {text}\n    </div>\n  );\n}\n\nexport default Title;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"6-文件类型报错",children:["6. 文件类型报错",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-文件类型报错",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当我们在代码中引入一张照片时，打包会发生错误"}),"\n",(0,r.jsxs)(n.p,{children:["官方提供了一种专门处理此类型的方案：",(0,r.jsx)(n.code,{children:"file-loader"}),"，我们安装一下这个 loader"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install file-loader --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改一下 ",(0,r.jsx)(n.code,{children:"webpack.base.js"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|jpeg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: '[name]_[hash].[ext]',\n              outputPath: 'images/',\n            },\n          },\n        ],\n      },\n    ],\n  },\n  plugins: [new CleanWebpackPlugin()],\n};\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"5-文件部分类型-ts-报红",children:["5. 文件部分类型 TS 报红",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-文件部分类型-ts-报红",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们此刻引入一张图片，TS 会报错，说找不到模块，实际上我们的路径是正确的，图片也能正常显示"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["这时候我们只需要在 ",(0,r.jsx)(n.code,{children:"app/renderer"})," 目录下，新增一个 ",(0,r.jsx)(n.code,{children:"global.d.ts"})," 文件即可"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// global.d.ts\ndeclare module '*.jpg' {\n  const jpg: string;\n  export default jpg;\n}\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["⚠️ 请注意：如果你在根目录下新增 global.d.ts 文件，请确保你的 tsconfig.json 中 ",(0,r.jsx)(n.code,{children:"include"})," 字段是能匹配到 global.d.ts 文件"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["关于 global.d.ts 可配置的东西可太多了，一般来说，我们 ",(0,r.jsx)(n.code,{children:"window.pdk"})," 肯定会被 ts 报红，说 window 上并无此属性，这时候我们又不想改成 ",(0,r.jsx)(n.code,{children:"(window as any).pdk"}),"，那么我们可以扩展 Window 的类型"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 这里用于扩充window对象上的值\ndeclare interface Window {\n  pdk: string;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节主要通过实操，手把手带大家从0到1实现了项目的搭建，这是最重要也是最核心的部分，一层一层、一步一步地讲解，帮助小伙伴们，能够从头到尾把内容连接起来。也期望大家一定要动手实操一遍，感受一下搭建的“快乐”。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["\uD83E\uDDE8  如果你不想动手搭建，可直接访问：",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/init-cli",target:"_blank",rel:"noopener noreferrer",children:"init-cli 分支"}),"，代码拉取之后安装一下即可开发。"]})}),"\n",(0,r.jsxs)(n.h2,{id:"补充说明",children:["补充说明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#补充说明",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"1-关于环境变量",children:["1. 关于环境变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-关于环境变量",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"2021.06.10 补充更新，此补充说明是给 10 号前已预览过的小伙伴看的～"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["早一批的小伙伴应该会记得，我们在 webpack.main.dev.js 中通过 webpack.DefinePlugin 定义了全局变量 process.env.NODE_ENV。并在 package.json 的脚本命令 start:main 中又声明了 NODE_ENV，目前代码仓库已全量更新。小伙伴们可前往 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/init-cli",target:"_blank",rel:"noopener noreferrer",children:"init-cli 分支"})," 看最新代码。下面来说明一下这两者区别。"]}),"\n",(0,r.jsx)(n.p,{children:"得先明白一点就是，为什么要配置这个，在前端工程化配置中，一般我们都会有许多环境，如生产环境/开发环境等。在 node 中有全局变量 process 表示当前 node 进程，process.env 包含着关于系统环境的信息。但是 process.env 中并不存在 NODE_ENV 这个玩意。所以我们通过定义全局变量来区分环境的不同。"}),"\n",(0,r.jsxs)(n.p,{children:["在 package.json 的 scripts 命令中，通过添加 NODE_ENV=development，表示 node 服务启动时，将 NODE_ENV 挂载到 process.env 上。在 Linux 和 Mac 上直接这么写是没问题的，但 Widnow 上就会存在问题，这也就是小伙伴们反馈 window 上无法运行的根本原因。如果你一定要在脚本命令中添加一些配置参数，那么建议通过第三方 ",(0,r.jsx)(n.code,{children:"cross-env"})," 库，抹平掉不同平台之间的差异。"]}),"\n",(0,r.jsx)(n.p,{children:"再来说说 webpack.DefinePlugin 中定义的全局变量，它表示 webpack 在编译过程中，所有此变量，都会被替换成我们定义的值。"}),"\n",(0,r.jsxs)(n.p,{children:["既然两者都能定义变量，那么采用哪种会比较好呢？由于我们的主进程和渲染进程都是经过 webpack 编译，我个人建议是通过 webpack.DefinePlugin。当然不用自己写环境变量的定义。因为在 webpack 配置中，我们定义了 mode 配置选项，通过",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/mode/#usage",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"我们可以看到:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const mainConfig = {\n  // ...\n  mode: 'development',\n  // \uD83D\uDC46 上面定义的 mode 等价于我们在 DefinePlugin 中定义了 process.env.NODE_ENV\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["点击查看 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/3eea3e6426e5ca1f316f42b327a2ccfa9d6a158a",target:"_blank",rel:"noopener noreferrer",children:"commit"})," 信息，如果看完这里还有疑问，欢迎进群讨论～"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-关于-dependencies-与-devdependencies",children:["2. 关于 dependencies 与 devDependencies",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-关于-dependencies-与-devdependencies",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"收到小伙伴们的建议，此次进行了更新，在此之前，我们需要搞清楚一下这两者的区别。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"dependencies 是产生环境下的依赖，比如说 Vue、React 等"}),"\n",(0,r.jsx)(n.li,{children:"devDependencies 是开发环境下的依赖，比如 Webpack、ESLint、Babel 等"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"可能这么讲小伙伴们还是不怎么能区分，这么说吧。我写了一个 React UI 组件包，其中依赖了 AntDesign，那我需要将 AntDesign 和 React 放在 dependencies 中。"}),"\n",(0,r.jsx)(n.p,{children:"再比如说，我们项目中用到了 Redux，但是 Redux 的 devDependencies 里面有 jest、rxjs 等，在我们安装 Redux 时，我们是不会把 jest、rxjs 拉下来的（也就是 node_modules 里是不会有 jest、rxjs）"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"一般我们开发过程中，会在项目中安装 webpack、webpack-dev-server、babel、eslint 的等工具库，或者是用于单元测试的 jest 库，这些依赖库都只是在我们项目开发过程中使用，应该写在 devDependencies 里。如果说我们依赖乱写，例如开发依赖放在生产，生产依赖放在开发，这会出现什么问题？"}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.a,{href:"https://github.com/SugarTurboS/rc-redux-model/blob/master/package.json",target:"_blank",rel:"noopener noreferrer",children:"rc-redux-model"}),"为例，我们可以看到它的依赖非常的少。这是一个 npm 包。当我们执行 ",(0,r.jsx)(n.code,{children:"npm install rc-redux-model"})," 时，此时会将 dependencies 的依赖都安装，不会安装 devDependencies 里的依赖库。"]}),"\n",(0,r.jsxs)(n.p,{children:["但如果是通过克隆仓库项目代码，如 ",(0,r.jsx)(n.code,{children:"git clone https://github.com/SugarTurboS/rc-redux-model"}),"，然后再 ",(0,r.jsx)(n.code,{children:"npm instal"}),"，这时候会将 dependencies 和 devDependencies 里的依赖库都安装。"]}),"\n",(0,r.jsxs)(n.p,{children:["小伙伴们可以再私下研究研究，点击查看 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/07e6b76b06f2ade272d58f6c47dbb134139ec28a",target:"_blank",rel:"noopener noreferrer",children:"commit"})," 信息，如果看完这里还有疑问，欢迎进群讨论～"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-打包成桌面应用",children:["3. 打包成桌面应用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-打包成桌面应用",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["许多小伙伴们通过本章节将 Electron + React 搭建起来后，还没开始写几行代码，就迫不及待想打包成桌面应用，毕竟搞出自己第一个桌面应用，是一件很骄傲自豪的事情！！！但是又不想等整个小册都完结，才能上手打包构建，为此，阿宽新增一章节 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6972047382494052392",target:"_blank",rel:"noopener noreferrer",children:"\uD83C\uDFC6 支线篇-打包生成第一个桌面应用（骄傲自豪）"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"此章节为支线任务，与主流程（主线任务）无任何关系。可放心使用，如果在打包期间遇到问题，可加我微信或进群讨论～"})]})}function k(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(v,{...e})}):v(e)}let w=k;k.__RSPRESS_PAGE_META={},k.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F4.%E7%8E%AF%E5%A2%83%E7%AF%87-%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E6%88%91%E4%BB%AC%E7%9A%84%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"开发前必读！Electron 与 React 的关系",id:"开发前必读electron-与-react-的关系",depth:2},{text:"第一阶段：Electron 搭建",id:"第一阶段electron-搭建",depth:2},{text:"1. 安装 Node 环境",id:"1-安装-node-环境",depth:3},{text:"2. 安装 Electron",id:"2-安装-electron",depth:3},{text:"3. 基本框架结构",id:"3-基本框架结构",depth:3},{text:"4. 编写 package.json",id:"4-编写-packagejson",depth:3},{text:"5. 定义 html",id:"5-定义-html",depth:3},{text:"6. 编写主进程",id:"6-编写主进程",depth:3},{text:"7. 启动应用程序",id:"7-启动应用程序",depth:3},{text:"第二阶段：React 搭建",id:"第二阶段react-搭建",depth:2},{text:"1. 安装 React",id:"1-安装-react",depth:3},{text:"2. 安装 Babel",id:"2-安装-babel",depth:3},{text:"3. 安装 Webpack",id:"3-安装-webpack",depth:3},{text:"3.1 webpack.base.js",id:"31-webpackbasejs",depth:4},{text:"3.2 webpack.main.dev.js",id:"32-webpackmaindevjs",depth:4},{text:"3.3 webpack.render.dev.js",id:"33-webpackrenderdevjs",depth:4},{text:"5. Electron 与 React 结合起来",id:"5-electron-与-react-结合起来",depth:3},{text:"6. 跑起来",id:"6-跑起来",depth:3},{text:"第三阶段：引入更多技术点",id:"第三阶段引入更多技术点",depth:2},{text:"1. 安装 TypeScript",id:"1-安装-typescript",depth:3},{text:"2. 安装 ESLint + Prettier",id:"2-安装-eslint--prettier",depth:3},{text:"3. CSS Modules 问题",id:"3-css-modules-问题",depth:3},{text:"4. styleName",id:"4-stylename",depth:3},{text:"6. 文件类型报错",id:"6-文件类型报错",depth:3},{text:"5. 文件部分类型 TS 报红",id:"5-文件部分类型-ts-报红",depth:3},{text:"总结",id:"总结",depth:2},{text:"补充说明",id:"补充说明",depth:2},{text:"1. 关于环境变量",id:"1-关于环境变量",depth:3},{text:"2. 关于 dependencies 与 devDependencies",id:"2-关于-dependencies-与-devdependencies",depth:3},{text:"3. 打包成桌面应用",id:"3-打包成桌面应用",depth:3}],title:"4.环境篇-动手搭建我们的简历平台",headingTitle:"4.环境篇-动手搭建我们的简历平台",frontmatter:{}}}}]);