"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27529"],{866014:function(e,n,d){d.r(n),d.d(n,{default:()=>u});var c=d(552676),r=d(740453);let l=d.p+"static/image/c3d9f9498a1aeb209498df4cf9453115.01450e75.webp",o=d.p+"static/image/a8cb546dbd8ae50ef3461562b17174ee.74a1fb04.webp",s=d.p+"static/image/af193224673d65d49065a8671dfe4a4d.34efc934.webp",i=d.p+"static/image/d09ad1aa0d5b97473efd09740a66ea5e.fe576de1.webp",h=d.p+"static/image/27307a0a29d1ddcd5cdcfe70956872b6.01e89b09.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",em:"em",code:"code",strong:"strong",ul:"ul",li:"li",h2:"h2",img:"img",ol:"ol",pre:"pre"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"25dependency-graph如何管理模块间依赖",children:["25.Dependency Graph：如何管理模块间依赖？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25dependency-graph如何管理模块间依赖",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Dependency Graph 概念来自官网 ",(0,c.jsx)(n.a,{href:"https://webpack.js.org/concepts/dependency-graph/",target:"_blank",rel:"noopener noreferrer",children:"Dependency Graph | webpack"})," 一文，原文解释："]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Any time one file depends on another, webpack treats this as a ",(0,c.jsx)(n.em,{children:"dependency"}),". This allows webpack to take non-code assets, such as images or web fonts, and also provide them as ",(0,c.jsx)(n.em,{children:"dependencies"})," for your application."]}),"\n",(0,c.jsxs)(n.p,{children:["When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file. Starting from these ",(0,c.jsx)(n.em,{children:(0,c.jsx)(n.a,{href:"https://webpack.js.org/concepts/entry-points/",target:"_blank",rel:"noopener noreferrer",children:"entry points"})}),", webpack recursively builds a ",(0,c.jsx)(n.em,{children:"dependency graph"})," that includes every module your application needs, then bundles all of those modules into a small number of ",(0,c.jsx)(n.em,{children:"bundles"})," - often, just one - to be loaded by the browser."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["大意：Webpack 处理应用代码时，会从开发者提供的 ",(0,c.jsx)(n.code,{children:"entry"})," 开始递归地组建起包含所有模块的 ",(0,c.jsx)(n.strong,{children:"Dependency Graph"}),"，之后再将这些 ",(0,c.jsx)(n.code,{children:"module"})," 打包为 ",(0,c.jsx)(n.code,{children:"bundles"})," 。"]}),"\n",(0,c.jsxs)(n.p,{children:["然而事实远不止官网描述的这么简单，Dependency Graph 贯穿 Webpack 整个运行周期，从「",(0,c.jsx)(n.strong,{children:"构建阶段"}),"」的模块解析，到「",(0,c.jsx)(n.strong,{children:"生成阶段"}),"」的 Chunk 生成，以及 Tree-shaking 等功能都高度依赖于Dependency Graph ，是 Webpack 资源构建流程中一个非常核心的数据结构。"]}),"\n",(0,c.jsx)(n.p,{children:"本文将围绕 Webpack5 的 Dependency Graph 实现，展开讨论如下内容："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"模块依赖关系图的概念；"}),"\n",(0,c.jsx)(n.li,{children:"Webpack5 如何收集、管理、消费模块依赖关系图。"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"dependency-graph-是什么",children:["Dependency Graph 是什么？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dependency-graph-是什么",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["正式介绍 Dependency Graph 结构之前，我们先 ",(0,c.jsx)(n.strong,{children:"简单"})," 回顾一下 Webpack 构建阶段的关键过程："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["首先根据 ",(0,c.jsx)(n.code,{children:"entry"})," 配置信息创建若干 ",(0,c.jsx)(n.code,{children:"EntryDependency"})," 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"NormalModuleFactory"})," ，根据 ",(0,c.jsx)(n.code,{children:"EntryDependency"})," 对象的资源路径创建 ",(0,c.jsx)(n.code,{children:"Module"})," 子类对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["将 ",(0,c.jsx)(n.code,{children:"Module"})," 代码解析为 AST 结构；"]}),"\n",(0,c.jsxs)(n.li,{children:["遍历 AST，找到所有模块导入语句（",(0,c.jsx)(n.code,{children:"import/require"}),"）；"]}),"\n",(0,c.jsxs)(n.li,{children:["根据导入语句创建对应的 ",(0,c.jsx)(n.code,{children:"Dependency"})," 子类对象；"]}),"\n",(0,c.jsx)(n.li,{children:"递归执行步骤 2，直到所有项目文件都处理完毕。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这个过程从 ",(0,c.jsx)(n.code,{children:"entry"})," 模块开始，逐步递归找出所有依赖文件，模块之间隐式形成了以 ",(0,c.jsx)(n.code,{children:"entry"})," 为起点，以模块为节点，以导入导出依赖为边的有向图关系 —— 也就是 Webpack 官网所说的 Dependency Graph。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"这个 Dependency Graph 是 Webpack 内部非常重要的过程信息之一，后续封装 Chunk、Code Splits、Tree-Shaking、Hot Module Replacement 等等，几乎所有功能都需要依赖这一信息实现。"}),"\n",(0,c.jsx)(n.p,{children:"Webpack5 之前，Dependency Graph 关系隐含在 Dependence、Module 对象的一系列属性中，例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"module.dependencies"})," 数组记录模块依赖对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"dependency.module"})," 记录依赖对应的模块对象引用；"]}),"\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"module.issuer"})," 记录父模块引用。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这种设计存在很多问题，例如：模块之间的关系非常隐晦难懂；模块搜索算法与模块资源构建逻辑耦合在同一个 Class 实体内，",(0,c.jsx)(n.code,{children:"Module"})," 职责不单一且复杂度非常高；同一个 Module 对象无法在多个 Dependency Graph 之间共享，等等。"]}),"\n",(0,c.jsxs)(n.p,{children:["为此，Webpack5 ",(0,c.jsx)(n.a,{href:"https://webpack.js.org/blog/2020-10-10-webpack-5-release/#module-and-chunk-graph",target:"_blank",rel:"noopener noreferrer",children:"重构"})," 了 Dependency Graph 的具体实现，将依赖关系从 ",(0,c.jsx)(n.code,{children:"Dependence/Module"})," 类型中解耦出来，以一套独立的 Graph 数据结构记录模块间依赖关系，并基于 ",(0,c.jsx)(n.code,{children:"Map/Set"})," 等原生模块实现更高效的模块搜索、校验、遍历算法。"]}),"\n",(0,c.jsxs)(n.h2,{id:"dependency-graph-数据结构详解",children:["Dependency Graph 数据结构详解",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dependency-graph-数据结构详解",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Webpack 5.0 之后的 Dependency Graph 涉及如下数据类型："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ModuleGraph"}),"：记录 Dependency Graph 信息的容器，记录构建过程中涉及到的所有 ",(0,c.jsx)(n.code,{children:"module"}),"、",(0,c.jsx)(n.code,{children:"dependency"})," 对象，以及这些对象互相之间的引用；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ModuleGraphConnection"})," ：记录模块间引用关系的数据结构，内部通过 ",(0,c.jsx)(n.code,{children:"originModule"})," 属性记录引用关系中的父模块，通过 ",(0,c.jsx)(n.code,{children:"module"})," 属性记录子模块；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ModuleGraphModule"})," ：",(0,c.jsx)(n.code,{children:"Module"})," 对象在 Dependency Graph 体系下的补充信息，包含模块对象的 ",(0,c.jsx)(n.code,{children:"incomingConnections"})," —— 指向模块本身的 ",(0,c.jsx)(n.code,{children:"ModuleGraphConnection"})," 集合，即谁引用了模块自身；",(0,c.jsx)(n.code,{children:"outgoingConnections"})," —— 该模块对外的依赖，即该模块引用了其他那些模块。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"这些类型之间关系的基本逻辑是："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Compilation"})," 类内部会维护一个全局唯一的 ",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 实例对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["每次解析出新模块后，将 Module、Dependency，以及模块之间的关系 —— ",(0,c.jsx)(n.code,{children:"ModuleConnection"})," 记录到 ",(0,c.jsx)(n.code,{children:"compilation.moduleGraph"})," 对象中；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"ModuleGraph"})," 除了记录依赖关系外，还提供了许多工具方法，方便使用者迅速读取出 ",(0,c.jsx)(n.code,{children:"module"})," 或 ",(0,c.jsx)(n.code,{children:"dependency"})," 附加的信息。",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 内部有两个关键属性：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"_dependencyMap"})," 属性记录 ",(0,c.jsx)(n.code,{children:"Dependency"})," 对象与 ",(0,c.jsx)(n.code,{children:"ModuleGraphConnection"})," 连接对象之间的映射关系，后续的处理中可以基于这层映射迅速找到 ",(0,c.jsx)(n.code,{children:"Dependency"})," 实例对应的引用与被引用者；"]}),"\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"_moduleMap"})," 属性记录 ",(0,c.jsx)(n.code,{children:"Module"})," 与 ",(0,c.jsx)(n.code,{children:"ModuleGraphModule"})," 之间的映射关系。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["最终，通过 ",(0,c.jsx)(n.code,{children:"ModuleGraph"}),"、",(0,c.jsx)(n.code,{children:"ModuleGraphConnection"}),"、",(0,c.jsx)(n.code,{children:"ModuleGraphModule"})," 三种类型的协作，在主体的 ",(0,c.jsx)(n.code,{children:"Module"}),"、",(0,c.jsx)(n.code,{children:"Dependency"})," 体系之外，记录模块之间的依赖信息。"]}),"\n",(0,c.jsx)(n.p,{children:"依赖关系收集过程，主要发生在构建阶段的两个节点："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"addDependency"})," ：webpack 从模块内容中解析出引用关系后，创建适当的 ",(0,c.jsx)(n.code,{children:"Dependency"})," 子类并调用该方法记录到 ",(0,c.jsx)(n.code,{children:"module"})," 实例；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"handleModuleCreation"})," ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 ",(0,c.jsx)(n.code,{children:"Dependency"})," 对应的子模块对象，之后调用 ",(0,c.jsx)(n.code,{children:"moduleGraph.setResolvedModule"})," 方法将父子引用信息记录到 ",(0,c.jsx)(n.code,{children:"moduleGraph"})," 对象上。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"moduleGraph.setResolvedModule"})," 方法的逻辑大致为："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class ModuleGraph {\n    constructor() {\n        /** @type {Map<Dependency, ModuleGraphConnection>} */\n        this._dependencyMap = new Map();\n        /** @type {Map<Module, ModuleGraphModule>} */\n        this._moduleMap = new Map();\n    }\n\n    /**\n     * @param {Module} originModule the referencing module\n     * @param {Dependency} dependency the referencing dependency\n     * @param {Module} module the referenced module\n     * @returns {void}\n     */\n    setResolvedModule(originModule, dependency, module) {\n        const connection = new ModuleGraphConnection(\n            originModule,\n            dependency,\n            module,\n            undefined,\n            dependency.weak,\n            dependency.getCondition(this)\n        );\n        this._dependencyMap.set(dependency, connection);\n        const connections = this._getModuleGraphModule(module).incomingConnections;\n        connections.add(connection);\n        const mgm = this._getModuleGraphModule(originModule);\n        if (mgm.outgoingConnections === undefined) {\n            mgm.outgoingConnections = new Set();\n        }\n        mgm.outgoingConnections.add(connection);\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["主要更改了 ",(0,c.jsx)(n.code,{children:"_dependencyMap"})," 及 ",(0,c.jsx)(n.code,{children:"moduleGraphModule"})," 的出入 ",(0,c.jsx)(n.code,{children:"connections"})," 属性，以此收集当前模块的上下游依赖关系。"]}),"\n",(0,c.jsxs)(n.h2,{id:"实例解析",children:["实例解析",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例解析",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"看个简单例子，对于下面的依赖关系："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"Webpack 启动后："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["首先创建 ",(0,c.jsx)(n.code,{children:"index.js"})," 对应的 ",(0,c.jsx)(n.code,{children:"EntryDependency"})," 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"NormalModuleFactory"})," 创建 ",(0,c.jsx)(n.code,{children:"EntryDependency"})," 对应的 ",(0,c.jsx)(n.code,{children:"NormalModule"})," 实例；"]}),"\n",(0,c.jsxs)(n.li,{children:["执行 ",(0,c.jsx)(n.code,{children:"compilation.handleModuleCreation"}),"，经过解析、遍历 AST 等操作，最终得到 ",(0,c.jsx)(n.code,{children:"a.js"}),"、",(0,c.jsx)(n.code,{children:"b.js"})," 两个新 Dependency 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"NormalModuleFactory"})," 为这两个 Dependency 对象创建对应的 ",(0,c.jsx)(n.code,{children:"NormalModule"})," 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"moduleGraph.setResolvedModule"})," 记录 ",(0,c.jsx)(n.code,{children:"entry"})," 模块与 ",(0,c.jsx)(n.code,{children:"a/b"})," 模块的依赖关系。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"最终生成如下数据结果："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'ModuleGraph: {\n    _dependencyMap: Map(3){\n        { \n            EntryDependency{request: "./src/index.js"} => ModuleGraphConnection{\n                module: NormalModule{request: "./src/index.js"}, \n                // 入口模块没有引用者，故设置为 null\n                originModule: null\n            } \n        },\n        { \n            HarmonyImportSideEffectDependency{request: "./src/a.js"} => ModuleGraphConnection{\n                module: NormalModule{request: "./src/a.js"}, \n                originModule: NormalModule{request: "./src/index.js"}\n            } \n        },\n        { \n            HarmonyImportSideEffectDependency{request: "./src/a.js"} => ModuleGraphConnection{\n                module: NormalModule{request: "./src/b.js"}, \n                originModule: NormalModule{request: "./src/index.js"}\n            } \n        }\n    },\n\n    _moduleMap: Map(3){\n        NormalModule{request: "./src/index.js"} => ModuleGraphModule{\n            incomingConnections: Set(1) [\n                // entry 模块，对应 originModule 为null\n                ModuleGraphConnection{ module: NormalModule{request: "./src/index.js"}, originModule:null }\n            ],\n            outgoingConnections: Set(2) [\n                // 从 index 指向 a 模块\n                ModuleGraphConnection{ module: NormalModule{request: "./src/a.js"}, originModule: NormalModule{request: "./src/index.js"} },\n                // 从 index 指向 b 模块\n                ModuleGraphConnection{ module: NormalModule{request: "./src/b.js"}, originModule: NormalModule{request: "./src/index.js"} }\n            ]\n        },\n        NormalModule{request: "./src/a.js"} => ModuleGraphModule{\n            incomingConnections: Set(1) [\n                ModuleGraphConnection{ module: NormalModule{request: "./src/a.js"}, originModule: NormalModule{request: "./src/index.js"} }\n            ],\n            // a 模块没有其他依赖，故 outgoingConnections 属性值为 undefined\n            outgoingConnections: undefined\n        },\n        NormalModule{request: "./src/b.js"} => ModuleGraphModule{\n            incomingConnections: Set(1) [\n                ModuleGraphConnection{ module: NormalModule{request: "./src/b.js"}, originModule: NormalModule{request: "./src/index.js"} }\n            ],\n            // b 模块没有其他依赖，故 outgoingConnections 属性值为 undefined\n            outgoingConnections: undefined\n        }\n    }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["从上面的 Dependency Graph 可以看出，本质上 ",(0,c.jsx)(n.code,{children:"ModuleGraph._moduleMap"})," 已经形成了一个有向无环图结构，其中字典 ",(0,c.jsx)(n.code,{children:"_moduleMap"})," 的 key 为图的节点，对应 value ",(0,c.jsx)(n.code,{children:"ModuleGraphModule"})," 结构中的 ",(0,c.jsx)(n.code,{children:"outgoingConnections"})," 属性为图的边，则上例中从起点 ",(0,c.jsx)(n.code,{children:"index.js"})," 出发沿 ",(0,c.jsx)(n.code,{children:"outgoingConnections"})," 向前可遍历出图的所有顶点。"]}),"\n",(0,c.jsxs)(n.h2,{id:"作用",children:["作用",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作用",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Webpack5 中，关键字 ",(0,c.jsx)(n.code,{children:"moduleGraph"})," 出现了 1000 多次，几乎覆盖了 ",(0,c.jsx)(n.code,{children:"webpack/lib"})," 文件夹下的所有文件，其作用可见一斑。虽然出现的频率很高，但总的来说可以看出有两个主要作用：信息索引，以及辅助构建 ChunkGraph。"]}),"\n",(0,c.jsxs)(n.p,{children:["信息索引是 ModuleGraph 最重要的功能，在 ",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 类型中提供了很多实现 ",(0,c.jsx)(n.code,{children:"module"})," / ",(0,c.jsx)(n.code,{children:"dependency"})," 信息查询的工具函数，例如："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"getModule(dep: Dependency)"})," ：根据 ",(0,c.jsx)(n.code,{children:"dep"})," 查找对应的 ",(0,c.jsx)(n.code,{children:"module"})," 实例；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"getOutgoingConnections(module)"})," ：查找 ",(0,c.jsx)(n.code,{children:"module"})," 实例的所有依赖；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"getIssuer(module: Module)"})," ：查找 ",(0,c.jsx)(n.code,{children:"module"})," 在何处被引用；"]}),"\n",(0,c.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Webpack5 内部的许多插件、Dependency 子类、Module 子类的实现都需要用到这些工具函数查找特定模块、依赖的信息，例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"SplitChunksPlugin"})," 在优化 ",(0,c.jsx)(n.code,{children:"chunks"})," 处理中，需要使用 ",(0,c.jsx)(n.code,{children:"moduleGraph.getExportsInfo"})," 查询各个模块的 ",(0,c.jsx)(n.code,{children:"exportsInfo"})," (模块导出的信息集合，与 tree-shaking 强相关，后续会单出一篇文章讲解)信息以确定如何分离 chunk。"]}),"\n",(0,c.jsxs)(n.li,{children:["在 ",(0,c.jsx)(n.code,{children:"compilation.seal"})," 函数中，需要遍历 ",(0,c.jsx)(n.code,{children:"entry"})," 对应的 dep 并调用 ",(0,c.jsx)(n.code,{children:"moduleGraph.getModule"})," 获取完整的 ",(0,c.jsx)(n.code,{children:"module"})," 定义"]}),"\n",(0,c.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["所以，你在编写插件时，可以考虑适度参考 ",(0,c.jsx)(n.code,{children:"webpack/lib/ModuleGraph.js"})," 中提供的方法，确认可以获取使用哪些函数，获取到你所需要的信息。"]}),"\n",(0,c.jsxs)(n.p,{children:["此外，在 Webpack 完成模块构建，进入「",(0,c.jsx)(n.strong,{children:"生成阶段"}),"」之后，会按一系列规则将模块逐一分配到不同 Chunk 对象中，在 Webpack4 时，这个过程主要围绕 ",(0,c.jsx)(n.code,{children:"Chunk"})," 及 ",(0,c.jsx)(n.code,{children:"ChunkGroup"})," 两个类型展开。"]}),"\n",(0,c.jsxs)(n.p,{children:["而 5.0 之后，对 Chunk 之间的依赖关系管理也做了一次大型 ",(0,c.jsx)(n.a,{href:"https://webpack.js.org/blog/2020-10-10-webpack-5-release/#module-and-chunk-graph",target:"_blank",rel:"noopener noreferrer",children:"重构"}),"：首先根据默认规则为每一个 ",(0,c.jsx)(n.code,{children:"entry"})," 创建对应 Chunk 对象 ，之后调用 ",(0,c.jsx)(n.code,{children:"buildChunkGraph"})," 方法，遍历 ",(0,c.jsx)(n.code,{children:"moduleGraph"})," 对象，找出入口模块对应的所有 ",(0,c.jsx)(n.code,{children:"Module"})," 对象，并将依赖关系转化为 ChunkGraph 对象，这一块的逻辑也特别复杂，我们放在下一章节讲解。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"综上，Webpack 构建过程中会持续收集模块之间的引用、被引用关系，并记录到 Dependency Graph 结构中，后续的 Chunk 封装、Code Split、Tree-Shaking 等，但凡需要分析模块关系的功能都强依赖于 Dependency Graph。"}),"\n",(0,c.jsxs)(n.p,{children:["可以说，Dependency Graph 是 Webpack 底层最关键的模块地图数据，因此在 Webpack5 之后，Dependency Graph 结构被解耦抽离为以 ",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 为中心的若干独立类型，架构逻辑更合理，模块搜索、分析效率也得到不同程度优化，进而使得 Webpack5 构建速度也有明显提升。"]}),"\n",(0,c.jsxs)(n.p,{children:["学习 Dependency Graph，一是能帮助我们从数据结构角度，更深入理解 Webpack 模块读入与分析处理的过程；二是编写自定义插件时，可以通过 ",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 提供的若干工具函数了解模块之间的相互依赖关系。"]}),"\n",(0,c.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Dependency Graph 在 Webpack 的「构建阶段」与「生成阶段」分别扮演什么样的角色？"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}let u=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F25.Dependency%20Graph%EF%BC%9A%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E9%97%B4%E4%BE%9D%E8%B5%96%EF%BC%9F.md"]={toc:[{text:"Dependency Graph 是什么？",id:"dependency-graph-是什么",depth:2},{text:"Dependency Graph 数据结构详解",id:"dependency-graph-数据结构详解",depth:2},{text:"实例解析",id:"实例解析",depth:2},{text:"作用",id:"作用",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"25.Dependency Graph：如何管理模块间依赖？",headingTitle:"25.Dependency Graph：如何管理模块间依赖？",frontmatter:{}}}}]);