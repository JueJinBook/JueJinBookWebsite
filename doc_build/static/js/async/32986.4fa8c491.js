"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32986"],{329478:function(e,n,i){i.r(n),i.d(n,{default:()=>o});var r=i(552676),s=i(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",ol:"ol",li:"li",blockquote:"blockquote",strong:"strong"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第09章实战篇自定义窗口的拖拽和缩放",children:["第09章—实战篇：自定义窗口的拖拽和缩放",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第09章实战篇自定义窗口的拖拽和缩放",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFF## 前言"}),"\n",(0,r.jsxs)(n.p,{children:["默认情况，在构建 ",(0,r.jsx)(n.code,{children:"Electron BrwoserWindow"})," 的时候，会使用系统自带的原生窗口样式，比如在 ",(0,r.jsx)(n.code,{children:"MacOS"})," 下的样式："]}),"\n",(0,r.jsxs)(n.p,{children:["在有些情况下，操作系统的原生窗口并不能符合我们的一些视觉和交互需求。所以，在使用\xa0",(0,r.jsx)(n.code,{children:"electron"}),"\xa0创建桌面应用的时候，有时候我们希望能完全掌控窗口的样式，而隐藏掉系统提供的窗口边框和标题栏等。这个时候就需要用到自定义窗口。"]}),"\n",(0,r.jsxs)(n.h2,{id:"无边框窗口的拖拽",children:["无边框窗口的拖拽",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#无边框窗口的拖拽",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["无边框窗口是不带外壳（包括窗口边框、工具栏等），只含有网页内容的窗口。要创建无边框窗口，需在\xa0",(0,r.jsx)(n.code,{children:"BrowserWindow"}),"\xa0的构造中将\xa0",(0,r.jsx)(n.code,{children:"frame"}),"\xa0参数设置为\xa0",(0,r.jsx)(n.code,{children:"false"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// main.js\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow({ frame: false })\n"})}),"\n",(0,r.jsx)(n.p,{children:"默认情况下，无边框窗口是不可以拖拽的。所以接下来，我们介绍几种让无边框窗口支持拖拽的方式。"}),"\n",(0,r.jsxs)(n.h3,{id:"1-使用--webkit-app-region-drag",children:["1. 使用 -webkit-app-region: drag",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用--webkit-app-region-drag",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["应用程序需要在 CSS 中指定 ",(0,r.jsx)(n.code,{children:"-webkit-app-region: drag"})," 来告诉 Electron 哪些区域是可拖拽的（如操作系统的标准标题栏），当前只支持矩形形状区域。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<body style="-webkit-app-region: drag"></body>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["注意：在某部分 windows 上使用 ",(0,r.jsx)(n.code,{children:"-webkit-app-region: drag"})," 来设置拖拽，那么请记住需要在可拖拽区域内部使用 ",(0,r.jsx)(n.code,{children:"-webkit-app-region: no-drag"})," 来将其中部分需要交互的区域排除。不然那些需要交互的元素几乎无法响应所有的鼠标事件，包括点击、拖拽等。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<body style="-webkit-app-region: drag">\n   <button style="-webkit-app-region: no-drag;">click</button>\n</body>\n'})}),"\n",(0,r.jsx)(n.p,{children:"所以，如果你需要整个窗口所有区域都支持拖拽，那臣妾就做不到了~"}),"\n",(0,r.jsxs)(n.h3,{id:"2-自定义拖拽事件",children:["2. 自定义拖拽事件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-自定义拖拽事件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["既然 ",(0,r.jsx)(n.code,{children:"-webkit-app-region: drag"})," 无法做到全屏拖拽移动窗口，那么有没有更好的办法呢？其实另一种方案就是自定拖拽移动，具体怎么做呢？"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Electron 需要拖拽的窗口的内容区域监听 ",(0,r.jsx)(n.code,{children:"mousedown"})," 事件，如果是鼠标左键按下，则开启可拖拽开关 ",(0,r.jsx)(n.code,{children:"draggable = true"}),"。然后记录鼠标按下去的位置 ",(0,r.jsx)(n.code,{children:"mouseX"}),"、",(0,r.jsx)(n.code,{children:"mouseY"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["接下来就启动一个 ",(0,r.jsx)(n.code,{children:"requestAnimationFrame"})," 函数来把 ",(0,r.jsx)(n.code,{children:"mouseX"})," 和 ",(0,r.jsx)(n.code,{children:"mouseY"})," 传递给主进程并不断和主进程通信。"]}),"\n",(0,r.jsxs)(n.li,{children:["主进程那边没收到一次通信请求就使用 ",(0,r.jsx)(n.code,{children:"screen.getCursorScreenPoint()"})," 来获取最新的鼠标位置 ",(0,r.jsx)(n.code,{children:"x、y"}),"。并计算鼠标的位移数值。最后通过 ",(0,r.jsx)(n.code,{children:"window.setBounds"})," 来重新设置窗口的位置"]}),"\n",(0,r.jsxs)(n.li,{children:["监听鼠标的 ",(0,r.jsx)(n.code,{children:"mouseup"})," 事件，如果触发，则设置 ",(0,r.jsx)(n.code,{children:"draggable=false"}),"。防止意外拖拽的产生。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"对应到代码的实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// renderer/dragWindow.js\nimport { ipcRenderer } from 'electron';\n\nconst useDrag = () => {\n  let animationId;\n  let mouseX;\n  let mouseY;\n  let clientWidth = 0;\n  let clientHeight = 0;\n  let draggable = true;\n\n  const onMouseDown = (e) => {\n    // 右击不移动，只有左击的时候触发\n    if (e.button === 2) return;\n    draggable = true;\n    // 记录位置\n    mouseX = e.clientX;\n    mouseY = e.clientY;\n    // 记录窗口大小\n    if (Math.abs(document.body.clientWidth - clientWidth) > 5) {\n      clientWidth = document.body.clientWidth;\n    }\n    if (Math.abs(document.body.clientHeight - clientHeight) > 5) {\n      clientHeight = document.body.clientHeight;\n    }\n    // 注册 mouseup 事件\n    document.addEventListener('mouseup', onMouseUp);\n    // 启动通信\n    animationId = requestAnimationFrame(moveWindow);\n  };\n\n  const onMouseUp = () => {\n    // 释放锁\n    draggable = false;\n    // 移除 mouseup 事件\n    document.removeEventListener('mouseup', onMouseUp);\n    // 清除定时器\n    cancelAnimationFrame(animationId);\n  };\n\n  const moveWindow = () => {\n    // 传给主进程位置信息\n    ipcRenderer.send('msg-trigger', {\n      type: 'windowMoving',\n      data: { mouseX, mouseY, width: clientWidth, height: clientHeight },\n    });\n    if (draggable) animationId = requestAnimationFrame(moveWindow);\n  };\n\n  return {\n    onMouseDown,\n  };\n};\n\nexport default useDrag;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// main.js\npublic windowMoving({ data: { mouseX, mouseY, width, height } }, window, e) {\n  // 获取当前鼠标的绝对位置。\n  const { x, y } = screen.getCursorScreenPoint();\n  // 获取当前需要移动的窗口\n  const originWindow = this.getCurrentWindow(window, e);\n  if (!originWindow) return;\n  // 重新设置窗口位置\n  originWindow.setBounds({ x: x - mouseX, y: y - mouseY, width, height });\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但这么做也有一些问题，首先就是渲染进程需要主进程直接进行通信，通信需要一定时间，所以窗口的移动必然慢于鼠标的移动，会造成一定程度的卡顿。其次，只能通过 ",(0,r.jsx)(n.code,{children:"document.removeEventListener('mouseup')"})," 的方法来注销对鼠标移动事件的监听，这个跟第一点接到一起就可能出现这样一种情况：鼠标移动得太快，界面没来得及跟得上，导致鼠标在界面外部释放，未能触发 ",(0,r.jsx)(n.code,{children:"mouseup"})," 事件，后面就会出现鼠标不管移动到哪里，界面都会跟着，特别烦人！\uD83D\uDE20"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-使用-electron-drag-库",children:["3. 使用 electron-drag 库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-使用-electron-drag-库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["相对于我们方案 2 提到问题，主要是因为我们需要监听鼠标的 ",(0,r.jsx)(n.code,{children:"mousedown"})," 和 ",(0,r.jsx)(n.code,{children:"mouseup"})," 事件必须要和 ",(0,r.jsx)(n.code,{children:"DOM"})," 绑定。所以如何实现系统级别的 ",(0,r.jsx)(n.code,{children:"mousedown"})," 和 ",(0,r.jsx)(n.code,{children:"mouseup"})," 就成了关键所在。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/kapetan/electron-drag",target:"_blank",rel:"noopener noreferrer",children:"electron-drag"})," 模块使用 ",(0,r.jsx)(n.code,{children:"osx-mouse"})," 或 ",(0,r.jsx)(n.code,{children:"win-mouse"})," 模块来跟踪整个屏幕上的鼠标位置，从而实现了一致的窗口拖动，同时受影响的元素仍能够接收 DOM 事件。使用方式也非常方便："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// app.vue\nimport drag from 'electron-drag-latest';\n\nconst undrag = drag('#app');\n\n// 如果不需要拖拽，调用 undrag 函数\n// undrag()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["完整代码见：",(0,r.jsx)(n.a,{href:"https://github.com/muwoo/electron-drag-latest/blob/master/test/index.html",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/muwoo/electron-drag-latest/blob/master/test/index.html"})]}),"\n",(0,r.jsxs)(n.p,{children:["但需要注意的是，",(0,r.jsx)(n.code,{children:"electron-drag"})," 仅支持 ",(0,r.jsx)(n.code,{children:"macOS"})," 和 ",(0,r.jsx)(n.code,{children:"windows"})," 操作系统，其他平台都不支持。因此，我们可以在不支持的平台上使用第二种方案来实现。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["注意：electron-drag 因为依赖了 ",(0,r.jsx)(n.code,{children:"osx-mouse"})," 或 ",(0,r.jsx)(n.code,{children:"win-mouse"})," 模块，而这两个模块都是需要进行 C++ 额外本地编译的，所以你可能还需要用 ",(0,r.jsx)(n.code,{children:"electron-rebuild"})," 进行重新编译。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"自定义窗口标题栏",children:["自定义窗口标题栏",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义窗口标题栏",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面说到无边框窗口是一种不带外壳（包括窗口边框、工具栏等）、只含有网页内容的窗口。但是有的时候，我们还是希望要包含工具栏和标题。这样不仅可以方便用户进行窗口最大化、最小化和关闭的操作，我们还可以融合一些自定义的操作能力进入标题栏。"}),"\n",(0,r.jsxs)(n.p,{children:["这种情况下，我们就需要实现一种自定义标题栏了，但这种自定义标题栏，在 ",(0,r.jsx)(n.code,{children:"Electron"})," 中，",(0,r.jsx)(n.code,{children:"Windows"})," 和 ",(0,r.jsx)(n.code,{children:"macOS"})," 的实现和样式是不一样的。接下来将详细介绍。"]}),"\n",(0,r.jsxs)(n.h3,{id:"1-windows-下自定义标题栏",children:["1. Windows 下自定义标题栏",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-windows-下自定义标题栏",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 Electron 中，我们可以通过 ",(0,r.jsx)(n.code,{children:"frame = false"})," 设置无边框窗口。再通过 ",(0,r.jsx)(n.code,{children:"titleBarStyle = 'hidden'"})," 和 ",(0,r.jsx)(n.code,{children:"titleBarOverlay"})," 的方式来创建一个带有操作栏的无边框窗口："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'new BrowserWindow({\n  width: 800,\n  height: 600,\n  titleBarStyle: \'hidden\',\n  // 在windows上，设置默认显示窗口控制工具\n  titleBarOverlay: { color: "#fff", symbolColor: "black", }\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"但是这样的无边框窗口仅能实现通用的样式，而且样式也比较奇怪：控制区域图标大小、间距无法修改，也没法内置其他的操作图标进去。"}),"\n",(0,r.jsx)(n.p,{children:"所以这个时候，在 windows 中，如果想要实现下面这样的效果（有自定义的标题、icon 图标），那么就不得不重新实现一个自定义的标题栏。"}),"\n",(0,r.jsx)(n.p,{children:"这种实现也很简单，首先就是构造一个不带控制栏的窗口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"new BrowserWindow({\n  autoHideMenuBar: true,\n  // 无边框窗口\n  frame: true,\n  // 无标题\n  titleBarStyle: 'hidden',\n  show: false,\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后在渲染进程中，自己 ",(0,r.jsx)(n.strong,{children:"“画一个标题栏”"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<div class="info">\n  <img :src="plugInfo.logo"/>\n  <span>rubick 系统菜单</span>\n</div>\n<div class="handle-container">\n  <div class="handle">\n    <div class="devtool" @click="openDevTool" title="开发者工具"></div>\n  </div>\n  <div class="window-handle" v-if="process.platform !== \'darwin\'">\n    <div class="minimize" @click="minimize"></div>\n    <div class="maximize" @click="maximize"></div>\n    <div class="close" @click="close"></div>\n  </div>\n</div>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["然后定义一下 ",(0,r.jsx)(n.code,{children:"icon"})," 的样式："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:'.minimize {\n  background: center / 20px no-repeat url("./assets/minimize.svg");\n}\n\n.maximize {\n  background: center / 20px no-repeat url("./assets/maximize.svg");\n}\n\n.unmaximize {\n  background: center / 20px no-repeat url("./assets/unmaximize.svg");\n}\n\n.close {\n  background: center / 20px no-repeat url("./assets/close.svg");\n}\n\n.close:hover {\n  background-color: #e53935;\n  background-image: url("./assets/close-hover.svg");\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["最后，渲染进程中通过 ",(0,r.jsx)(n.code,{children:"ipcRenderer"})," 向主进程中发送操作事件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 最小化\nconst minimize = () => {\n  ipcRenderer.send('detach:service', { type: 'minimize' });\n};\n// 最大化\nconst maximize = () => {\n  ipcRenderer.send('detach:service', { type: 'maximize' });\n};\n// 关闭窗口\nconst close = () => {\n  ipcRenderer.send('detach:service', { type: 'close' });\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"主进程对操作事件进行响应："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"ipcMain.on('detach:service', async (event, arg: { type: string }) => {\n  operation[arg.type]();\n});\n\nconst operation = {\n  minimize: () => {\n    win.focus();\n    win.minimize();\n  },\n  maximize: () => {\n    win.isMaximized() ? win.unmaximize() : win.maximize();\n  },\n  close: () => {\n    win.close();\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["关于自定义窗口标题栏的完整代码可以看这里：",(0,r.jsx)(n.a,{href:"https://github.com/rubickCenter/rubick/blob/master/detach/src/App.vue",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/rubickCenter/rubick/blob/master/detach/src/App.vue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-macos-下自定义菜单栏",children:["2. macOS 下自定义菜单栏",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-macos-下自定义菜单栏",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"macOS"})," 中，要实现上面的自定义菜单栏还是比较方便的，因为 ",(0,r.jsx)(n.code,{children:"macOS"})," 的操作栏主要是红绿灯效果，而且 ",(0,r.jsx)(n.code,{children:"macOS"})," 的交互方式都是将红绿灯统一放在窗口的左上角："]}),"\n",(0,r.jsxs)(n.p,{children:["所以对于 ",(0,r.jsx)(n.code,{children:"macOS"})," 下，自定义菜单栏的交互就是下面这样："]}),"\n",(0,r.jsx)(n.p,{children:"这里，我们不需要再手动实现关闭、缩小、放大等系统功能了，只需要调整一下红绿灯的位置就可以了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"new BrowserWindow({\n  // ... \n  // 设置 macOS 下红绿灯的位置\n  trafficLightPosition: { x: 12, y: 21 },\n  // ...\n})\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本小节，我们完成了对 ",(0,r.jsx)(n.code,{children:"Electron"})," 常用的 ",(0,r.jsx)(n.code,{children:"无边框窗口"})," 和 ",(0,r.jsx)(n.code,{children:"自定义窗口标题栏"})," 的介绍，它们相对于默认的系统窗口而言，需要处理一些小的交互问题。希望通过本小节的介绍，可以让你清楚地了解这些问题背后的原因和解决问题的方式。"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC09%E7%AB%A0%E2%80%94%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AA%97%E5%8F%A3%E7%9A%84%E6%8B%96%E6%8B%BD%E5%92%8C%E7%BC%A9%E6%94%BE.md"]={toc:[{text:"无边框窗口的拖拽",id:"无边框窗口的拖拽",depth:2},{text:"1. 使用 -webkit-app-region: drag",id:"1-使用--webkit-app-region-drag",depth:3},{text:"2. 自定义拖拽事件",id:"2-自定义拖拽事件",depth:3},{text:"3. 使用 electron-drag 库",id:"3-使用-electron-drag-库",depth:3},{text:"自定义窗口标题栏",id:"自定义窗口标题栏",depth:2},{text:"1. Windows 下自定义标题栏",id:"1-windows-下自定义标题栏",depth:3},{text:"2. macOS 下自定义菜单栏",id:"2-macos-下自定义菜单栏",depth:3},{text:"总结",id:"总结",depth:2}],title:"第09章—实战篇：自定义窗口的拖拽和缩放",headingTitle:"第09章—实战篇：自定义窗口的拖拽和缩放",frontmatter:{}}}}]);