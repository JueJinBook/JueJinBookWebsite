"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["61658"],{431141:function(e,n,t){t.r(n),t.d(n,{default:()=>k});var c=t(552676),r=t(740453);let s=t.p+"static/image/cc7431ebb5eb80f0190ebbef9c226f33.3887c113.webp",a=t.p+"static/image/b21ebc65dd93c18d94fa3fc071d9ffab.4df999ec.webp",i=t.p+"static/image/d4a4e5593e3810b32248717083d1793c.a91a0449.webp",d=t.p+"static/image/0aea2b181b4ec68e67cd37ad1a68bf2b.fcf7e6c9.gif",l=t.p+"static/image/0aa29253750ef11cb65cd590f2eef0f9.d3177d94.gif",u=t.p+"static/image/a8bdd0caa53ca7d3adadb6ad1118dd24.3de7d0bb.webp",o=t.p+"static/image/391ed9c4a2a2e590e1af1480b29efd0b.9939e6e5.webp",p=t.p+"static/image/21107aca37fa8e5c6f458964d7080895.ecd98787.gif",f=t.p+"static/image/84029e6732df779ebb49a64390a537b5.9c23fe1b.webp",h=t.p+"static/image/a57232e46239f358186ff781e3255556.6772edfe.gif",j=t.p+"static/image/534bdf6e63832550ad6ca2bed359323b.0f803768.webp",x=t.p+"static/image/0213f9801d34b169cd5f3a4e83fb199b.c6d87aba.webp",m=t.p+"static/image/0355c42ce8af537522505571f179501d.33ff9488.webp",b=t.p+"static/image/a34a15952f14dd353875fb5a9c161bf6.283cdee9.webp",g=t.p+"static/image/77eb740a758475a263241cefa066dffe.93a2ee91.webp";function E(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"第03章hook的闭包陷阱的成因和解决方案",children:["第03章—Hook的闭包陷阱的成因和解决方案",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第03章hook的闭包陷阱的成因和解决方案",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"\uFEFF上节我们学习了各种 hook，用这些 hook 写组件的时候经常遇到一个问题，就是闭包陷阱。"}),"\n",(0,c.jsx)(n.p,{children:"这节我们了解下什么是闭包陷阱，如何解决闭包陷阱。"}),"\n",(0,c.jsx)(n.p,{children:"用 cra 创建个项目："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npx create-react-app --template typescript closure-trap\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"改一下 index.tsx："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(<App />);\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后看这样一个组件，通过定时器不断的累加 count："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\n\nfunction App() {\n\n    const [count,setCount] = useState(0);\n\n    useEffect(() => {\n        setInterval(() => {\n            console.log(count);\n            setCount(count + 1);\n        }, 1000);\n    }, []);\n\n    return <div>{count}</div>\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"大家觉得这个 count 会每秒加 1 么？"}),"\n",(0,c.jsx)(n.p,{children:"不会。"}),"\n",(0,c.jsx)(n.p,{children:"可以看到，setCount 时拿到的 count 一直是 0:"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,c.jsx)(n.p,{children:"大家可能觉得，每次渲染都引用最新的 count，然后加 1，所以觉得没问题："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"但是，现在 useEffect 的依赖数组是 []，也就是只会执行并保留第一次的 function。"}),"\n",(0,c.jsx)(n.p,{children:"而第一次的 function 引用了当时的 count，形成了闭包。"}),"\n",(0,c.jsx)(n.p,{children:"也就是实际上的执行是这样的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这就导致了每次执行定时器的时候，都是在 count = 0 的基础上加一。"}),"\n",(0,c.jsx)(n.p,{children:"这就叫做 hook 的闭包陷阱。"}),"\n",(0,c.jsxs)(n.h2,{id:"第一种解法",children:["第一种解法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一种解法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"那怎么解决这个问题呢？"}),"\n",(0,c.jsx)(n.p,{children:"不让它形成闭包不就行了？"}),"\n",(0,c.jsx)(n.p,{children:"这时候可以用 setState 的另一种参数："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这次并没有形成闭包，每次的 count 都是参数传入的上一次的 state。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这样功能就正常了。"}),"\n",(0,c.jsx)(n.p,{children:"和用 setState 传入函数的方案类似，还可以用 useReducer 来解决。"}),"\n",(0,c.jsx)(n.p,{children:"因为它是 dispatch 一个 action，不直接引用 state，所以也不会形成闭包："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { Reducer, useEffect, useReducer } from \"react\";\n\ninterface Action {\n    type: 'add' | 'minus',\n    num: number\n}\n\nfunction reducer(state: number, action: Action) {\n\n    switch(action.type) {\n        case 'add':\n            return state + action.num\n        case 'minus': \n            return state - action.num\n    }\n    return state;\n}\n\nfunction App() {\n    const [count, dispatch] = useReducer<Reducer<number, Action>>(reducer, 0);\n\n    useEffect(() => {\n        console.log(count);\n\n        setInterval(() => {\n            dispatch({ type: 'add', num: 1 })\n        }, 1000);\n    }, []);\n\n    return <div>{count}</div>;\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"思路和 setState 传入函数一样，所以算是一种解法。"}),"\n",(0,c.jsxs)(n.h2,{id:"第二种解法",children:["第二种解法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二种解法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"但有的时候，是必须要用到 state 的，也就是肯定会形成闭包，"}),"\n",(0,c.jsx)(n.p,{children:"比如这里，console.log 的 count 就用到了外面的 count，形成了闭包，但又不能把它挪到 setState 里去写："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这种情况怎么办呢？"}),"\n",(0,c.jsx)(n.p,{children:"还记得 useEffect 的依赖数组是干啥的么？"}),"\n",(0,c.jsx)(n.p,{children:"当依赖变动的时候，会重新执行 effect。"}),"\n",(0,c.jsx)(n.p,{children:"所以可以这样："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\n\nfunction App() {\n\n    const [count,setCount] = useState(0);\n\n    useEffect(() => {\n        console.log(count);\n\n        const timer = setInterval(() => {\n            setCount(count + 1);\n        }, 1000);\n\n        return () => {\n            clearInterval(timer);\n        }\n    }, [count]);\n\n    return <div>{count}</div>\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"依赖数组加上了 count，这样 count 变化的时候重新执行 effect，那执行的函数引用的就是最新的 count 值。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这种解法是能解决闭包陷阱的，但在这里并不合适，因为 effect 里跑的是定时器，每次都重新跑定时器，那定时器就不是每 1s 执行一次了。"}),"\n",(0,c.jsxs)(n.h2,{id:"第三种解法",children:["第三种解法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三种解法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"有定时器不能重新跑 effect 函数，那怎么做呢？"}),"\n",(0,c.jsx)(n.p,{children:"可以用 useRef。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState, useRef, useLayoutEffect } from 'react';\n\nfunction App() {\n    const [count, setCount] = useState(0);\n\n    const updateCount = () => {\n        setCount(count + 1);\n    };\n    const ref = useRef(updateCount);\n\n    ref.current = updateCount;\n\n    useEffect(() => {\n        const timer = setInterval(() => ref.current(), 1000);\n\n        return () => {\n            clearInterval(timer);\n        }\n    }, []);\n\n    return <div>{count}</div>;\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"通过 useRef 创建 ref 对象，保存执行的函数，每次渲染更新 ref.current 的值为最新函数。"}),"\n",(0,c.jsx)(n.p,{children:"这样，定时器执行的函数里就始终引用的是最新的 count。"}),"\n",(0,c.jsx)(n.p,{children:"useEffect 只跑一次，保证 setIntervel 不会重置，是每秒执行一次。"}),"\n",(0,c.jsx)(n.p,{children:"执行的函数是从 ref.current 取的，这个函数每次渲染都会更新，引用着最新的 count。"}),"\n",(0,c.jsx)(n.p,{children:"跑一下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"功能正常。"}),"\n",(0,c.jsx)(n.p,{children:"讲 useRef 的时候说过，ref.current 的值改了不会触发重新渲染，"}),"\n",(0,c.jsx)(n.p,{children:"它就很适合这种保存渲染过程中的一些数据的场景。"}),"\n",(0,c.jsx)(n.p,{children:"其实定时器的这种处理是常见场景，我们可以把它封装一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState, useRef } from 'react';\n\nfunction useInterval(fn: Function, delay?: number | null) {\n    const callbackFn = useRef(fn);\n\n    useLayoutEffect(() => {\n        callbackFn.current = fn;\n    });\n    \n    useEffect(() => {\n        const timer = setInterval(() => callbackFn.current(), delay || 0);\n\n        return () => clearInterval(timer);\n    }, []);\n}\n\nfunction App() {\n    const [count, setCount] = useState(0);\n\n    const updateCount = () => {\n        setCount(count + 1);\n    };\n\n    useInterval(updateCount, 1000);\n\n    return <div>{count}</div>;\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"这里我们封装了个 useInterval 的函数，传入 fn 和 delay，里面会用 useRef 保存并更新每次的函数。"}),"\n",(0,c.jsx)(n.p,{children:"我们在 useLayoutEffect 里更新 ref.current 的值，它是在 dom 操作完之后同步执行的，比 useEffect 更早。"}),"\n",(0,c.jsx)(n.p,{children:"通过 useEffect 来跑定时器，依赖数组为 [delay]，确保定时器只跑一次，但是 delay 变化的话会重新跑。"}),"\n",(0,c.jsx)(n.p,{children:"在 useEffect 里返回 clean 函数在组件销毁的时候自动调用来清理定时器。"}),"\n",(0,c.jsx)(n.p,{children:"这种就叫做自定义 hook，它就是普通的函数封装，没啥区别。"}),"\n",(0,c.jsx)(n.p,{children:"这样，组件里就可以直接用 useInterval 这个自定义 hook，不用每次都 useRef + useEffect 了。"}),"\n",(0,c.jsx)(n.p,{children:"有的同学可能会说，直接在渲染过程中该 ref.current 不也一样么，为啥包一层 useLayoutEffect？"}),"\n",(0,c.jsx)(n.p,{children:"确实，从结果来看是一样的。"}),"\n",(0,c.jsxs)(n.p,{children:["但是",(0,c.jsx)(n.a,{href:"https://react.dev/reference/react/useRef#caveats",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"里不建议："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["不过这也没啥，ahooks 里就是直接在渲染过程中",(0,c.jsx)(n.a,{href:"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts#L23",target:"_blank",rel:"noopener noreferrer",children:"改了 ref.current"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"上面的 useInterval 没有返回 clean 函数，调用者不能停止定时器，所以我们再加一个 ref 来保存 clean 函数，然后返回："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function useInterval(fn: Function, time: number) {\n    const ref = useRef(fn);\n\n    ref.current = fn;\n\n    let cleanUpFnRef = useRef<Function>();\n    \n    const clean = useCallback(() =>{\n        cleanUpFnRef.current?.();\n    }, []);\n\n    useEffect(() => {\n        const timer = setInterval(() => ref.current(), time);\n\n        cleanUpFnRef.current = ()=> {\n            clearInterval(timer);\n        }\n\n        return clean;\n    }, []);\n\n    return clean;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"为什么要用 useCallback 包裹返回的函数呢？"}),"\n",(0,c.jsx)(n.p,{children:"因为这个返回的函数可能作为参数传入别的组件，这样用 useCallback 包裹就可以避免该参数的变化，配合 memo 可以起到减少没必要的渲染的效果。"}),"\n",(0,c.jsxs)(n.p,{children:["案例代码上传了",(0,c.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/closure-trap",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这节我们学习了闭包陷阱和它的三种解决方案。"}),"\n",(0,c.jsx)(n.p,{children:"闭包陷阱就是 effect 函数等引用了 state，形成了闭包，但是并没有把 state 加到依赖数组里，导致执行 effect 时用的 state 还是之前的。"}),"\n",(0,c.jsx)(n.p,{children:"这个问题有三种解决方案："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"使用 setState 的函数的形式，从参数拿到上次的 state，这样就不会形成闭包了，或者用 useReducer，直接 dispatch action，而不是直接操作 state，这样也不会形成闭包"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"把用到的 state 加到依赖数组里，这样 state 变了就会重新跑 effect 函数，引用新的 state"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"使用 useRef 保存每次渲染的值，用到的时候从 ref.current 取"}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"定时器的场景需要保证定时器只跑一次，不然重新跑会导致定时不准，所以需要用 useEffect + useRef 的方式来解决闭包陷阱问题。"}),"\n",(0,c.jsx)(n.p,{children:"我们还封装了 useInterval 的自定义 hook，这样可以不用在每个组件里都写一样的 useRef + useEffect 了，直接用这个自定义 hook 就行。"}),"\n",(0,c.jsx)(n.p,{children:"此外，关于要不要在渲染函数里直接修改 ref.current，其实都可以，直接改也行，包一层 useLayoutEffect 或者 useEffect 也行。"}),"\n",(0,c.jsx)(n.p,{children:"闭包陷阱是经常会遇到的问题，要对它的成因和解决方案有清晰的认识。"})]})}function v(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(E,{...e})}):E(e)}let k=v;v.__RSPRESS_PAGE_META={},v.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC03%E7%AB%A0%E2%80%94Hook%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1%E7%9A%84%E6%88%90%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md"]={toc:[{text:"第一种解法",id:"第一种解法",depth:2},{text:"第二种解法",id:"第二种解法",depth:2},{text:"第三种解法",id:"第三种解法",depth:2},{text:"总结",id:"总结",depth:2}],title:"第03章—Hook的闭包陷阱的成因和解决方案",headingTitle:"第03章—Hook的闭包陷阱的成因和解决方案",frontmatter:{}}}}]);