"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77102"],{315736:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var a=r(552676),t=r(740453);let c=r.p+"static/image/d83dfc34ff0611fb4bac01eb87627c12.4d3ca45d.png";function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3",img:"img",em:"em"},(0,t.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"16实战案例自动埋点",children:["16.实战案例：自动埋点",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16实战案例自动埋点",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"埋点是一个常见的需求，就是在函数里面上报一些信息。像一些性能的埋点，每个函数都要处理，很繁琐。能不能自动埋点呢？"}),"\n",(0,a.jsx)(n.p,{children:"答案是可以的。埋点只是在函数里面插入了一段代码，这段代码不影响其他逻辑，这种函数插入不影响逻辑的代码的手段叫做函数插桩。"}),"\n",(0,a.jsx)(n.p,{children:"我们可以基于 babel 来实现自动的函数插桩，在这里就是自动的埋点。"}),"\n",(0,a.jsxs)(n.h2,{id:"思路分析",children:["思路分析",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"比如这样一段代码："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import aa from 'aa';\nimport * as bb from 'bb';\nimport {cc} from 'cc';\nimport 'dd';\n\nfunction a () {\n    console.log('aaa');\n}\n\nclass B {\n    bb() {\n        return 'bbb';\n    }\n}\n\nconst c = () => 'ccc';\n\nconst d = function () {\n    console.log('ddd');\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"我们要实现埋点就是要转成这样："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import _tracker2 from \"tracker\";\nimport aa from 'aa';\nimport * as bb from 'bb';\nimport { cc } from 'cc';\nimport 'dd';\n\nfunction a() {\n  _tracker2();\n\n  console.log('aaa');\n}\n\nclass B {\n  bb() {\n    _tracker2();\n\n    return 'bbb';\n  }\n\n}\n\nconst c = () => {\n  _tracker2();\n\n  return 'ccc';\n};\n\nconst d = function () {\n  _tracker2();\n\n  console.log('ddd');\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"有两方面的事情要做："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"引入 tracker 模块。如果已经引入过就不引入，没有的话就引入，并且生成个唯一 id 作为标识符"}),"\n",(0,a.jsx)(n.li,{children:"对所有函数在函数体开始插入 tracker 的代码"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"代码实现",children:["代码实现",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"模块引入",children:["模块引入",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块引入",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"引入模块这种功能显然很多插件都需要，这种插件之间的公共函数会放在 helper，这里我们使用 @babel/helper-module-imports。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const importModule = require('@babel/helper-module-imports');\n\n// 省略一些代码\nimportModule.addDefault(path, 'tracker',{\n    nameHint: path.scope.generateUid('tracker')\n})\n"})}),"\n",(0,a.jsx)(n.p,{children:"首先要判断是否被引入过：在 Program 根结点里通过 path.traverse 来遍历 ImportDeclaration，如果引入了 tracker 模块，就记录 id 到 state，并用 path.stop 来终止后续遍历；没有就引入 tracker 模块，用 generateUid 生成唯一 id，然后放到 state。"}),"\n",(0,a.jsx)(n.p,{children:"当然 default import 和 namespace import 取 id 的方式不一样，需要分别处理下。"}),"\n",(0,a.jsx)(n.p,{children:"我们把 tracker 模块名作为参数传入，通过 options.trackerPath 来取。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"Program: {\n    enter (path, state) {\n        path.traverse({\n            ImportDeclaration (curPath) {\n                const requirePath = curPath.get('source').node.value;\n                if (requirePath === options.trackerPath) {// 如果已经引入了\n                    const specifierPath = curPath.get('specifiers.0');\n                    if (specifierPath.isImportSpecifier()) { \n                        state.trackerImportId = specifierPath.toString();\n                    } else if(specifierPath.isImportNamespaceSpecifier()) {\n                        state.trackerImportId = specifierPath.get('local').toString();// tracker 模块的 id\n                    }\n                    path.stop();// 找到了就终止遍历\n                }\n            }\n        });\n        if (!state.trackerImportId) {\n            state.trackerImportId  = importModule.addDefault(path, 'tracker',{\n                nameHint: path.scope.generateUid('tracker')\n            }).name; // tracker 模块的 id\n            state.trackerAST = api.template.statement(`${state.trackerImportId}()`)();// 埋点代码的 AST\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"我们在记录 tracker 模块的 id 的时候，也生成调用 tracker 模块的 AST，使用 template.statement."}),"\n",(0,a.jsxs)(n.h3,{id:"函数插桩",children:["函数插桩",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数插桩",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"函数插桩要找到对应的函数，这里要处理的有：ClassMethod、ArrowFunctionExpression、FunctionExpression、FunctionDeclaration 这些节点。"}),"\n",(0,a.jsx)(n.p,{children:"当然有的函数没有函数体，这种要包装一下，然后修改下 return 值。如果有函数体，就直接在开始插入就行了。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"'ClassMethod|ArrowFunctionExpression|FunctionExpression|FunctionDeclaration'(path, state) {\n    const bodyPath = path.get('body');\n    if (bodyPath.isBlockStatement()) { // 有函数体就在开始插入埋点代码\n        bodyPath.node.body.unshift(state.trackerAST);\n    } else { // 没有函数体要包裹一下，处理下返回值\n        const ast = api.template.statement(`{${state.trackerImportId}();return PREV_BODY;}`)({PREV_BODY: bodyPath.node});\n        bodyPath.replaceWith(ast);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这样我们就实现了自动埋点。"}),"\n",(0,a.jsxs)(n.h2,{id:"效果演示",children:["效果演示",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#效果演示",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"我们来试下效果："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const { transformFromAstSync } = require('@babel/core');\nconst  parser = require('@babel/parser');\nconst autoTrackPlugin = require('./plugin/auto-track-plugin');\nconst fs = require('fs');\nconst path = require('path');\n\nconst sourceCode = fs.readFileSync(path.join(__dirname, './sourceCode.js'), {\n    encoding: 'utf-8'\n});\n\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous'\n});\n\nconst { code } = transformFromAstSync(ast, sourceCode, {\n    plugins: [[autoTrackPlugin, {\n        trackerPath: 'tracker'\n    }]]\n});\n\nconsole.log(code);\n"})}),"\n",(0,a.jsx)(n.p,{children:"效果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"我们实现了自动埋点！"}),"\n",(0,a.jsxs)(n.h2,{id:"扩展思考",children:["扩展思考",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展思考",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["上面实现的是一种情况，实际上可能有的函数不需要埋点，这种可以自己做一下过滤，或者在函数上写上注释，然后根据注释来过滤，就像 eslint 支持 /* eslint-disable ",(0,a.jsx)(n.em,{children:"/ 来配置 rule 的开启关闭，teser 支持 /"})," @__PURE__*/ 来配置纯函数一样。关于注释的操作，可以看另一个案例“自动生成 API 文档”。"]}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"函数插桩是在函数中插入一段逻辑但不影响函数原本逻辑，埋点就是一种常见的函数插桩，我们完全可以用 babel 来自动做。"}),"\n",(0,a.jsx)(n.p,{children:"实现思路分为引入 tracker 模块和函数插桩两部分："}),"\n",(0,a.jsx)(n.p,{children:"引入 tracker 模块需要判断 ImportDeclaration 是否包含了 tracker 模块，没有的话就用 @babel/helper-module-import 来引入。"}),"\n",(0,a.jsx)(n.p,{children:"函数插桩就是在函数体开始插入一段代码，如果没有函数体，需要包装一层，并且处理下返回值。、"}),"\n",(0,a.jsxs)(n.p,{children:["（代码在",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F16.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%9F%8B%E7%82%B9.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"模块引入",id:"模块引入",depth:3},{text:"函数插桩",id:"函数插桩",depth:3},{text:"效果演示",id:"效果演示",depth:2},{text:"扩展思考",id:"扩展思考",depth:2},{text:"总结",id:"总结",depth:2}],title:"16.实战案例：自动埋点",headingTitle:"16.实战案例：自动埋点",frontmatter:{}}}}]);