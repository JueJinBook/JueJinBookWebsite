"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75944"],{286277:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var r=s(552676),i=s(740453);let d=s.p+"static/image/849123736a97993170291df5e0aafe1a.14a1dc22.webp",l=s.p+"static/image/1cf938f81fa1ae192d41e2dd523721c3.b450caf0.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",ol:"ol"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"24-工程化使用-eslint-统一-javascript-代码规范",children:["24 工程化：使用 ESLint 统一 JavaScript 代码规范",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-工程化使用-eslint-统一-javascript-代码规范",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上一章节，我们介绍了工程化 Node.js 项目需要的配置文件 package.json。这一章节，我们开始介绍工程化所需的工具之一：ESLint。"}),"\n",(0,r.jsx)(n.p,{children:"JavaScript 语言的代码书写形式比较宽松，只要符合基本的语法，都可以正确运行。对于空白符、括号、缩进、以及分号的形式，JavaScript 并没有强制的要求。"}),"\n",(0,r.jsxs)(n.p,{children:["许多前端程序员，都有自己的书写习惯。但是，在多人维护的项目，统一代码书写风格则很有必要，因为一致的书写风格，便于维护，可以提升模块质量。因此，前端工程化的一个环节是使用工具脚本来统一代码的书写风格，目前比较流行的工具是 ",(0,r.jsx)(n.a,{href:"https://eslint.org/",target:"_blank",rel:"noopener noreferrer",children:"ESLint"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"安装-eslint",children:["安装 ESLint",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安装-eslint",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们依然是使用 NPM 安装 ESLint。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save-dev eslint\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面的命令行中，参数",(0,r.jsx)(n.code,{children:"--save-dev"}),"表示将它安装到开发依赖中（devDependencies)。"]}),"\n",(0,r.jsxs)(n.p,{children:["还记得 dependencies 字段吗？dependencies 字段表示运行时依赖，devDependencies 字段表示开发依赖。这两种依赖的区别在于，当其他开发人员通过",(0,r.jsx)(n.code,{children:"npm install isketch"}),"安装我们的项目时，它只会下载 dependencies 里的依赖，忽略 devDependencies 中的依赖。只有通过 git clone isketch，将我们的 isketch 克隆到本地，并在本地的项目中运行 ",(0,r.jsx)(n.code,{children:"npm install"})," 时，才会将两种依赖都安装到本地。"]}),"\n",(0,r.jsx)(n.p,{children:"所以，安装完成后，我们的 package.json 文件多了一个 devDependiences 字段，现在完整的内容如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{\n \xa0"name": "isketch",\n \xa0"version": "0.0.1",\n \xa0"description": "A SVG doodle for sketching",\n \xa0"main": "lib/index.js",\n \xa0"module": "src/index.js",\n \xa0"scripts": {\n \xa0 \xa0"start": "",\n \xa0 \xa0"lint": "",\n \xa0 \xa0"compile": "",\n \xa0 \xa0"build": "",\n \xa0 \xa0"deploy": "",\n \xa0 \xa0"test": "echo "Error: no test specified" && exit 1",\n \xa0 \xa0"prepublishOnly": ""\n  },\n \xa0"keywords": [],\n \xa0"author": "junyux",\n \xa0"license": "MIT",\n \xa0"devDependencies": {\n \xa0 \xa0"eslint": "^7.0.0"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["然后，我们需要在 scripts 字段中配置 eslint 的脚本命令，指定",(0,r.jsx)(n.code,{children:"eslint"}),"检查哪些目录和文件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{\n \xa0...\n \xa0"scripts": {\n \xa0 \xa0"start": "",\n \xa0 \xa0"lint": "eslint \'./**/*.js\'",\n \xa0 \xa0"compile": "",\n \xa0 \xa0"build": "",\n \xa0 \xa0"test": "echo "Error: no test specified" && exit 1",\n \xa0 \xa0"prepublishOnly": ""\n  },\n \xa0...\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面的代码中，",(0,r.jsx)(n.code,{children:"eslint './**/*.js'"})," 是 eslint 的命令行指令，表示检查项目内所有的 js 文件。",(0,r.jsx)(n.code,{children:'"lint": "eslint \'./**/*.js\'"'}),"是对 eslint 命令进行包装，这样我们可以通过",(0,r.jsx)(n.code,{children:"npm run lint"})," 执行 eslint 的命令行，对我们的 js 文件进行语法检查。"]}),"\n",(0,r.jsx)(n.p,{children:"安装好 ESLint 后，我们还需要配置一下检查规则。"}),"\n",(0,r.jsxs)(n.h2,{id:"配置-eslint-规则",children:["配置 ESLint 规则",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置-eslint-规则",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在配置规则之前，如果我们直接执行",(0,r.jsx)(n.code,{children:"npm run lint"}),"，会出现下面的结果："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> eslint './**/*.js'\n​\n​\nOops! Something went wrong! :(\n​\nESLint: 7.0.0\n​\nNo files matching the pattern \"./**/*.js\" were found.\nPlease check for typing mistakes in the pattern.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为，",(0,r.jsx)(n.code,{children:"eslint"}),"并没有强制指定某种代码风格，需要我们进行配置。ESLint 的代码风格配置项比较复杂，大约有数百项，有兴趣一一配置的同学可以去看它的",(0,r.jsx)(n.a,{href:"https://eslint.org/docs/rules/",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"ESLint 内置了默认的配置规则，所以我们可以方便地通过几行配置搞定。"}),"\n",(0,r.jsx)(n.p,{children:"首先我们创建一个 .eslintrc.js 文件，这个文件在上一章节我们的目录中有列出，它是 ESLint 规则文件。这个文件的内容如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module.exports = {\n \xa0env: {\n \xa0 \xa0node: true,\n \xa0 \xa0browser: true,\n \xa0 \xa0es6: true,\n  },\n \xa0extends: 'eslint:recommended',\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"eslint 配置项的 env 属性是 JavaScript 运行时环境，我们将 node 和 browser 都配置为 true，表示我们的代码既可以运行在 Node.js 也可以运行在浏览器上。这样一来，使用 Node.js 和浏览器内置的 API 对象就不会报未定义变量的错误了。"}),"\n",(0,r.jsx)(n.p,{children:"因为我们的代码要支持较新的 JavaScript 语法，所以也设置 env 中的 es6 属性为 true。"}),"\n",(0,r.jsxs)(n.p,{children:["extends 表示继承的规则，ESLint 的配置规则是可以继承的，我们可以通过 NPM 安装某个规则，然后继承它，其中",(0,r.jsx)(n.code,{children:"eslint:recommanded"}),"是 eslint 默认推荐的规则，不需要安装额外的依赖。"]}),"\n",(0,r.jsxs)(n.p,{children:["除了继承",(0,r.jsx)(n.code,{children:"eslint:recommanded"}),"之外，也可以继承其他的规则，目前比较流行的规则有 ",(0,r.jsx)(n.a,{href:"https://github.com/doasync/eslint-config-airbnb-standard",target:"_blank",rel:"noopener noreferrer",children:"eslint-config-airbnb"}),"、",(0,r.jsx)(n.a,{href:"https://github.com/google/eslint-config-google",target:"_blank",rel:"noopener noreferrer",children:"eslint-config-google"}),"等，稍后我们会看到如何继承它们。"]}),"\n",(0,r.jsx)(n.p,{children:"接下来我们先看一下如何配置扩展到 lint 规则。我们先在 isketch 下创建 src/math/index.js 文件，随便写一点东西，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"var message = 'Hello world';\nconsole.log(message);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后执行",(0,r.jsx)(n.code,{children:"npm run lint"}),"，会看到现在 eslint 命令运行完没有错误输出，因为我们现在写的代码风格符合",(0,r.jsx)(n.code,{children:"eslint:recommanded"}),"的要求。"]}),"\n",(0,r.jsxs)(n.p,{children:["接着，我们添加一下规则，我们修改",(0,r.jsx)(n.code,{children:".eslintrc.js"}),"文件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'module.exports = {\n \xa0env: {\n \xa0 \xa0node: true,\n \xa0 \xa0browser: true,\n \xa0 \xa0es6: true,\n  },\n \xa0extends: \'eslint:recommended\',\n \xa0rules: {\n \xa0 \xa0"no-var": "error",\n  },\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"no-var": "error"'})," 是一条 rules 规则，一般的配置为",(0,r.jsx)(n.code,{children:"规则名: 警告等级"}),"。",(0,r.jsx)(n.code,{children:'"no-var"'}),"表示不能使用 var 声明，否则违反该规则，就会报告错误。"]}),"\n",(0,r.jsxs)(n.p,{children:["所以，我们再次运行",(0,r.jsx)(n.code,{children:"npm run lint"}),"命令，就会看到以下输出结果："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> eslint './**/*.js'\n​\n​\n/.../isketch/src/math/index.js\n \xa01:1  error  Unexpected var, use let or const instead  no-var\n​\n✖ 1 problem (1 error, 0 warnings)\n \xa01 error and 0 warnings potentially fixable with the `--fix` option.\n"})}),"\n",(0,r.jsx)(n.p,{children:"输出结果中报告了一个错误，要求使用 let 或 const 替代 var 声明变量。"}),"\n",(0,r.jsxs)(n.p,{children:["我们可以修改一下警告等级，比如改成",(0,r.jsx)(n.code,{children:'"no-var": "warn"'}),"，这样的话，eslint 将不会报告错误，而是报告一条警告信息。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> eslint './**/*.js'\n\n\n/.../isketch/src/math/index.js\n  1:1  warning  Unexpected var, use let or const instead  no-var\n\n✖ 1 problem (0 errors, 1 warning)\n  0 errors and 1 warning potentially fixable with the `--fix` option.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["ESLint 的警告等级有 3 种：",(0,r.jsx)(n.code,{children:"error"}),"表示报告错误；",(0,r.jsx)(n.code,{children:"warn"}),"表示不报错，只提示警告信息；",(0,r.jsx)(n.code,{children:"off"}),"表示不检查该规则。"]}),"\n",(0,r.jsxs)(n.h2,{id:"与编辑器联动",children:["与编辑器联动",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与编辑器联动",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在大部分主流的代码编辑器都支持 ESLint 插件，比如你使用 VisualStudio Code，那么你可以安装 ESLint 插件，就可以直接在代码中显示出 ESLint 规则的提示信息："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["因为我们刚才把警告等级改为",(0,r.jsx)(n.code,{children:"warn"}),"了，所以现在显示出的是黄色的波浪线。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们将",(0,r.jsx)(n.code,{children:"no-var"}),"规则的警告等级改回",(0,r.jsx)(n.code,{children:"error"}),"，那么波浪线的颜色就变成红色的了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"使用 eslint 配合编辑器插件，可以帮助我们快速找到代码错误或者不规范的地方，有助于我们养成良好代码风格的书写习惯。"}),"\n",(0,r.jsxs)(n.h2,{id:"--fix-自动修复",children:["--fix 自动修复",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#--fix-自动修复",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["用 ESLint 发现代码的问题后，我们可以选择手工修复代码，或者依赖 eslint 自动修复。要依赖 eslint 自动修复，我们可以添加一个 NPM Scripts 叫做",(0,r.jsx)(n.code,{children:"lint:fix"}),"，执行 eslint 命令的同时带上参数",(0,r.jsx)(n.code,{children:"--fix"}),"，这样执行代码检查的时候就会自动修复问题了。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{\n  ...\n  "scripts": {\n    "start": "",\n    "lint": "eslint \'./**/*.js\'",\n    "lint:fix": "eslint \'./**/*.js\' --fix",\n    "compile": "",\n    "build": "",\n    "test": "echo "Error: no test specified" && exit 1",\n    "prepublishOnly": ""\n  },\n  ...\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们执行",(0,r.jsx)(n.code,{children:"npm run lint:fix"}),"，之后再打开",(0,r.jsx)(n.code,{children:"src/index.js"}),"文件，你就会发现代码",(0,r.jsx)(n.code,{children:"var message = 'Hello world';"}),"被自动替换成了",(0,r.jsx)(n.code,{children:"let message = 'Hello world';"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"自动配置-eslint",children:["自动配置 ESLint",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自动配置-eslint",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["前面我们通过手工配置",(0,r.jsx)(n.code,{children:".eslintrc.js"}),"文件，实际上 ESLint 还支持自动配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'{\n  ...\n  "scripts": {\n    ...\n    "lint": "eslint \'./**/*.js\'",\n    "lint:fix": "eslint \'./**/*.js\' --fix",\n    "lint:init": "eslint --init",\n    ...\n  },\n  ...\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们添加一个",(0,r.jsx)(n.code,{children:"lint:init"}),"命令行脚本，然后运行它："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run lint:init\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样 ESLint 就会启动交互式配置的命令，帮助我们配置合适于我们项目的 ESLint 检查规则。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> eslint --init\n\n? How would you like to use ESLint? To check syntax, find problems, and enforce \ncode style\n? What type of modules does your project use? JavaScript modules (import/export)\n\n\n? Which framework does your project use? None of these\n? Does your project use TypeScript? No\n? Where does your code run? Browser, Node\n? How would you like to define a style for your project? Use a popular style gui\nde\n? Which style guide do you want to follow? Standard: https://github.com/standard\n/standard\n? What format do you want your config file to be in? JavaScript\n"})}),"\n",(0,r.jsxs)(n.p,{children:["执行",(0,r.jsx)(n.code,{children:"eslint --init"}),"会询问我们几个问题，根据我们的回答初始化配置文件，而且会让我们选择继承常用的代码风格，包括 ",(0,r.jsx)(n.a,{href:"https://github.com/doasync/eslint-config-airbnb-standard",target:"_blank",rel:"noopener noreferrer",children:"Airbnb"})," 风格、",(0,r.jsx)(n.a,{href:"https://github.com/standard/eslint-config-standard",target:"_blank",rel:"noopener noreferrer",children:"Standard"})," 和 ",(0,r.jsx)(n.a,{href:"https://github.com/google/eslint-config-google",target:"_blank",rel:"noopener noreferrer",children:"Google"})," 风格，我们可以选择适合我们团队的风格。比如选择 Standard 风格，最终生成的",(0,r.jsx)(n.code,{children:".eslintrc.js"}),"配置文件如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module.exports = {\n  env: {\n    browser: true,\n    es6: true,\n    node: true\n  },\n  extends: [\n    'standard'\n  ],\n  globals: {\n    Atomics: 'readonly',\n    SharedArrayBuffer: 'readonly'\n  },\n  parserOptions: {\n    ecmaVersion: 11,\n    sourceType: 'module'\n  },\n  rules: {\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里面有些是我们前面没有介绍过的属性，我们看一下，env 我们介绍过了不提，extends 从",(0,r.jsx)(n.code,{children:"eslint:recommended"}),"换成",(0,r.jsx)(n.code,{children:"standard"}),"风格。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"globals 是内置全局变量，因为 ESLint 支持最新的 JavaScript 规范，在 ES2017 中有两个新的全局对象 Atomics 和 SharedArrayBuffer。"}),"\n",(0,r.jsxs)(n.li,{children:["parserOptions 指定解析器版本，这里设置 ecmaVersion 值为 11，是目前最新的语言标准。ecmaVersion 这个属性目前可以设置",(0,r.jsx)(n.code,{children:"3、5、6、7、8、9、10、11"}),"，3、5 表示 ES3 和 ES5，6、7、8、9、10、11 分别表示 ES2015、ES2016、ES2017、ES2018、ES2019 和 ES2020；sourceType 为",(0,r.jsx)(n.code,{children:"module"}),"，表示支持 ES Modules 模块规范。"]}),"\n",(0,r.jsx)(n.li,{children:"rules 字段是扩展规则，暂时为空，我们可以根据需要添加。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["然后，我们再次运行",(0,r.jsx)(n.code,{children:"npm run lint"}),"，发现这次多了几个错误信息："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> eslint './**/*.js'\n\n\n/.../isketch/math/src/index.js\n  1:5   error  'message' is never reassigned. Use 'const' instead  prefer-const\n  1:28  error  Extra semicolon                                     semi\n  2:21  error  Extra semicolon                                     semi\n  2:22  error  Newline required at end of file but not found       eol-last\n"})}),"\n",(0,r.jsxs)(n.p,{children:["因为 Standard 风格比默认的",(0,r.jsx)(n.code,{children:"eslint:recommended"}),"更严格，这次 ESLint 报的错误如下："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"message"}),"变量没有被再次赋值，应当使用",(0,r.jsx)(n.code,{children:"const"}),"声明；"]}),"\n",(0,r.jsx)(n.li,{children:"两条语句多余分号（Standard 采用 semiless 风格，不主动写分号）；"}),"\n",(0,r.jsx)(n.li,{children:"文件最后保留一个空行。\nStandard 是 semiless 风格，不主动写分号，如果你不喜欢不写分号，可以扩展 rules，添加如下："}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module.exports = {\n  ...\n  rules: {\n    semi: ['error', 'always']\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"semi"}),"是分号书写规则，",(0,r.jsx)(n.code,{children:"['error', 'always']"}),"表示警告级别是",(0,r.jsx)(n.code,{children:"error"}),"，需要总是(always)书写分号。这样，错误信息就只剩下两条。然后，我们执行",(0,r.jsx)(n.code,{children:"npm run lint:fix"}),"自动修复错误。最终",(0,r.jsx)(n.code,{children:"src/index.js"}),"代码被修改为如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const message = 'Hello world';\nconsole.log(message);\n// 这里是空行\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"ESLint 是工程化中的一个重要的规范代码书写的工具。在多人协作开发项目中，它能够统一每个开发者的代码书写风格，提高项目的可维护性。"}),"\n",(0,r.jsx)(n.p,{children:"那么，安装和使用 ESLint 工具的步骤如下。"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["通过",(0,r.jsx)(n.code,{children:"npm install --save-dev eslint"}),"将 eslint 安装到项目的开发依赖中。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"创建 eslint 规则文件 —— .eslintrc.js。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"在 package.json 中设置 eslint 的命令行配置："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"lint": "eslint \'./**/*.js\'"'})," 表示运行 eslint 命令行脚本，检查项目下所有 js 文件的代码规范；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"lint:fix": "eslint \'./**/*.js\' --fix"'})," 表示自动修复代码书写错误；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"lint:init": "eslint --init"'})," 表示自动创建 eslint 规则文件"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，我们通过",(0,r.jsx)(n.code,{children:"npm run xxx"}),"来运行这些 script。"]}),"\n",(0,r.jsx)(n.p,{children:"下一章节，我们将介绍工程化的兼容性和跨平台工具：Babel。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let o=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F24%20%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8%20ESLint%20%E7%BB%9F%E4%B8%80%20JavaScript%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.md"]={toc:[{text:"安装 ESLint",id:"安装-eslint",depth:2},{text:"配置 ESLint 规则",id:"配置-eslint-规则",depth:2},{text:"与编辑器联动",id:"与编辑器联动",depth:2},{text:"--fix 自动修复",id:"--fix-自动修复",depth:2},{text:"自动配置 ESLint",id:"自动配置-eslint",depth:2},{text:"小结",id:"小结",depth:2}],title:"24 工程化：使用 ESLint 统一 JavaScript 代码规范",headingTitle:"24 工程化：使用 ESLint 统一 JavaScript 代码规范",frontmatter:{}}}}]);