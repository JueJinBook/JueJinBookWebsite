"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["69961"],{792305:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var i=s(552676),r=s(740453);let l=s.p+"static/image/6d6eadd62f9011f8e06ae6ce9f8d957f.89bb483f.webp",c=s.p+"static/image/f6e99fc0cc0c7de0db958a56dd0ec200.c7c39960.webp",t=s.p+"static/image/0d14f955211bc0cf69078406b2945050.571e87fb.webp",d=s.p+"static/image/83292da21f33c70f49aa7b17c7ac84a7.d60f5f65.webp",h=s.p+"static/image/92b01556030adaab6d2e825d5d74af51.e8747bb3.webp";function a(e){let n=Object.assign({p:"p",strong:"strong",blockquote:"blockquote",code:"code",a:"a",h2:"h2",h3:"h3",pre:"pre",img:"img",h4:"h4",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["在上一节的内容中，我们详细讲解了如何在 Vite 中实现 CSS 工程化方案，迈出了搭建脚手架项目的第一步。本节，让我们把目光投向项目中另外一个非常重要的部分——",(0,i.jsx)(n.strong,{children:"代码规范"}),"。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"代码不仅是让机器看的，它也是给人看的。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["在真实的工程项目中，尤其是多人协作的场景下，代码规范就变得非常重要了，它可以用来统一团队代码风格，避免不同风格的代码混杂到一起难以阅读，有效提高",(0,i.jsx)(n.strong,{children:"代码质量"}),"，甚至可以将一些",(0,i.jsx)(n.strong,{children:"语法错误"}),"在开发阶段提前规避掉。但仅有规范本身不够，我们需要",(0,i.jsx)(n.strong,{children:"自动化的工具"}),"(即",(0,i.jsx)(n.code,{children:"Lint 工具"}),")来保证规范的落地，把代码规范检查(包括",(0,i.jsx)(n.code,{children:"自动修复"}),")这件事情交给机器完成，开发者只需要专注应用逻辑本身。"]}),"\n",(0,i.jsxs)(n.p,{children:["本节，我们将一起来完成 Lint 工具链在项目中的落地，实现自动化代码规范检查及修复的能力。学完本节内容后，你不仅能熟悉诸如",(0,i.jsx)(n.code,{children:"ESLint"}),"、",(0,i.jsx)(n.code,{children:"Prettier"}),"、",(0,i.jsx)(n.code,{children:"Stylelint"}),"和",(0,i.jsx)(n.code,{children:"Commitlint"})," 等诸多主流 Lint 工具的概念和使用，还能配合",(0,i.jsx)(n.code,{children:"husky"}),"、",(0,i.jsx)(n.code,{children:"lint-staged"}),"、",(0,i.jsx)(n.code,{children:"VSCode 插件"}),"和",(0,i.jsx)(n.code,{children:"Vite 生态"}),"在项目中集成完整的 Lint 工具链，搭建起完整的前端开发和代码提交工作流，这部分内容虽然和 Vite 没有直接的联系，但也是 Vite 项目搭建中非常重要的一环，是前端工程化的必备知识。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["小节示例项目仓库: ",(0,i.jsx)(n.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/4~7-vite-project-framework",target:"_blank",rel:"noopener noreferrer",children:"点击直达"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"jsts-规范工具-eslint",children:["JS/TS 规范工具: ESLint",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jsts-规范工具-eslint",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"简介",children:["简介",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Eslint 是国外的前端大牛",(0,i.jsx)(n.code,{children:"Nicholas C. Zakas"}),'在 2013 年发起的一个开源项目，有一本书被誉为前端界的"圣经"，叫《JavaScript 高级程序设计》(即红宝书)，他正是这本书的作者。']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Nicholas"})," 当初做这个开源项目，就是为了打造一款插件化的 JavaScript 代码静态检查工具，通过解析代码的 AST 来分析代码格式，检查代码的风格和质量问题。现在，Eslint 已经成为一个非常成功的开源项目了，基本上属于前端项目中 Lint 工具的标配。"]}),"\n",(0,i.jsxs)(n.p,{children:["ESLint 的使用并不复杂，主要通过配置文件对各种代码格式的规则(",(0,i.jsx)(n.code,{children:"rules"}),")进行配置，以指定具体的代码规范。目前开源社区也有一些成熟的规范集可供使用，著名的包括",(0,i.jsx)(n.a,{href:"https://github.com/airbnb/javascript",target:"_blank",rel:"noopener noreferrer",children:"Airbnb JavaScript 代码规范"}),"、",(0,i.jsx)(n.a,{href:"https://github.com/standard/standard/blob/master/docs/README-zhcn.md",target:"_blank",rel:"noopener noreferrer",children:"Standard JavaScript 规范"}),"、",(0,i.jsx)(n.a,{href:"https://google.github.io/styleguide/jsguide.html",target:"_blank",rel:"noopener noreferrer",children:"Google JavaScript 规范"}),"等等，你可以在项目中直接使用这些成熟的规范，也可以自己定制一套团队独有的代码规范，这在一些大型团队当中还是很常见的。"]}),"\n",(0,i.jsxs)(n.h3,{id:"初始化",children:["初始化",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来我们来利用 ESLint 官方的 cli 在现有的脚手架项目中进行初始化操作，首先我们需要安装 ESLint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pnpm i eslint -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"接着执行 ESLint 的初始化命令，并进行如下的命令行交互:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"npx eslint --init\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["接着 ESLint 会帮我们自动生成",(0,i.jsx)(n.code,{children:".eslintrc.js"}),"配置文件。需要注意的是，在上述初始化流程中我们并没有用 npm 安装依赖，需要进行手动安装:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pnpm i eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"核心配置解读",children:["核心配置解读",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心配置解读",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["大家初次接触配置文件可能会有点不太理解，接下来我来为你介绍一下几个核心的配置项，你可以对照目前生成的",(0,i.jsx)(n.code,{children:".eslintrc.js"}),"一起学习。"]}),"\n",(0,i.jsxs)(n.h4,{id:"1-parser---解析器",children:["1. parser - 解析器",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-parser---解析器",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["ESLint 底层默认使用 ",(0,i.jsx)(n.a,{href:"https://github.com/eslint/espree",target:"_blank",rel:"noopener noreferrer",children:"Espree"}),"来进行 AST 解析，这个解析器目前已经基于 ",(0,i.jsx)(n.code,{children:"Acron"})," 来实现，虽然说 ",(0,i.jsx)(n.code,{children:"Acron"})," 目前能够解析绝大多数的 ",(0,i.jsx)(n.a,{href:"https://github.com/acornjs/acorn/tree/master/acorn",target:"_blank",rel:"noopener noreferrer",children:"ECMAScript 规范的语法"}),"，但还是不支持 TypeScript ，因此需要引入其他的解析器完成 TS 的解析。"]}),"\n",(0,i.jsxs)(n.p,{children:["社区提供了",(0,i.jsx)(n.code,{children:"@typescript-eslint/parser"}),"这个解决方案，专门为了 TypeScript 的解析而诞生，将 ",(0,i.jsx)(n.code,{children:"TS"})," 代码转换为 ",(0,i.jsx)(n.code,{children:"Espree"})," 能够识别的格式(即 ",(0,i.jsx)(n.a,{href:"https://github.com/estree/estree",target:"_blank",rel:"noopener noreferrer",children:(0,i.jsx)(n.strong,{children:"Estree 格式"})}),")，然后在 Eslint 下通过",(0,i.jsx)(n.code,{children:"Espree"}),"进行格式检查， 以此兼容了 TypeScript 语法。"]}),"\n",(0,i.jsxs)(n.h4,{id:"2-parseroptions----解析器选项",children:["2. parserOptions  - 解析器选项",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-parseroptions----解析器选项",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这个配置可以对上述的解析器进行能力定制，默认情况下 ESLint 支持 ES5 语法，你可以配置这个选项，具体内容如下:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ecmaVersion: 这个配置和 ",(0,i.jsx)(n.code,{children:"Acron"})," 的 ",(0,i.jsx)(n.a,{href:"https://github.com/acornjs/acorn/tree/master/acorn",target:"_blank",rel:"noopener noreferrer",children:"ecmaVersion"})," 是兼容的，可以配置 ",(0,i.jsx)(n.code,{children:"ES + 数字"}),"(如 ES6)或者",(0,i.jsx)(n.code,{children:"ES + 年份"}),"(如 ES2015)，也可以直接配置为",(0,i.jsx)(n.code,{children:"latest"}),"，启用最新的 ES 语法。"]}),"\n",(0,i.jsxs)(n.li,{children:["sourceType: 默认为",(0,i.jsx)(n.code,{children:"script"}),"，如果使用 ES Module 则应设置为",(0,i.jsx)(n.code,{children:"module"})]}),"\n",(0,i.jsxs)(n.li,{children:["ecmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 ",(0,i.jsx)(n.code,{children:"jsx"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"3-rules---具体代码规则",children:["3. rules - 具体代码规则",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-rules---具体代码规则",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rules"})," 配置即代表在 ESLint 中手动调整哪些代码规则，比如",(0,i.jsx)(n.code,{children:"禁止在 if 语句中使用赋值语句"}),"这条规则可以像如下的方式配置:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// .eslintrc.js\nmodule.exports = {\n  // 其它配置省略\n  rules: {\n    // key 为规则名，value 配置内容\n    "no-cond-assign": ["error", "always"]\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["在 rules 对象中，",(0,i.jsx)(n.code,{children:"key"})," 一般为",(0,i.jsx)(n.code,{children:"规则名"}),"，",(0,i.jsx)(n.code,{children:"value"})," 为具体的配置内容，在上述的例子中我们设置为一个数组，数组第一项为规则的 ",(0,i.jsx)(n.code,{children:"ID"}),"，第二项为",(0,i.jsx)(n.code,{children:"规则的配置"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"这里重点说一说规则的 ID，它的语法对所有规则都适用，你可以设置以下的值:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"off"})," 或 ",(0,i.jsx)(n.code,{children:"0"}),": 表示关闭规则。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"warn"})," 或 ",(0,i.jsx)(n.code,{children:"1"}),": 表示开启规则，不过违背规则后只抛出 warning，而不会导致程序退出。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"error"})," 或 ",(0,i.jsx)(n.code,{children:"2"}),": 表示开启规则，不过违背规则后抛出 error，程序会退出。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["具体的规则配置可能会不一样，有的是一个字符串，有的可以配置一个对象，你可以参考 ",(0,i.jsx)(n.a,{href:"https://cn.eslint.org/docs/rules/",target:"_blank",rel:"noopener noreferrer",children:"ESLint 官方文档"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["当然，你也能直接将 ",(0,i.jsx)(n.code,{children:"rules"})," 对象的 ",(0,i.jsx)(n.code,{children:"value"})," 配置成 ID，如: ",(0,i.jsx)(n.code,{children:'"no-cond-assign": "error"'}),"。"]}),"\n",(0,i.jsxs)(n.h4,{id:"4-plugins",children:["4. plugins",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-plugins",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["上面提到过 ESLint 的 parser 基于",(0,i.jsx)(n.code,{children:"Acorn"}),"实现，不能直接解析 TypeScript，需要我们指定 parser 选项为",(0,i.jsx)(n.code,{children:"@typescript-eslint/parser"}),"才能兼容 TS 的解析。同理，ESLint 本身也没有内置 TypeScript 的代码规则，这个时候 ESLint 的插件系统就派上用场了。我们需要通过添加 ESLint 插件来增加一些特定的规则，比如添加",(0,i.jsx)(n.code,{children:"@typescript-eslint/eslint-plugin"})," 来拓展一些关于 TS 代码的规则，如下代码所示:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// .eslintrc.js\nmodule.exports = {\n  // 添加 TS 规则，可省略`eslint-plugin`\n  plugins: ['@typescript-eslint']\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["值得注意的是，添加插件后只是拓展了 ESLint 本身的规则集，但 ESLint 默认并",(0,i.jsx)(n.strong,{children:"没有开启"}),"这些规则的校验！如果要开启或者调整这些规则，你需要在 rules 中进行配置，如:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// .eslintrc.js\nmodule.exports = {\n  // 开启一些 TS 规则\n  rules: {\n    '@typescript-eslint/ban-ts-comment': 'error',\n    '@typescript-eslint/no-explicit-any': 'warn',\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"5-extends---继承配置",children:["5. extends - 继承配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-extends---继承配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["extends 相当于",(0,i.jsx)(n.code,{children:"继承"}),"另外一份 ESLint 配置，可以配置为一个字符串，也可以配置成一个字符串数组。主要分如下 3 种情况:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"从 ESLint 本身继承；"}),"\n",(0,i.jsxs)(n.li,{children:["从类似 ",(0,i.jsx)(n.code,{children:"eslint-config-xxx"})," 的 npm 包继承；"]}),"\n",(0,i.jsx)(n.li,{children:"从 ESLint 插件继承。"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// .eslintrc.js\nmodule.exports = {\n   "extends": [\n     // 第1种情况 \n     "eslint:recommended",\n     // 第2种情况，一般配置的时候可以省略 `eslint-config`\n     "standard"\n     // 第3种情况，可以省略包名中的 `eslint-plugin`\n     // 格式一般为: `plugin:${pluginName}/${configName}`\n     "plugin:react/recommended"\n     "plugin:@typescript-eslint/recommended",\n   ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["有了 extends 的配置，对于之前所说的 ESLint 插件中的繁多配置，我们就",(0,i.jsx)(n.strong,{children:"不需要手动一一开启"}),"了，通过 extends 字段即可自动开启插件中的推荐规则:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'extends: ["plugin:@typescript-eslint/recommended"]\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"6-env-和-globals",children:["6. env 和 globals",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-env-和-globals",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["这两个配置分别表示",(0,i.jsx)(n.code,{children:"运行环境"}),"和",(0,i.jsx)(n.code,{children:"全局变量"}),"，在指定的运行环境中会预设一些全局变量，比如:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// .eslint.js\nmodule.export = {\n  "env": {\n    "browser": "true",\n    "node": "true"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["指定上述的 ",(0,i.jsx)(n.code,{children:"env"})," 配置后便会启用浏览器和 Node.js 环境，这两个环境中的一些全局变量(如 ",(0,i.jsx)(n.code,{children:"window"}),"、",(0,i.jsx)(n.code,{children:"global"})," 等)会同时启用。"]}),"\n",(0,i.jsxs)(n.p,{children:["有些全局变量是业务代码引入的第三方库所声明，这里就需要在",(0,i.jsx)(n.code,{children:"globals"}),"配置中声明全局变量了。每个全局变量的配置值有 3 种情况:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"writable"'}),"或者 ",(0,i.jsx)(n.code,{children:"true"}),"，表示变量可重写；"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"readonly"'}),"或者",(0,i.jsx)(n.code,{children:"false"}),"，表示变量不可重写；"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"off"'}),"，表示禁用该全局变量。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["那",(0,i.jsx)(n.code,{children:"jquery"}),"举例，我们可以在配置文件中声明如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// .eslintrc.js\nmodule.exports = {\n  "globals": {\n    // 不可重写\n    "$": false, \n    "jQuery": false \n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"相信有了上述核心配置部分的讲解，你再回头看看初始化生成的 ESLint 配置文件，你也能很好地理解各个配置项的含义了。"}),"\n",(0,i.jsxs)(n.h3,{id:"与-prettier-强强联合",children:["与 Prettier 强强联合",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与-prettier-强强联合",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["虽然 ESLint 本身具备自动格式化代码的功能(",(0,i.jsx)(n.code,{children:"eslint --fix"}),")，但术业有专攻，ESLint 的主要优势在于",(0,i.jsx)(n.code,{children:"代码的风格检查并给出提示"}),"，而在代码格式化这一块 Prettier 做的更加专业，因此我们经常将 ESLint 结合 Prettier 一起使用。"]}),"\n",(0,i.jsx)(n.p,{children:"首先我们来安装一下 Prettier:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i prettier -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在项目根目录新建",(0,i.jsx)(n.code,{children:".prettierrc.js"}),"配置文件，填写如下的配置内容:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// .prettierrc.js\nmodule.exports = {\n  printWidth: 80, //一行的字符数，如果超过会进行换行，默认为80\n  tabWidth: 2, // 一个 tab 代表几个空格数，默认为 2 个\n  useTabs: false, //是否使用 tab 进行缩进，默认为false，表示用空格进行缩减\n  singleQuote: true, // 字符串是否使用单引号，默认为 false，使用双引号\n  semi: true, // 行尾是否使用分号，默认为true\n  trailingComma: "none", // 是否使用尾逗号\n  bracketSpacing: true // 对象大括号直接是否有空格，默认为 true，效果：{ a: 1 }\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们将",(0,i.jsx)(n.code,{children:"Prettier"}),"集成到现有的",(0,i.jsx)(n.code,{children:"ESLint"}),"工具中，首先安装两个工具包:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"pnpm i eslint-config-prettier eslint-plugin-prettier -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["其中",(0,i.jsx)(n.code,{children:"eslint-config-prettier"}),"用来覆盖 ESLint 本身的规则配置，而",(0,i.jsx)(n.code,{children:"eslint-plugin-prettier"}),"则是用于让 Prettier 来接管",(0,i.jsx)(n.code,{children:"eslint --fix"}),"即修复代码的能力。"]}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:".eslintrc.js"})," 配置文件中接入 prettier 的相关工具链，最终的配置代码如下所示，你可以直接粘贴过去:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",meta:"diff",children:'// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true\n  },\n  extends: [\n    "eslint:recommended",\n    "plugin:react/recommended",\n    "plugin:@typescript-eslint/recommended",\n    // 1. 接入 prettier 的规则\n    "prettier",\n    "plugin:prettier/recommended"\n  ],\n  parser: "@typescript-eslint/parser",\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true\n    },\n    ecmaVersion: "latest",\n    sourceType: "module"\n  },\n  // 2. 加入 prettier 的 eslint 插件\n  plugins: ["react", "@typescript-eslint", "prettier"],\n  rules: {\n    // 3. 注意要加上这一句，开启 prettier 自动修复的功能\n    "prettier/prettier": "error",\n    quotes: ["error", "single"],\n    semi: ["error", "always"],\n    "react/react-in-jsx-scope": "off"\n  }\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["OK，现在我们回到项目中来见证一下",(0,i.jsx)(n.code,{children:"ESLint + Prettier"}),"强强联合的威力，在 ",(0,i.jsx)(n.code,{children:"package.json"})," 中定义一个脚本:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    // 省略已有 script\n    "lint:script": "eslint --ext .js,.jsx,.ts,.tsx --fix --quiet ./src",\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"接下来在命令行终端执行:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"pnpm run lint:script\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样我们就完成了 ",(0,i.jsx)(n.code,{children:"ESLint 的规则检查"}),"以及 ",(0,i.jsx)(n.code,{children:"Prettier 的自动修复"}),"。不过每次执行这个命令未免会有些繁琐，我们可以在",(0,i.jsx)(n.code,{children:"VSCode"}),"中安装",(0,i.jsx)(n.code,{children:"ESLint"}),"和",(0,i.jsx)(n.code,{children:"Prettier"}),"这两个插件，并且在设置区中开启",(0,i.jsx)(n.code,{children:"Format On Save"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来在你按",(0,i.jsx)(n.code,{children:"Ctrl + S"}),"保存代码的时候，Prettier 便会自动帮忙修复代码格式。"]}),"\n",(0,i.jsxs)(n.h3,{id:"在-vite-中接入-eslint",children:["在 Vite 中接入 ESLint",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在-vite-中接入-eslint",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"除了安装编辑器插件，我们也可以通过 Vite 插件的方式在开发阶段进行 ESLint 扫描，以命令行的方式展示出代码中的规范问题，并能够直接定位到原文件。"}),"\n",(0,i.jsx)(n.p,{children:"首先我们安装 Vite 中的 ESLint 插件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i vite-plugin-eslint -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后在 ",(0,i.jsx)(n.code,{children:"vite.config.ts"})," 中接入:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport viteEslint from 'vite-plugin-eslint';\n\n// 具体配置\n{\n  plugins: [\n    // 省略其它插件\n    viteEslint(),\n  ]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在你可以试着重新启动项目， ESLint 的错误已经能够及时显示到命令行窗口中了。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"由于这个插件采用另一个进程来运行 ESLint 的扫描工作，因此不会影响 Vite 项目的启动速度，这个大家不用担心。"}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"样式规范工具-stylelint",children:["样式规范工具: Stylelint",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#样式规范工具-stylelint",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们进入",(0,i.jsx)(n.code,{children:"Stylelint"}),"的部分，先来看看官方的定义:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Stylelint，一个强大的现代化样式 Lint 工具，用来帮助你避免语法错误和统一代码风格。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Stylelint 主要专注于样式代码的规范检查，内置了 ",(0,i.jsx)(n.strong,{children:"170 多个 CSS 书写规则"}),"，支持 ",(0,i.jsx)(n.strong,{children:"CSS 预处理器"}),"(如 Sass、Less)，提供",(0,i.jsx)(n.strong,{children:"插件化机制"}),"以供开发者扩展规则，已经被 Google、Github 等",(0,i.jsx)(n.strong,{children:"大型团队"}),"投入使用。与 ESLint 类似，在规范检查方面，Stylelint 已经做的足够专业，而在代码格式化方面，我们仍然需要结合 Prettier 一起来使用。"]}),"\n",(0,i.jsx)(n.p,{children:"首先让我们来安装 Stylelint 以及相应的工具套件："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i stylelint stylelint-prettier stylelint-config-prettier stylelint-config-recess-order stylelint-config-standard stylelint-config-standard-scss -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后，我们在 Stylelint 的配置文件",(0,i.jsx)(n.code,{children:".stylelintrc.js"}),"中一一使用这些工具套件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// .stylelintrc.js\nmodule.exports = {\n  // 注册 stylelint 的 prettier 插件\n  plugins: ['stylelint-prettier'],\n  // 继承一系列规则集合\n  extends: [\n    // standard 规则集合\n    'stylelint-config-standard',\n    // standard 规则集合的 scss 版本\n    'stylelint-config-standard-scss',\n    // 样式属性顺序规则\n    'stylelint-config-recess-order',\n    // 接入 Prettier 规则\n    'stylelint-config-prettier',\n    'stylelint-prettier/recommended'\n  ],\n  // 配置 rules\n  rules: {\n    // 开启 Prettier 自动格式化功能\n    'prettier/prettier': true\n  }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["可以发现 Stylelint 的配置文件和 ESLint 还是非常相似的，常用的",(0,i.jsx)(n.code,{children:"plugins"}),"、",(0,i.jsx)(n.code,{children:"extends"}),"和",(0,i.jsx)(n.code,{children:"rules"}),"属性在 ESLint 同样存在，并且与 ESLint 中这三个属性的功能也基本相同。不过需要强调的是在 Stylelint 中 rules 的配置会和 ESLint 有些区别，对于每个具体的 rule 会有三种配置方式:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"null"}),"，表示关闭规则。"]}),"\n",(0,i.jsx)(n.li,{children:"一个简单值(如 true，字符串，根据不同规则有所不同)，表示开启规则，但并不做过多的定制。"}),"\n",(0,i.jsxs)(n.li,{children:["一个数组，包含两个元素，即",(0,i.jsx)(n.code,{children:"[简单值，自定义配置]"}),"，第一个元素通常为一个简单值，第二个元素用来进行更精细化的规则配置。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们将 Stylelint 集成到项目中，回到 ",(0,i.jsx)(n.code,{children:"package.json"})," 中，增加如下的 ",(0,i.jsx)(n.code,{children:"scripts"})," 配置:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    // 整合 lint 命令\n    "lint": "npm run lint:script && npm run lint:style",\n    // stylelint 命令\n    "lint:style": "stylelint --fix \\"src/**/*.{css,scss}\\""\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["执行",(0,i.jsx)(n.code,{children:"pnpm run lint:style"}),"即可完成样式代码的规范检查和自动格式化。当然，你也可以在 VSCode 中安装",(0,i.jsx)(n.code,{children:"Stylelint"}),"插件，这样能够在开发阶段即时感知到代码格式问题，提前进行修复。"]}),"\n",(0,i.jsx)(n.p,{children:"当然，我们也可以直接在 Vite 中集成 Stylelint。社区中提供了 Stylelint 的 Vite 插件，实现在项目开发阶段提前暴露出样式代码的规范问题。我们来安装一下这个插件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 5.代码规范_ 如何利用 Lint 工具链来保证代码风格和质量？\npnpm i @amatlash/vite-plugin-stylelint -D\n\n# Vite 3.x 及以后的版本\npnpm i vite-plugin-stylelint -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后在 Vite 配置文件中添加如下的内容:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import viteStylelint from '@amatlash/vite-plugin-stylelint';\n// 注意: Vite 3.x 以及以后的版本需要引入 vite-plugin-stylelint\n\n// 具体配置\n{\n  plugins: [\n    // 省略其它插件\n    viteStylelint({\n      // 对某些文件排除检查\n      exclude: /windicss|node_modules/\n    }),\n  ]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"接下来，你就可以在命令行界面看到对应的 Stylelint 提示了:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"husky--lint-staged-的-git-提交工作流集成",children:["Husky + lint-staged 的 Git 提交工作流集成",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#husky--lint-staged-的-git-提交工作流集成",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"提交前的代码-lint-检查",children:["提交前的代码 Lint 检查",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#提交前的代码-lint-检查",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在上文中我们提到了安装 ",(0,i.jsx)(n.code,{children:"ESLint"}),"、",(0,i.jsx)(n.code,{children:"Prettier"}),"和",(0,i.jsx)(n.code,{children:"Stylelint"}),"的 VSCode 插件或者 Vite 插件，在开发阶段提前规避掉代码格式的问题，但实际上这也只是将问题提前暴露，并不能保证规范问题能完全被解决，还是可能导致线上的代码出现不符合规范的情况。那么如何来避免这类问题呢？"]}),"\n",(0,i.jsxs)(n.p,{children:["我们可以在代码提交的时候进行卡点检查，也就是拦截 ",(0,i.jsx)(n.code,{children:"git commit"})," 命令，进行代码格式检查，只有确保通过格式检查才允许正常提交代码。社区中已经有了对应的工具——",(0,i.jsx)(n.code,{children:"Husky"}),"来完成这件事情，让我们来安装一下这个工具:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i husky -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["值得提醒的是，有很多人推荐在",(0,i.jsx)(n.code,{children:"package.json"}),"中配置 husky 的钩子:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n  "husky": {\n    "pre-commit": "npm run lint"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["这种做法在 Husky ",(0,i.jsx)(n.code,{children:"4.x"})," 及以下版本没问题，而在最新版本(7.x 版本)中是无效的！在新版 Husky 版本中，我们需要做如下的事情:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["初始化 Husky: ",(0,i.jsx)(n.code,{children:"npx husky install"}),"，并将 ",(0,i.jsx)(n.code,{children:"husky install"}),"作为项目启动前脚本，如:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    // 会在安装 npm 依赖后自动执行\n    "prepare": "husky install"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"添加 Husky 钩子，在终端执行如下命令:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'npx husky add .husky/pre-commit "npm run lint"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["接着你将会在项目根目录的",(0,i.jsx)(n.code,{children:".husky"}),"目录中看到名为",(0,i.jsx)(n.code,{children:"pre-commit"}),"的文件，里面包含了 ",(0,i.jsx)(n.code,{children:"git commit"}),"前要执行的脚本。现在，当你执行 ",(0,i.jsx)(n.code,{children:"git commit"})," 的时候，会首先执行 ",(0,i.jsx)(n.code,{children:"npm run lint"}),"脚本，通过 Lint 检查后才会正式提交代码记录。"]}),"\n",(0,i.jsxs)(n.p,{children:["不过，刚才我们直接在 Husky 的钩子中执行 ",(0,i.jsx)(n.code,{children:"npm run lint"}),"，这会产生一个额外的问题: Husky 中每次执行",(0,i.jsx)(n.code,{children:"npm run lint"}),"都对仓库中的代码进行全量检查，也就是说，即使某些文件并没有改动，也会走一次 Lint 检查，当项目代码越来越多的时候，提交的过程会越来越慢，影响开发体验。"]}),"\n",(0,i.jsxs)(n.p,{children:["而",(0,i.jsx)(n.code,{children:"lint-staged"}),"就是用来解决上述全量扫描问题的，可以实现只对存入",(0,i.jsx)(n.code,{children:"暂存区"}),"的文件进行 Lint 检查，大大提高了提交代码的效率。首先，让我们安装一下对应的 npm 包:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i -D lint-staged\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后在 ",(0,i.jsx)(n.code,{children:"package.json"}),"中添加如下的配置:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "lint-staged": {\n    "**/*.{js,jsx,tsx,ts}": [\n      "npm run lint:script",\n      "git add ."\n    ],\n    "**/*.{scss}": [\n      "npm run lint:style",\n      "git add ."\n    ]\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们需要在 Husky 中应用",(0,i.jsx)(n.code,{children:"lint-stage"}),"，回到",(0,i.jsx)(n.code,{children:".husky/pre-commit"}),"脚本中，将原来的",(0,i.jsx)(n.code,{children:"npm run lint"}),"换成如下脚本:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"npx --no -- lint-staged\n"})}),"\n",(0,i.jsxs)(n.p,{children:["如此一来，我们便实现了提交代码时的",(0,i.jsx)(n.code,{children:"增量 Lint 检查"}),"。"]}),"\n",(0,i.jsxs)(n.h3,{id:"提交时的-commit-信息规范",children:["提交时的 commit 信息规范",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#提交时的-commit-信息规范",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"除了代码规范检查之后，Git 提交信息的规范也是不容忽视的一个环节，规范的 commit 信息能够方便团队协作和问题定位。首先我们来安装一下需要的工具库，执行如下的命令:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pnpm i commitlint @commitlint/cli @commitlint/config-conventional -D\n"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来新建",(0,i.jsx)(n.code,{children:".commitlintrc.js"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// .commitlintrc.js\nmodule.exports = {\n  extends: ["@commitlint/config-conventional"]\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["一般我们直接使用",(0,i.jsx)(n.code,{children:"@commitlint/config-conventional"}),"规范集就可以了，它所规定的 commit 信息一般由两个部分: ",(0,i.jsx)(n.code,{children:"type"})," 和 ",(0,i.jsx)(n.code,{children:"subject"})," 组成，结构如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// type 指提交的类型\n// subject 指提交的摘要信息\n<type>: <subject>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["常用的 ",(0,i.jsx)(n.code,{children:"type"})," 值包括如下:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"feat"}),": 添加新功能。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fix"}),": 修复 Bug。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chore"}),": 一些不影响功能的更改。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"docs"}),": 专指文档的修改。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"perf"}),": 性能方面的优化。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"refactor"}),": 代码重构。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"test"}),": 添加一些测试代码等等。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们将",(0,i.jsx)(n.code,{children:"commitlint"}),"的功能集成到 Husky 的钩子当中，在终端执行如下命令即可:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'npx husky add .husky/commit-msg "npx --no-install commitlint -e $HUSKY_GIT_PARAMS"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["你可以发现在",(0,i.jsx)(n.code,{children:".husky"}),"目录下多出了",(0,i.jsx)(n.code,{children:"commit-msg"}),"脚本文件，表示",(0,i.jsx)(n.code,{children:"commitlint"}),"命令已经成功接入到 husky 的钩子当中。现在我们可以尝试对代码进行提交，假如输入一个错误的 commit 信息，commitlint 会自动抛出错误并退出:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"至此，我们便完成了 Git 提交信息的卡点扫描和规范检查。"}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["恭喜你，学完了本节的内容。本小节你应该了解前端的",(0,i.jsx)(n.strong,{children:"自动化代码规范工具的使用"}),"以及",(0,i.jsx)(n.strong,{children:"在 Vite 中的接入方法"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"我主要给你介绍了 3 个方面的自动化代码规范工具:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["JavaScript/TypeScript 规范。主流的 Lint 工具包括 ",(0,i.jsx)(n.code,{children:"Eslint"}),"、",(0,i.jsx)(n.code,{children:"Prettier"}),"；"]}),"\n",(0,i.jsxs)(n.li,{children:["样式开发规范。主流的 Lint 工具包括",(0,i.jsx)(n.code,{children:"Stylelint"}),"、",(0,i.jsx)(n.code,{children:"Prettier"}),"；"]}),"\n",(0,i.jsxs)(n.li,{children:["Git 提交规范。主流的 Lint 工具包括",(0,i.jsx)(n.code,{children:"Commitlint"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["我们可以通过编辑器的插件或者 Vite 插件在开发阶段暴露出规范问题，但也无法保证这类问题在开发时完全被解决掉，因此我们尝试在代码提交阶段来解决这个问题，通过",(0,i.jsx)(n.code,{children:"Husky"}),"+",(0,i.jsx)(n.code,{children:"lint-staged"}),"成功地拦截 ",(0,i.jsx)(n.code,{children:"git commit"}),"过程，只有在各项 Lint 检查通过后才能正常提交代码，这样就有效提高了线上代码和 Git 提交信息的质量。"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}let x=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F5.%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_%20%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Lint%20%E5%B7%A5%E5%85%B7%E9%93%BE%E6%9D%A5%E4%BF%9D%E8%AF%81%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E8%B4%A8%E9%87%8F%EF%BC%9F.md"]={toc:[{text:"JS/TS 规范工具: ESLint",id:"jsts-规范工具-eslint",depth:2},{text:"简介",id:"简介",depth:3},{text:"初始化",id:"初始化",depth:3},{text:"核心配置解读",id:"核心配置解读",depth:3},{text:"1. parser - 解析器",id:"1-parser---解析器",depth:4},{text:"2. parserOptions  - 解析器选项",id:"2-parseroptions----解析器选项",depth:4},{text:"3. rules - 具体代码规则",id:"3-rules---具体代码规则",depth:4},{text:"4. plugins",id:"4-plugins",depth:4},{text:"5. extends - 继承配置",id:"5-extends---继承配置",depth:4},{text:"6. env 和 globals",id:"6-env-和-globals",depth:4},{text:"与 Prettier 强强联合",id:"与-prettier-强强联合",depth:3},{text:"在 Vite 中接入 ESLint",id:"在-vite-中接入-eslint",depth:3},{text:"样式规范工具: Stylelint",id:"样式规范工具-stylelint",depth:2},{text:"Husky + lint-staged 的 Git 提交工作流集成",id:"husky--lint-staged-的-git-提交工作流集成",depth:2},{text:"提交前的代码 Lint 检查",id:"提交前的代码-lint-检查",depth:3},{text:"提交时的 commit 信息规范",id:"提交时的-commit-信息规范",depth:3},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);