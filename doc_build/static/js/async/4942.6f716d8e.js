"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["4942"],{620737:function(n,e,i){i.r(e),i.d(e,{default:()=>o});var r=i(552676),s=i(740453);function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",strong:"strong"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"28手写-babel-traverse-篇",children:["28.手写 Babel： traverse 篇",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#28手写-babel-traverse-篇",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"traverse 是遍历 AST，并且遍历的过程中支持 visitor 的调用，在 visitor 里实现对 AST 的增删改。"}),"\n",(0,r.jsx)(e.p,{children:"我们这一节的目的是实现这样的 api："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"traverse(ast, {\n    Identifier(node) {\n        node.name = 'b';\n    }\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:"path 放到下一节实现。"}),"\n",(0,r.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"AST 的遍历就是树的遍历，树的遍历就深度优先、广度优先两种方式，而这里明显是深度优先遍历。"}),"\n",(0,r.jsx)(e.p,{children:"深度优先遍历要递归的遍历节点的子节点，那么我们怎么知道对象的属性是可以遍历的子节点呢？"}),"\n",(0,r.jsx)(e.p,{children:"可以维护一份数据来保存不同 AST 的什么属性是可以遍历的，然后在遍历不同节点的时候从中查找应该继续遍历什么属性。这样就实现了深度优先遍历。"}),"\n",(0,r.jsx)(e.p,{children:"在遍历的过程中可以根据类型调用不同的 visitor，然后传入当前节点。"}),"\n",(0,r.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先，我们维护这样一份数据：不同的 AST 有哪些可以遍历的属性。"}),"\n",(0,r.jsx)(e.p,{children:"比如 Program 要遍历 body 属性，VariableDeclarator 要遍历 id、init 属性等："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const astDefinationsMap = new Map();\n\nastDefinationsMap.set('Program', {\n    visitor: ['body']\n});\nastDefinationsMap.set('VariableDeclaration', {\n    visitor: ['declarations']\n});\nastDefinationsMap.set('VariableDeclarator', {\n    visitor: ['id', 'init']\n});\nastDefinationsMap.set('Identifier', {});\nastDefinationsMap.set('NumericLiteral', {});\nastDefinationsMap.set('FunctionDeclaration', {\n    visitor: ['id', 'params', 'body']\n});\nastDefinationsMap.set('BlockStatement', {\n    visitor: ['body']\n});\nastDefinationsMap.set('ReturnStatement', {\n    visitor: ['argument']\n});\nastDefinationsMap.set('BinaryExpression', {\n    visitor: ['left', 'right']\n});\nastDefinationsMap.set('ExpressionStatement', {\n    visitor: ['expression']\n});\nastDefinationsMap.set('CallExpression', {\n    visitor: ['callee', 'arguments']\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后实现递归的遍历，遍历到不同节点时，取出不同节点要遍历的属性，然后递归遍历。如果是数组的话，每个元素都是这样处理："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function traverse(node, visitors) {\n    const defination = astDefinationsMap.get(node.type);\n    \n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach(childNode => {\n                    traverse(childNode, visitors);\n                })\n            } else {\n                traverse(prop, visitors);\n            }\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"实现了遍历，当然还要在遍历时支持不同节点的 visitor 回调函数："}),"\n",(0,r.jsx)(e.p,{children:"visitor 支持 enter 和 exit 阶段，也就是进入节点调用 enter 回调函数，之后遍历子节点，之后再调用 exit 回调函数。"}),"\n",(0,r.jsx)(e.p,{children:"那么分别在遍历前后调用就可以，默认如果没有指定哪个阶段就在 enter 阶段调用。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function traverse(node, visitors) {\n    const defination = astDefinationsMap.get(node.type);\n\n    let visitorFuncs = visitors[node.type] || {};\n\n    if(typeof visitorFuncs === 'function') {\n        visitorFuncs = {\n            enter: visitorFuncs\n        }\n    }\n\n    visitorFuncs.enter && visitorFuncs.enter(node);\n\n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach(childNode => {\n                    traverse(childNode, visitors);\n                })\n            } else {\n                traverse(prop, visitors);\n            }\n        })\n    }\n    visitorFuncs.exit && visitorFuncs.exit(node);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样，我们就实现了 AST 的遍历和 enter、exit 阶段的 visitor 调用。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"为什么要分 enter 和 exit 两个阶段呢？"})}),"\n",(0,r.jsx)(e.p,{children:"因为 enter 阶段在遍历子节点之前，那么修改之后就可以立刻遍历子节点，而 exit 是在遍历结束之后了，所以不会继续遍历子节点。如果 enter 阶段修改了 AST 但是不想遍历新生成的子节点，可以用 path.skip 跳过遍历。"}),"\n",(0,r.jsx)(e.p,{children:"可以这样来遍历和修改 AST："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"traverse(ast, {\n    Identifier(node) {\n        node.name = 'b';\n    }\n});\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"traverse 就是 AST 的遍历，而树的遍历就深度优先和广度优先两种，这里是深度优先，我们维护了一份什么 AST 遍历什么属性的数据，然后遍历的时候就可以知道如何遍历每一个节点。"}),"\n",(0,r.jsx)(e.p,{children:"遍历的时候调用 visitor 的回调函数，分为 enter 和 exit 阶段来调用，默认是 enter 阶段。"}),"\n",(0,r.jsxs)(e.p,{children:["（代码在",(0,r.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(t,{...n})}):t(n)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F28.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20traverse%20%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"28.手写 Babel： traverse 篇",headingTitle:"28.手写 Babel： traverse 篇",frontmatter:{}}}}]);