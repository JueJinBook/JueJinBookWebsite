"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1706"],{154485:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var c=r(552676),d=r(740453);function s(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",h3:"h3",ol:"ol",li:"li",blockquote:"blockquote"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["数据持久化存储是每个桌面端应用基本上都会面对的问题，作为前端开发者，我们通常会使用 ",(0,c.jsx)(n.code,{children:"localstorage"})," 或者 ",(0,c.jsx)(n.code,{children:"indexedDB"})," 作为我们的存储方式。"]}),"\n",(0,c.jsxs)(n.p,{children:["但是在桌面端应用开发中，我们通常会使用 ",(0,c.jsx)(n.a,{href:"https://www.sqlite.org/index.html",target:"_blank",rel:"noopener noreferrer",children:"SQLite"})," 或者 ",(0,c.jsx)(n.a,{href:"https://pouchdb.com/",target:"_blank",rel:"noopener noreferrer",children:"PouchDB"})," 作为我们的存储方式，它们分别是关系型数据库管理系统（RDBMS）和 NoSQL 数据库中的代表工具。至于对于 ",(0,c.jsx)(n.code,{children:"Rubick"})," 而言，选择什么类型的数据库我们来简单分析一下。"]}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{children:"特性"}),"\n",(0,c.jsx)(n.th,{children:"SQLite"}),"\n",(0,c.jsx)(n.th,{children:"PouchDB"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"类型"}),"\n",(0,c.jsx)(n.td,{children:"关系型数据库管理系统（RDBMS），以单个文件形式存储数据库，可以通过 SQL 进行数据操作。"}),"\n",(0,c.jsx)(n.td,{children:"NoSQL 数据库，特别适用于在浏览器和 Node.js 环境中工作，并支持实时数据同步。"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"适用场景"}),"\n",(0,c.jsx)(n.td,{children:"用于需要在单个设备上进行数据存储和处理的应用程序，例如移动应用程序或桌面应用程序。通常用于需要严格的数据结构和复杂查询的场景。"}),"\n",(0,c.jsx)(n.td,{children:"更适合需要在不同设备之间同步数据的应用程序，尤其是需要离线数据操作和实时同步的情况。它可在离线状态下操作数据，并在重新联网时与远程服务器同步。"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"架构"}),"\n",(0,c.jsx)(n.td,{children:"传统的关系型数据库，使用SQL进行数据操作，支持复杂的查询语言和事务管理。"}),"\n",(0,c.jsx)(n.td,{children:"基于文档的数据库，使用JavaScript API来操作数据，而不是SQL。支持JSON文档，并且与CouchDB等兼容，能够在离线状态下工作。"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"数据同步"}),"\n",(0,c.jsx)(n.td,{children:"通常需要手动实现数据同步和复制来实现设备之间的数据一致性。"}),"\n",(0,c.jsx)(n.td,{children:"专注于实时数据同步，并内置了处理多设备间数据同步的功能。"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"跨平台支持"}),"\n",(0,c.jsx)(n.td,{children:"支持各种平台，但需要特定的驱动程序来与不同编程语言和环境交互。"}),"\n",(0,c.jsx)(n.td,{children:"能够无缝地在浏览器和Node.js环境中运行，并且可以直接在这些环境中使用JavaScript API。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["再来谈谈 Rubick 数据库使用的场景：首先我们的用于数据持久化存储的场景大多是插件产生的数据，我们并不需要插件开发者特别关系数据表的数据结构。其次插件可能需要存储各种类型的离线文件，比如 ",(0,c.jsx)(n.code,{children:"OCR"})," 插件需要存储图片文件。最后我们的用户可能有多台设备，需要进行跨设备间的数据同步。"]}),"\n",(0,c.jsxs)(n.p,{children:["基于此前提下，我们选择的是 ",(0,c.jsx)(n.code,{children:"PouchDB"})," 作为 Rubick 的本地存储数据库。"]}),"\n",(0,c.jsxs)(n.h2,{id:"引入-pouchdb",children:["引入 PouchDB",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引入-pouchdb",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 Electron 中引入 ",(0,c.jsx)(n.code,{children:"PouchDB"})," 也是非常方便，首先需要安装 ",(0,c.jsx)(n.code,{children:"PouchDB"})," 的依赖包："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"npm install pouchdb --save\n# 第17章—实战篇：本地数据库和多端数据同步\nyarn add pouchdb\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后在项目中引入它："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import PouchDB from 'pouchdb';\n"})}),"\n",(0,c.jsx)(n.p,{children:"如果不出意外在运行的时候就要报错了："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"App threw an error during load\nError: No native build was found for platform=xxx ...\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这个是因为 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 本身依赖了 ",(0,c.jsx)(n.a,{href:"https://github.com/Level/leveldown",target:"_blank",rel:"noopener noreferrer",children:"leveldown"})," 模块，该模块是一个基于 ",(0,c.jsx)(n.code,{children:"node-gyp"})," 构建的 ",(0,c.jsx)(n.code,{children:".node"})," 二进制模块。在 Electron 中，对于这类二进制模块的应用需要进行单独打包，因为我们使用的是 ",(0,c.jsx)(n.code,{children:"electron-builder"})," 构建，那么就可以直接添加如下配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"externals: [\n  'pouchdb',\n]\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"pouchdb-初始化",children:["PouchDB 初始化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pouchdb-初始化",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["初始化一个 ",(0,c.jsx)(n.code,{children:"PouchDB"})," 也非常简单："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"new PouchDB([name], [options])\n"})}),"\n",(0,c.jsxs)(n.p,{children:["其中，",(0,c.jsx)(n.code,{children:"name"})," 是数据库名称，是一个必填值。",(0,c.jsx)(n.code,{children:"Options"})," 包含数据库创建的一些参数设置，比如在 Rubick 中我们实例化一个 ",(0,c.jsx)(n.code,{children:"db"})," 实例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export default class DB {\n  public dbpath;\n  public defaultDbName;\n  public pouchDB;\n\n  constructor(dbPath) {\n    this.dbpath = dbPath;\n    this.defaultDbName = path.join(dbPath, 'default');\n  }\n\n  init() {\n    this.pouchDB = new PouchDB(this.defaultDbName, { auto_compaction: true });\n  }\n  \n  // ...\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"auto_compaction"})," 是 PouchDB 中一个配置属性，用于指定数据库是否开启自动压缩。"]}),"\n",(0,c.jsxs)(n.h2,{id:"数据库的增删改查",children:["数据库的增删改查",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据库的增删改查",children:"#"})]}),"\n",(0,c.jsxs)(n.h3,{id:"1-增加数据",children:["1. 增加数据",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-增加数据",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们要实现向数据库中增加数据的 API，其 API 调用方式大致为："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'// 创建数据\ndb.put({\n  // 键\n  _id: "demo",\n  // 值\n  data: "demo"\n})\n// 返回 {id: "demo", ok: true, rev: "1-05c9b92e6f24287dc1f4ec79d9a34fa8"}\n'})}),"\n",(0,c.jsx)(n.p,{children:"那么实现方式如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export default class DB {\n  // ...\n  async put(doc) {\n    try {\n      // 调用 pouchDB.put 函数\n      const result = await this.pouchDB.put(doc);\n      doc._id = result.id;\n      return result;\n    } catch (e: any) {\n      return { id: doc._id, name: e.name, error: true, message: e.message };\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"2-修改数据",children:["2. 修改数据",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-修改数据",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["修改数据需要向 ",(0,c.jsx)(n.code,{children:"pouchDB"})," 中提供额外的索引参数 ",(0,c.jsx)(n.code,{children:"_rev"}),"，这是代表此文档的版本，每次对文档进行更新时，都要带上最新的版本号，否则更新将失败，版本化的意义在于解决同步时数据冲突。更新 API 使用方式如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'db.put({\n  _id: "demo",\n  data: "demo",\n  _rev: "1-05c9b92e6f24287dc1f4ec79d9a34fa8"\n})\n'})}),"\n",(0,c.jsxs)(n.p,{children:["对应的实现函数依然是之前的 ",(0,c.jsx)(n.code,{children:"db.put"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"3-获取数据",children:["3. 获取数据",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-获取数据",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["获取数据需要向 ",(0,c.jsx)(n.code,{children:"pouchDB"})," 传入一个 ",(0,c.jsx)(n.code,{children:"id"})," 作为键值，使用示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'db.get("demo")\n// 返回 {_id: "demo", _rev: "3-9836c5c68af5aef618e17d615882942a", data: "demo"}\n'})}),"\n",(0,c.jsx)(n.p,{children:"实现方式："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export default class DB {\n  // ...\n  async get(id) {\n    try {\n      return await this.pouchDB.get(id);\n    } catch (e) {\n      return null;\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"4-删除数据",children:["4. 删除数据",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-删除数据",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["删除数据需要向 ",(0,c.jsx)(n.code,{children:"pouchDB"})," 传入一个文档对象或文档 id 进行操作，使用示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'db.remove("demo")\n// 返回 {id: "demo", ok: true, rev: "2-effe5dbc23dffc180d8411b23f3108fb"}\n'})}),"\n",(0,c.jsx)(n.p,{children:"实现方式："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export default class DB {\n  // ...\n  async remove(doc) {\n    try {\n      let target;\n      // 如果是对象\n      if (typeof doc === 'object') {\n        target = doc;\n        // 判断是否存在 _id\n        if (!target._id || typeof target._id !== 'string') {\n          return this.errorInfo('exception', 'doc _id error');\n        }\n      } else {\n        // 如果也不是 string 则报错\n        if (typeof doc !== 'string') {\n          return this.errorInfo('exception', 'param error');\n        }\n        // 先获取对象内容\n        target = await this.pouchDB.get(this.getDocId(doc));\n      }\n      // 删除对象\n      return await this.pouchDB.remove(target);\n    } catch (e) {\n      return this.errorInfo(e.name, e.message);\n    }\n  }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["除了增删改查单条数据外，",(0,c.jsx)(n.code,{children:"PouchDB"})," 还有批量增加和删除数据的功能：",(0,c.jsx)(n.code,{children:"db.bulkDocs"}),"、",(0,c.jsx)(n.code,{children:"db.allDocs"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["具体实现细节和整个完整案例可以见 Rubick 源码关于数据实现部分：",(0,c.jsx)(n.a,{href:"https://github.com/rubickCenter/rubick/blob/master/src/core/db/index.ts",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/rubickCenter/rubick/blob/master/src/core/db/index.ts"})]}),"\n",(0,c.jsxs)(n.h2,{id:"多端数据同步",children:["多端数据同步",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#多端数据同步",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Rubick 数据存储是基于 ",(0,c.jsx)(n.a,{href:"https://pouchdb.com/",target:"_blank",rel:"noopener noreferrer",children:"pouchdb"})," 的，所以数据同步的方案可以有："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["直接把 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 里面的数据以文件的形式导出，其他设备再以文件的形式导入。"]}),"\n",(0,c.jsxs)(n.li,{children:["基于 ",(0,c.jsx)(n.code,{children:"webdav"}),"，把数据先导入到支持 ",(0,c.jsx)(n.code,{children:"webdav"})," 的云盘，其他设备再从云盘导入 rubick。"]}),"\n",(0,c.jsxs)(n.li,{children:["自建中央数据存储服务器，然后将 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 数据同步到云服务器。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"方案一是可行的，但是不咋方便，因为虽然导出了文件，但是文件还是需要手动同步到另一台设备。方案三也是可行的，但是开源项目搞一台存储服务一方面是没钱，另一方面是把用户数据同步到自己的服务器对用户来说太不安全了。所以 rubick 多端同步选择的是方案二。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"WebDAV （Web-based Distributed Authoring and Versioning），一种基于\xa0HTTP\xa01.1 协议的通信协议。它扩展了 HTTP 1.1，在 GET、POST、HEAD 等几个 HTTP 标准方法以外添加了一些新的方法，使应用程序可对 Web Server 直接读写，并支持写文件锁定及解锁，还可以支持文件的版本控制。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["目前，国内支持 ",(0,c.jsx)(n.code,{children:"webdav"})," 服务的厂商不是很多，比较有名的就是",(0,c.jsx)(n.a,{href:"https://www.jianguoyun.com/",target:"_blank",rel:"noopener noreferrer",children:"坚果云"}),"。你可以打开坚果云官网快速注册一个坚果云账号，跟着 ",(0,c.jsx)(n.a,{href:"https://help.jianguoyun.com/?p=2064",target:"_blank",rel:"noopener noreferrer",children:"# 坚果云第三方应用授权WebDAV开启方法"})," 这个文档一步步开启 webdav 授权，当然你也可以自建 ",(0,c.jsx)(n.code,{children:"webdav"})," 服务器。"]}),"\n",(0,c.jsxs)(n.h3,{id:"1-数据导出",children:["1. 数据导出",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-数据导出",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["以把数据导入到坚果云为例，首先需要把 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 里面的数据导出到坚果云。这里就需要用到一个 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 的插件：",(0,c.jsx)(n.a,{href:"https://github.com/pouchdb-community/pouchdb-replication-stream",target:"_blank",rel:"noopener noreferrer",children:"pouchdb-replication-stream"}),"，以及一个支持 ",(0,c.jsx)(n.code,{children:"webdav"})," 的 npm 包 ",(0,c.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack",target:"_blank",rel:"noopener noreferrer",children:"webdav"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["首先，安装引入 ",(0,c.jsx)(n.code,{children:"pouchdb-replication-stream"})," 插件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const replicationStream = require('pouchdb-replication-stream/dist/pouchdb.replication-stream.min.js');\n\nPouchDB.plugin(replicationStream.plugin);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后，初始化 ",(0,c.jsx)(n.code,{children:"webdav"})," 客户端："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import { createClient } from 'webdav';\n\nexport default class WebDav {\n  // 定义 client 实例\n  public client;\n  // 定义云盘存储的目录\n  private cloudPath = '/rubick/db.txt';\n\n  constructor({ username, password, url }) {\n    // 创建客户端连接\n    this.client = createClient(url, {\n      username,\n      password,\n    });\n    // 检测连接状态\n    this.client\n      .exists('/')\n      .then((result) => {\n        !result &&\n          new Notification({\n            title: '导出失败',\n            body: 'webdav 连接失败',\n          }).show();\n      })\n      .catch((r) => {\n        new Notification({\n          title: '导出失败',\n          body: 'WebDav连接出错' + r,\n        }).show();\n      });\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["创建好 ",(0,c.jsx)(n.code,{children:"webdav"})," 客户端后，就可以尝试通过 ",(0,c.jsx)(n.code,{children:"pouchdb-replication-stream"})," 将 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 中的数据导出到云端指定目录："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import MemoryStream from 'memorystream';\n\nasync createWriteStream(dbInstance) {\n  try {\n    // 判断是否存在 /rubick 目录，不存在就新建\n    const result = await this.client.exists('/rubick');\n    if (!result) {\n      await this.client.createDirectory('/rubick');\n    }\n  } catch (e) {\n    new Notification({\n      title: '导出失败',\n      body: 'WebDav目录创建出错:' + e,\n    }).show();\n  }\n  // 创建一个内存流\n  const ws = new MemoryStream();\n  // 调用 pouchdb-replication-stream 插件提供的 dump 番薯导出\n  dbInstance.dump(ws);\n  // 写入坚果云\n  ws.pipe(\n    this.client.createWriteStream(this.cloudPath, {}, () => {\n      new Notification({\n        title: '已导出到坚果云',\n        body: `文件目录为：${this.cloudPath}`,\n      }).show();\n    })\n  );\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"2-数据导入",children:["2. 数据导入",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-数据导入",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["导出完成了，接下来就是从坚果云中下载数据了，这里也用到了一个加载数据的插件：",(0,c.jsx)(n.a,{href:"https://github.com/pouchdb-community/pouchdb-load",target:"_blank",rel:"noopener noreferrer",children:"pouchdb-load"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"async createReadStream(dbInstance) {\n  try {\n    // 先检测是否存在 webdav 数据\n    const result = await this.client.exists(this.cloudPath);\n    if (!result) {\n      return new Notification({\n        title: '导入失败',\n        body: '请确认坚果云上已存在数据',\n      }).show();\n    }\n    // 下载数据\n    const str = await this.client.getFileContents(this.cloudPath, {\n      format: 'text',\n    });\n    // 使用 pouchdb-load 提供的 loadIt 函数来导入数据\n    await dbInstance.loadIt(str);\n    new Notification({\n      title: '导入成功',\n      body: '数据已导入到 rubick，主应用数据需重启后生效',\n    }).show();\n  } catch (e) {\n    new Notification({\n      title: '导入失败',\n      body: 'WebDav目录导入出错:' + e,\n    }).show();\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["多端数据同步完整代码：",(0,c.jsx)(n.a,{href:"https://github.com/rubickCenter/rubick/blob/master/src/core/db/index.ts",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/rubickCenter/rubick/blob/master/src/core/db/index.ts"})]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本小节我们详细介绍了桌面端使用 ",(0,c.jsx)(n.code,{children:"pouchdb"})," 进行数据存储的过程和方法，并基于 ",(0,c.jsx)(n.code,{children:"webdav"})," 实现了一个多端数据同步的功能。其实多端数据同步在很多桌面端软件中都有应用，如果你希望你的软件也支持多端数据同步，不妨也来试试吧！"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(s,{...e})}):s(e)}let i=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC17%E7%AB%A0%E2%80%94%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%A4%9A%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"引入 PouchDB",id:"引入-pouchdb",depth:2},{text:"PouchDB 初始化",id:"pouchdb-初始化",depth:2},{text:"数据库的增删改查",id:"数据库的增删改查",depth:2},{text:"1. 增加数据",id:"1-增加数据",depth:3},{text:"2. 修改数据",id:"2-修改数据",depth:3},{text:"3. 获取数据",id:"3-获取数据",depth:3},{text:"4. 删除数据",id:"4-删除数据",depth:3},{text:"多端数据同步",id:"多端数据同步",depth:2},{text:"1. 数据导出",id:"1-数据导出",depth:3},{text:"2. 数据导入",id:"2-数据导入",depth:3},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);