"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["15043"],{673830:function(e,n,c){e.exports=c.p+"static/image/d988498b2d7b1726243a3b1c25ea611a.46ea6461.webp"},75488:function(e,n,c){c.r(n),c.d(n,{default:()=>h});var r=c(552676),s=c(740453),d=c(673830);let t=c.p+"static/image/f28f96086ae6fbd6b83cfacf32f6a296.457a9627.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",pre:"pre",code:"code",img:"img",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"3响应式系统的依赖收集追踪原理",children:["3.响应式系统的依赖收集追踪原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3响应式系统的依赖收集追踪原理",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"为什么要依赖收集",children:["为什么要依赖收集？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么要依赖收集",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"先举个栗子\uD83C\uDF30"})}),"\n",(0,r.jsx)(n.p,{children:"我们现在有这么一个 Vue 对象。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"new Vue({\n    template: \n        `<div>\n            <span>{{text1}}</span> \n            <span>{{text2}}</span> \n        <div>`,\n    data: {\n        text1: 'text1',\n        text2: 'text2',\n        text3: 'text3'\n    }\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后我们做了这么一个操作。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"this.text3 = 'modify text3';\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们修改了 ",(0,r.jsx)(n.code,{children:"data"})," 中 ",(0,r.jsx)(n.code,{children:"text3"})," 的数据，但是因为视图中并不需要用到 ",(0,r.jsx)(n.code,{children:"text3"})," ，所以我们并不需要触发上一章所讲的 ",(0,r.jsx)(n.code,{children:"cb"})," 函数来更新视图，调用 ",(0,r.jsx)(n.code,{children:"cb"})," 显然是不正确的。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"再来一个栗子\uD83C\uDF30"})}),"\n",(0,r.jsx)(n.p,{children:"假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let globalObj = {\n    text1: 'text1'\n};\n\nlet o1 = new Vue({\n    template:\n        `<div>\n            <span>{{text1}}</span> \n        <div>`,\n    data: globalObj\n});\n\nlet o2 = new Vue({\n    template:\n        `<div>\n            <span>{{text1}}</span> \n        <div>`,\n    data: globalObj\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个时候，我们执行了如下操作。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"globalObj.text1 = 'hello,text1';\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们应该需要通知 ",(0,r.jsx)(n.code,{children:"o1"})," 以及 ",(0,r.jsx)(n.code,{children:"o2"})," 两个vm实例进行视图的更新，「依赖收集」会让 ",(0,r.jsx)(n.code,{children:"text1"})," 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。"]}),"\n",(0,r.jsx)(n.p,{children:"最终会形成数据与视图的一种对应关系，如下图。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"接下来我们来介绍一下「依赖收集」是如何实现的。"}),"\n",(0,r.jsxs)(n.h2,{id:"订阅者-dep",children:["订阅者 Dep",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#订阅者-dep",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 ",(0,r.jsx)(n.code,{children:"Watcher"})," 观察者对象。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Dep {\n    constructor () {\n        /* 用来存放Watcher对象的数组 */\n        this.subs = [];\n    }\n\n    /* 在subs中添加一个Watcher对象 */\n    addSub (sub) {\n        this.subs.push(sub);\n    }\n\n    /* 通知所有Watcher对象更新视图 */\n    notify () {\n        this.subs.forEach((sub) => {\n            sub.update();\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"为了便于理解我们只实现了添加的部分代码，主要是两件事情："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["用 ",(0,r.jsx)(n.code,{children:"addSub"})," 方法可以在目前的 ",(0,r.jsx)(n.code,{children:"Dep"})," 对象中增加一个 ",(0,r.jsx)(n.code,{children:"Watcher"})," 的订阅操作；"]}),"\n",(0,r.jsxs)(n.li,{children:["用 ",(0,r.jsx)(n.code,{children:"notify"})," 方法通知目前 ",(0,r.jsx)(n.code,{children:"Dep"})," 对象的 ",(0,r.jsx)(n.code,{children:"subs"})," 中的所有 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象触发更新操作。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"观察者-watcher",children:["观察者 Watcher",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者-watcher",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Watcher {\n    constructor () {\n        /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */\n        Dep.target = this;\n    }\n\n    /* 更新视图的方法 */\n    update () {\n        console.log("视图更新啦～");\n    }\n}\n\nDep.target = null;\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"依赖收集",children:["依赖收集",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖收集",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们修改一下 ",(0,r.jsx)(n.code,{children:"defineReactive"})," 以及 Vue 的构造函数，来完成依赖收集。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们在闭包中增加了一个 Dep 类的对象，用来收集 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象。在对象被「读」的时候，会触发 ",(0,r.jsx)(n.code,{children:"reactiveGetter"})," 函数把当前的 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象（存放在 Dep.target 中）收集到 ",(0,r.jsx)(n.code,{children:"Dep"})," 类中去。之后如果当该对象被「",(0,r.jsx)(n.strong,{children:"写"}),"」的时候，则会触发 ",(0,r.jsx)(n.code,{children:"reactiveSetter"})," 方法，通知 ",(0,r.jsx)(n.code,{children:"Dep"})," 类调用 ",(0,r.jsx)(n.code,{children:"notify"})," 来触发所有 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象的 ",(0,r.jsx)(n.code,{children:"update"})," 方法更新对应视图。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function defineReactive (obj, key, val) {\n    /* 一个Dep类对象 */\n    const dep = new Dep();\n    \n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter () {\n            /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */\n            dep.addSub(Dep.target);\n            return val;         \n        },\n        set: function reactiveSetter (newVal) {\n            if (newVal === val) return;\n            /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */\n            dep.notify();\n        }\n    });\n}\n\nclass Vue {\n    constructor(options) {\n        this._data = options.data;\n        observer(this._data);\n        /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */\n        new Watcher();\n        /* 在这里模拟render的过程，为了触发test属性的get函数 */\n        console.log('render~', this._data.test);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"总结一下。"}),"\n",(0,r.jsxs)(n.p,{children:["首先在 ",(0,r.jsx)(n.code,{children:"observer"})," 的过程中会注册 ",(0,r.jsx)(n.code,{children:"get"})," 方法，该方法用来进行「",(0,r.jsx)(n.strong,{children:"依赖收集"}),"」。在它的闭包中会有一个 ",(0,r.jsx)(n.code,{children:"Dep"})," 对象，这个对象用来存放 Watcher 对象的实例。其实「",(0,r.jsx)(n.strong,{children:"依赖收集"}),"」的过程就是把 ",(0,r.jsx)(n.code,{children:"Watcher"})," 实例存放到对应的 ",(0,r.jsx)(n.code,{children:"Dep"})," 对象中去。",(0,r.jsx)(n.code,{children:"get"})," 方法可以让当前的 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象（Dep.target）存放到它的 subs 中（",(0,r.jsx)(n.code,{children:"addSub"}),"）方法，在数据变化时，",(0,r.jsx)(n.code,{children:"set"})," 会调用 ",(0,r.jsx)(n.code,{children:"Dep"})," 对象的 ",(0,r.jsx)(n.code,{children:"notify"})," 方法通知它内部所有的 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象进行视图更新。"]}),"\n",(0,r.jsxs)(n.p,{children:["这是 ",(0,r.jsx)(n.code,{children:"Object.defineProperty"})," 的 ",(0,r.jsx)(n.code,{children:"set/get"})," 方法处理的事情，那么「",(0,r.jsx)(n.strong,{children:"依赖收集"}),"」的前提条件还有两个："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["触发 ",(0,r.jsx)(n.code,{children:"get"})," 方法；"]}),"\n",(0,r.jsx)(n.li,{children:"新建一个 Watcher 对象。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["这个我们在 Vue 的构造类中处理。新建一个 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象只需要 new 出来，这时候 ",(0,r.jsx)(n.code,{children:"Dep.target"})," 已经指向了这个 new 出来的 ",(0,r.jsx)(n.code,{children:"Watcher"})," 对象来。而触发 ",(0,r.jsx)(n.code,{children:"get"})," 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 ",(0,r.jsx)(n.code,{children:"get"})," 进行「依赖收集」。"]}),"\n",(0,r.jsxs)(n.p,{children:["本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 ",(0,r.jsx)(n.code,{children:"get"})," 进行「依赖收集」。",(0,r.jsx)(n.code,{children:"set"})," 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["注：本节代码参考",(0,r.jsx)(n.a,{href:"https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86%E3%80%8B.js",target:"_blank",rel:"noopener noreferrer",children:"《响应式系统的依赖收集追踪原理》"}),"。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%96%E6%9E%90%20Vue.js%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F3.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86.md"]={toc:[{text:"为什么要依赖收集？",id:"为什么要依赖收集",depth:2},{text:"订阅者 Dep",id:"订阅者-dep",depth:2},{text:"观察者 Watcher",id:"观察者-watcher",depth:2},{text:"依赖收集",id:"依赖收集",depth:2},{text:"小结",id:"小结",depth:2}],title:"3.响应式系统的依赖收集追踪原理",headingTitle:"3.响应式系统的依赖收集追踪原理",frontmatter:{}}}}]);