"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["61280"],{61751:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(552676),t=s(740453);let a=s.p+"static/image/c98776a8f210403aa213af5665f75652.3ded0a06.webp",i=s.p+"static/image/44d4be47e20026ad4aac8a98c0a92b12.ad56b58a.webp",c=s.p+"static/image/4b0ef97fb73553d1ca18379f39fcb6d2.24619162.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",br:"br",img:"img",ul:"ul",li:"li",strong:"strong",h4:"h4",pre:"pre",code:"code"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"16行为型观察者模式面试真题手把手教学",children:["16.行为型：观察者模式——面试真题手把手教学",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16行为型观察者模式面试真题手把手教学",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上节我们说过，观察者模式作为一个超高频考点，在设计模式中具有举足轻重的地位。单从面试的维度来说，说它是最重要的设计模式也不为过。正因为如此，它的面试题变体可以说是五花八门。"}),"\n",(0,r.jsx)(n.p,{children:"不过面试题这东西，和数学题一样，看似变化多端，实则大同小异。大家如果经历的面试足够多，会发现观察者模式考来考去也就是那么几种考法，所谓的“变化多端”，也无非是改个条件改个变量的事情。本节在梳理了大量相关面试题的基础上，为大家总结了观察者模式的四个出题方向。相信有了本节的加持和下节的强化，大家再和面试官聊到观察者模式时，一定可以滔滔不绝、轻松拿下~"}),"\n",(0,r.jsxs)(n.h2,{id:"vue-响应式系统实现原理",children:["Vue 响应式系统实现原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-响应式系统实现原理",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"解析",children:["解析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解析",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Vue 框架是热门的渐进式\nJavaScript 框架。在 Vue 中，当我们修改状态时，视图会随之更新，这背后依赖就是Vue的响应式系统。",(0,r.jsx)(n.br,{}),"\n","响应式系统是Vue 最独特的特性之一。如果读者没有接触过 Vue，强烈建议阅读",(0,r.jsx)(n.a,{href:"https://v2.cn.vuejs.org/v2/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer",children:"Vue官方对响应式原理的介绍"}),"。此处我们用官方的一张流程图来简要地说明一下Vue响应式系统的整个流程："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"Vue响应式系统"})}),"\n",(0,r.jsxs)(n.p,{children:["在 Vue 中，每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。",(0,r.jsx)(n.br,{}),"\n","这道面试题能够同时考察受试者对 Vue 底层原理的理解、对观察者模式的应用能力以及对 JS 语言本身的运用能力，具有较强的综合性和代表性。"]}),"\n",(0,r.jsxs)(n.p,{children:["值得注意的是，在面试过程中，面试官多数情况下不会要求大家写出完整的响应式原理实现代码，而是要求你“说说自己的理解”。在本节，我们不会带大家一行一行写代码（具体深入 Vue 框架的相关知识，建议大家阅读",(0,r.jsx)(n.a,{href:"https://github.com/vuejs/vue",target:"_blank",rel:"noopener noreferrer",children:"Vue源码"}),"及这本",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6844733705089449991",target:"_blank",rel:"noopener noreferrer",children:"专门写Vue的小册"}),"。），而是针对 Vue 响应式系统中与观察者模式紧密关联的这部分知识作讲解，帮助大家捋清楚整套流程里的来龙去脉、加深对观察者模式的理解。"]}),"\n",(0,r.jsx)(n.p,{children:"在 Vue 响应式系统的实现逻辑里，有这样三个关键角色："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["observer（监听器）：注意，此 observer 非彼 observer。在我们上节的解析中，observer 作为设计模式中的一个角色，代表“订阅者”。但在 Vue 响应式系统的角色结构里，所谓的 observer 不仅是一个数据监听器，它还需要对监听到的数据进行",(0,r.jsx)(n.strong,{children:"转发"}),"——也就是说它",(0,r.jsx)(n.strong,{children:"同时还是一个发布者"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["watcher（订阅者）：observer 把数据转发给了",(0,r.jsx)(n.strong,{children:"真正的订阅者"}),"——watcher对象。watcher 接收到新的数据后，会去更新视图。"]}),"\n",(0,r.jsxs)(n.li,{children:["compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~",(0,r.jsx)(n.br,{}),"\n","这三者的配合过程如图所示："]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["OK，实现方案搞清楚了，下面我们给整个流程中",(0,r.jsx)(n.strong,{children:"涉及到发布-订阅这一模式的代码"}),"来个特写："]}),"\n",(0,r.jsxs)(n.h3,{id:"核心代码",children:["核心代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心代码",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"实现observer",children:["实现observer",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现observer",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先我们需要实现一个方法，这个方法会对需要监听的数据对象进行遍历、给它的属性加上定制的 getter 和 setter 函数。这样但凡这个对象的某个属性发生了改变，就会触发 setter 函数，进而通知到订阅者。这个 setter 函数，就是我们的监听器："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// observe方法遍历并包装对象属性\nfunction observe(target) {\n    // 若target是一个对象，则遍历它\n    if(target && typeof target === 'object') {\n        Object.keys(target).forEach((key)=> {\n            // defineReactive方法会给目标属性装上“监听器”\n            defineReactive(target, key, target[key])\n        })\n    }\n}\n\n// 定义defineReactive方法\nfunction defineReactive(target, key, val) {\n    // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历\n    observe(val)\n    // 为当前属性安装监听器\n    Object.defineProperty(target, key, {\n         // 可枚举\n        enumerable: true,\n        // 不可配置\n        configurable: false, \n        get: function () {\n            return val;\n        },\n        // 监听器函数\n        set: function (value) {\n            console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)\n            val = value\n        }\n    });\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"下面实现订阅者 Dep："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 定义订阅者类Dep\nclass Dep {\n    constructor() {\n        // 初始化订阅队列\n        this.subs = []\n    }\n    \n    // 增加订阅者\n    addSub(sub) {\n        this.subs.push(sub)\n    }\n    \n    // 通知订阅者（是不是所有的代码都似曾相识？）\n    notify() {\n        this.subs.forEach((sub)=>{\n            sub.update()\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"现在我们就可以改写 defineReactive 中的 setter 方法，在监听器里去通知订阅者了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function defineReactive(target, key, val) {\n    const dep = new Dep()\n    // 监听当前属性\n    observe(val)\n    Object.defineProperty(target, key, {\n        set: (value) => {\n            // 通知所有订阅者\n            dep.notify()\n        }\n    })\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实现一个event-bus-event-emitter",children:["实现一个Event Bus/ Event Emitter",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现一个event-bus-event-emitter",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Event Bus（Vue、Flutter 等前端框架中有出镜）和 Event Emitter（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——",(0,r.jsx)(n.strong,{children:"全局事件总线"}),"。",(0,r.jsx)(n.br,{}),"\n","全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式（具体的概念甄别我们会在下个小节着重讲）。它在我们日常的业务开发中应用非常广泛。"]}),"\n",(0,r.jsx)(n.p,{children:"上节开篇我说过，如果只能考一个设计模式的面试题，我一定会出观察者模式。"}),"\n",(0,r.jsx)(n.p,{children:"这句话接着往下说，如果只能选一道题，那这道题一定是 Event Bus/Event Emitter 的代码实现——我都说这么清楚了，这个知识点到底要不要掌握、需要掌握到什么程度，就看各位自己的了。"}),"\n",(0,r.jsxs)(n.h3,{id:"在vue中使用event-bus来实现组件间的通讯",children:["在Vue中使用Event Bus来实现组件间的通讯",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在vue中使用event-bus来实现组件间的通讯",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Event Bus/Event Emitter 作为全局事件总线，它起到的是一个",(0,r.jsx)(n.strong,{children:"沟通桥梁"}),"的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。",(0,r.jsx)(n.br,{}),"\n","在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 Vuex 之外，我们还可以通过 Event Bus 来实现我们的需求。"]}),"\n",(0,r.jsx)(n.p,{children:"创建一个 Event Bus（本质上也是 Vue 实例）并导出："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const EventBus = new Vue()\nexport default EventBus\n"})}),"\n",(0,r.jsx)(n.p,{children:"在主文件里引入EventBus，并挂载到全局："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import bus from 'EventBus的文件路径'\nVue.prototype.bus = bus\n"})}),"\n",(0,r.jsx)(n.p,{children:"订阅事件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 这里func指someEvent这个事件的监听函数\nthis.bus.$on('someEvent', func)\n"})}),"\n",(0,r.jsx)(n.p,{children:"发布（触发）事件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 这里params指someEvent这个事件被触发时回调函数接收的入参\nthis.bus.$emit('someEvent', params)\n"})}),"\n",(0,r.jsx)(n.p,{children:"大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上节的PrdPublisher和DeveloperObserver），全程只有bus这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！"}),"\n",(0,r.jsx)(n.p,{children:"下面，我们就一起来实现一个Event Bus（注意看注释里的解析）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class EventEmitter {\n  constructor() {\n    // handlers是一个map，用于存储事件与回调之间的对应关系\n    this.handlers = {}\n  }\n\n  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数\n  on(eventName, cb) {\n    // 先检查一下目标事件名有没有对应的监听函数队列\n    if (!this.handlers[eventName]) {\n      // 如果没有，那么首先初始化一个监听函数队列\n      this.handlers[eventName] = []\n    }\n\n    // 把回调函数推入目标事件的监听函数队列里去\n    this.handlers[eventName].push(cb)\n  }\n\n  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数\n  emit(eventName, ...args) {\n    // 检查目标事件是否有监听函数队列\n    if (this.handlers[eventName]) {\n      // 这里需要对 this.handlers[eventName] 做一次浅拷贝，主要目的是为了避免通过 once 安装的监听器在移除的过程中出现顺序问题\n      const handlers = this.handlers[eventName].slice()\n      // 如果有，则逐个调用队列里的回调函数\n      handlers.forEach((callback) => {\n        callback(...args)\n      })\n    }\n  }\n\n  // 移除某个事件回调队列里的指定回调函数\n  off(eventName, cb) {\n    const callbacks = this.handlers[eventName]\n    const index = callbacks.indexOf(cb)\n    if (index !== -1) {\n      callbacks.splice(index, 1)\n    }\n  }\n\n  // 为事件注册单次监听器\n  once(eventName, cb) {\n    // 对回调函数进行包装，使其执行完毕自动被移除\n    const wrapper = (...args) => {\n      cb(...args)\n      this.off(eventName, wrapper)\n    }\n    this.on(eventName, wrapper)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在日常的开发中，大家用到EventBus/EventEmitter往往提供比这五个方法多的多的多的方法。但在面试过程中，如果大家能够完整地实现出这五个方法，已经非常可以说明问题了，因此楼上这个EventBus希望大家可以熟练掌握。学有余力的同学，推荐阅读",(0,r.jsx)(n.a,{href:"https://github.com/facebook/emitter",target:"_blank",rel:"noopener noreferrer",children:"FaceBook推出的通用EventEmiiter库的源码"}),"，相信你会有更多收获。"]}),"\n",(0,r.jsxs)(n.h2,{id:"观察者模式与发布-订阅模式的区别是什么",children:["观察者模式与发布-订阅模式的区别是什么？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者模式与发布-订阅模式的区别是什么",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在面试过程中，一些对细节比较在意的面试官可能会追问观察者模式与发布-订阅模式的区别。这个问题可能会引发一些同学的不适，因为在大量参考资料以及已出版的纸质书籍中，都会告诉大家“发布-订阅模式和观察者模式是同一个东西的两个名字”。本书在前文的叙述中，也没有突出强调两者的区别。其实这两个模式，要较起真来，确实不能给它们划严格的等号。"}),"\n",(0,r.jsx)(n.p,{children:"为什么大家都喜欢给它们强行划等号呢？这是因为就算划了等号，也不影响我们正常使用，毕竟两者在核心思想、运作机制上没有本质的差别。但考虑到这个问题确实可以成为面试题的一个方向，此处我们还是单独拿出来讲一下。"}),"\n",(0,r.jsxs)(n.p,{children:["回到我们上文的例子里。韩梅梅把所有的开发者拉了一个群，直接把需求文档丢给每一位群成员，这种",(0,r.jsx)(n.strong,{children:"发布者直接触及到订阅者"}),"的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种",(0,r.jsx)(n.strong,{children:"发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"相信大家也已经看出来了，观察者模式和发布-订阅模式之间的区别，在于是否存在第三方、发布者能否直接感知订阅者（如图所示）。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在我们见过的这些例子里，韩梅梅拉钉钉群的操作，就是典型的观察者模式；而通过EventBus去实现事件监听/发布，则属于发布-订阅模式。"}),"\n",(0,r.jsx)(n.p,{children:"既生瑜，何生亮？既然有了观察者模式，为什么还需要发布-订阅模式呢？"}),"\n",(0,r.jsxs)(n.p,{children:["大家思考一下：为什么要有观察者模式？观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，",(0,r.jsx)(n.strong,{children:"并没有完全地解决耦合问题"}),"——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。"]}),"\n",(0,r.jsx)(n.p,{children:"而发布-订阅模式，则是快刀斩乱麻了——发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。发布-订阅模式下，实现了完全地解耦。"}),"\n",(0,r.jsxs)(n.p,{children:["但这并不意味着，发布-订阅模式就比观察者模式“高级”。在实际开发中，我们的模块解耦诉求",(0,r.jsx)(n.strong,{children:"并非总是需要它们完全解耦"}),"。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用发布-订阅模式。"]}),"\n",(0,r.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F16.%E8%A1%8C%E4%B8%BA%E5%9E%8B%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6.md"]={toc:[{text:"Vue 响应式系统实现原理",id:"vue-响应式系统实现原理",depth:2},{text:"解析",id:"解析",depth:3},{text:"核心代码",id:"核心代码",depth:3},{text:"实现observer",id:"实现observer",depth:4},{text:"实现一个Event Bus/ Event Emitter",id:"实现一个event-bus-event-emitter",depth:2},{text:"在Vue中使用Event Bus来实现组件间的通讯",id:"在vue中使用event-bus来实现组件间的通讯",depth:3},{text:"观察者模式与发布-订阅模式的区别是什么？",id:"观察者模式与发布-订阅模式的区别是什么",depth:2}],title:"16.行为型：观察者模式——面试真题手把手教学",headingTitle:"16.行为型：观察者模式——面试真题手把手教学",frontmatter:{}}}}]);