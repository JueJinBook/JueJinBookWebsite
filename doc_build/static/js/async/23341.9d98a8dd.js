"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["23341"],{870036:function(e,n,a){a.r(n),a.d(n,{default:()=>M});var r=a(552676),t=a(740453);let s=a.p+"static/image/4cf9fdb045bd33f446504de97c72c619.e4b0b268.webp",c=a.p+"static/image/1688a00e4e0b9d178512de32a12b3be0.5079e487.webp",i=a.p+"static/image/b99a8d12de526e4c0c34948057f01163.d7d26933.webp",p=a.p+"static/image/79cffa40a025f25535d642b6707bb6b9.6f0e0fff.webp",l=a.p+"static/image/f7df9a5c682bfec819a20d2b6f056a5c.255b781b.webp",d=a.p+"static/image/64ec7f75861145730785026562b8e8ef.09025205.webp",o=a.p+"static/image/e400fc0859f237b2b4dd1fb2a57f821c.edbc94ef.webp",m=a.p+"static/image/6bbcb48acd18ca386bcd3e88bbc65f36.998446c4.webp",j=a.p+"static/image/4179fee846391c03c722cd00e63e4c44.a84155ac.webp",h=a.p+"static/image/a80829f1d1a75640f4350d0b54c1e294.37501fc7.webp",x=a.p+"static/image/f3a0c82e7f3559c3cb8f6a7fd5d35f43.7f8dfb37.webp",g=a.p+"static/image/121e6cbce600f0ef58387f49b00c2127.9ef4b1d7.webp",y=a.p+"static/image/4151aa8eab6045c3e25c100d061b47bd.5bb5a23e.webp",b=a.p+"static/image/5bdff8297df5aa80e62f517abcd81764.01bafd1c.webp",f=a.p+"static/image/e8ae99197d435fc96b26f8ae40b0b662.a8129019.webp",u=a.p+"static/image/86e2d833bba8de26a1c7efd814937ef0.0c6fcdee.webp",E=a.p+"static/image/ed14e60913a0d97cd425e85c193a053c.42e7cfd8.webp",D=a.p+"static/image/556fc0c81884f74ee9dd7e559c3ebc73.6aaf6d23.webp",w=a.p+"static/image/770b3c11d7b7ef4815c9637d3bd7e335.d4779d3f.webp",A=a.p+"static/image/1d0097354040eff0f672e8c44dae6f87.dc5935a0.webp",S=a.p+"static/image/d996300ef1113099e267b3df2a04ea03.8763dde4.webp",C=a.p+"static/image/29fe5becc849de16ded8dfa47b0b9fd1.290b7f57.webp";function R(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"56-typeorm-一对多的映射和关联-crud",children:["56. TypeORM 一对多的映射和关联 CRUD",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#56-typeorm-一对多的映射和关联-crud",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们继续来学习 TypeORM 的一对多关系的映射和 CRUD。"}),"\n",(0,r.jsx)(n.p,{children:"我们再创建个 typeorm 项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npx typeorm@latest init --name typeorm-relation-mapping2 --database mysql\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"进入项目目录，安装驱动包 mysql2："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install mysql2\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后修改 data-source.ts 的配置："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import "reflect-metadata"\nimport { DataSource } from "typeorm"\nimport { User } from "./entity/User"\n\nexport const AppDataSource = new DataSource({\n    type: "mysql",\n    host: "localhost",\n    port: 3306,\n    username: "root",\n    password: "guang",\n    database: "typeorm_test",\n    synchronize: true,\n    logging: true,\n    entities: [User],\n    migrations: [],\n    subscribers: [],\n    poolSize: 10,\n    connectorPackage: \'mysql2\',\n    extra: {\n        authPlugin: \'sha256_password\',\n    }\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"这些前面讲过，就不解释了。"}),"\n",(0,r.jsx)(n.p,{children:"这次我们创建 Department 和 Employee 两个实体："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npx typeorm entity:create src/entity/Department\nnpx typeorm entity:create src/entity/Employee\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后添加 Department 和 Employee 的映射信息："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"\n\n@Entity()\nexport class Department {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column({\n        length: 50\n    })\n    name: string;\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"\n\n@Entity()\nexport class Employee {\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column({\n        length: 50\n    })\n    name: string;\n}\n\n'})}),"\n",(0,r.jsx)(n.p,{children:"把这俩 Entity 添加到 DataSource 的 entities 里："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"因为 index.ts 里用到了 User，我们用不到，把这些代码删掉："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，这两个表都创建成功了。"}),"\n",(0,r.jsx)(n.p,{children:"如何给它们添加一对多的映射呢？"}),"\n",(0,r.jsx)(n.p,{children:"通过 @ManyToOne 的装饰器："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在多的一方使用 @ManyToOne 装饰器。"}),"\n",(0,r.jsx)(n.p,{children:"把这两个表删掉："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"重新 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"就可以看到创建了两个表，并且在 employee 表添加了外建约束。"}),"\n",(0,r.jsx)(n.p,{children:"workbench 里也可以看到这个外键："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"改下 index.ts，新增一些数据，调用 save 保存："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Department } from './entity/Department';\nimport { Employee } from './entity/Employee';\nimport { AppDataSource } from \"./data-source\"\n\nAppDataSource.initialize().then(async () => {\n\n    const d1 = new Department();\n    d1.name = '技术部';\n\n    const e1 = new Employee();\n    e1.name = '张三';\n    e1.department = d1;\n\n    const e2 = new Employee();\n    e2.name = '李四';\n    e2.department = d1;\n\n    const e3 = new Employee();\n    e3.name = '王五';\n    e3.department = d1;\n\n    await AppDataSource.manager.save(Department, d1);\n    await AppDataSource.manager.save(Employee,[e1, e2, e3]);\n\n\n}).catch(error => console.log(error))\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"再跑下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到被 transaction 包裹的 4 条 insert 语句，分别插入了 Department 和 3 个 Employee。"}),"\n",(0,r.jsx)(n.p,{children:"当然，如果是设置了 cascade，那就只需要保存 empolyee 就好了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"department 会自动级联保存。"}),"\n",(0,r.jsx)(n.p,{children:"不过一对多关系更多还是在一的那一方来保持关系，我们改下 Department："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里要通过第二个参数指定外键列在 employee.department 维护。"}),"\n",(0,r.jsx)(n.p,{children:"一对一的时候我们还通过 @JoinColumn 来指定外键列，为什么一对多就不需要了呢？"}),"\n",(0,r.jsx)(n.p,{children:"因为一对多的关系只可能是在多的那一方保存外键呀！"}),"\n",(0,r.jsx)(n.p,{children:"所以并不需要 @JoinColumn。"}),"\n",(0,r.jsx)(n.p,{children:"不过你也可以通过 @JoinColumn 来修改外键列的名字："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"加上 @OneToMany 装饰器，再设置下 cascade："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样当你保存 department 的时候，关联的 employee 也都会保存了。"}),"\n",(0,r.jsx)(n.p,{children:"不过这时候要把 @ManyToOne 的 cascade 去掉。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不然，双方都级联保存，那不就无限循环了么？"}),"\n",(0,r.jsx)(n.p,{children:"然后修改下 index.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Department } from './entity/Department';\nimport { Employee } from './entity/Employee';\nimport { AppDataSource } from \"./data-source\"\n\nAppDataSource.initialize().then(async () => {\n    const e1 = new Employee();\n    e1.name = '张三';\n\n    const e2 = new Employee();\n    e2.name = '李四';\n\n    const e3 = new Employee();\n    e3.name = '王五';\n\n    const d1 = new Department();\n    d1.name = '技术部';\n    d1.employees = [e1, e2, e3];\n\n    await AppDataSource.manager.save(Department, d1);\n\n}).catch(error => console.log(error))\n"})}),"\n",(0,r.jsx)(n.p,{children:"只需要设置 department 的 employees 属性，然后 save 这个 department。"}),"\n",(0,r.jsx)(n.p,{children:"这样关联的 employee 就会自动保存："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后再来试下查询："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const deps = await AppDataSource.manager.find(Department);\nconsole.log(deps);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"想要关联查询需要声明下 relations："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const deps = await AppDataSource.manager.find(Department, {\n    relations: {\n        employees: true\n    }\n});\nconsole.log(deps);\nconsole.log(deps.map(item => item.employees))\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 relations 其实就是 left join on，或者通过 query builder 来手动关联："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const es = await AppDataSource.manager.getRepository(Department)\n            .createQueryBuilder('d')\n            .leftJoinAndSelect('d.employees', 'e')\n            .getMany();\n\nconsole.log(es);\nconsole.log(es.map(item => item.employees))\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"先 getRepository 再创建 query builder。"}),"\n",(0,r.jsx)(n.p,{children:"也可以直接用 EntityManager 来创建 query builder："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const es = await AppDataSource.manager\n    .createQueryBuilder(Department, 'd')\n    .leftJoinAndSelect('d.employees', 'e')\n    .getMany();\n\nconsole.log(es);\nconsole.log(es.map(item => item.employees))\n"})}),"\n",(0,r.jsx)(n.p,{children:"删除的话，需要先把关联的 employee 删了，再删除 department："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const deps = await AppDataSource.manager.find(Department, {\n    relations: {\n        employees: true\n    }\n});\nawait AppDataSource.manager.delete(Employee, deps[0].employees);\nawait AppDataSource.manager.delete(Department, deps[0].id);\n"})}),"\n",(0,r.jsx)(n.p,{children:"当然，如果你设置了 onDelete 为 SET NULL 或者 CASCADE："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那就不用自己删 employee 了，只要删了 department，mysql 会自动把关联的 employee 记录删除，或者是把它们的外键 id 置为空。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["案例代码在",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-relation-mapping2",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们学了一对多关系的映射，通过 @ManyToOne 或者 @OneToMany 装饰器。"}),"\n",(0,r.jsx)(n.p,{children:"TypeORM 会自动在多的那一方添加外键，不需要通过 @JoinColumn 指定，不过你可以通过 @JoinColumn 来修改外键列的名字。"}),"\n",(0,r.jsx)(n.p,{children:"双方只能有一方 cascade，不然会无限循环。设置了 cascade 之后，只要一方保存，关联的另一方就会自动保存。"}),"\n",(0,r.jsx)(n.p,{children:"删除的话，如果设置了外键的 CASCADE 或者 SET NULL，那只删除主表（一的那一方）对应的 Entity 就好了，msyql 会做后续的关联删除或者 id 置空。"}),"\n",(0,r.jsx)(n.p,{children:"否则就要先删除所有的从表（多的那一方）对应的 Entity 再删除主表对应的 Entity。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 typeorm 的一对多关系的映射和 CRUD。"})]})}function v(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(R,{...e})}):R(e)}let M=v;v.__RSPRESS_PAGE_META={},v.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F56.%20TypeORM%20%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E6%98%A0%E5%B0%84%E5%92%8C%E5%85%B3%E8%81%94%20CRUD.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"56. TypeORM 一对多的映射和关联 CRUD",headingTitle:"56. TypeORM 一对多的映射和关联 CRUD",frontmatter:{}}}}]);