"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["51666"],{245856:function(n,e,i){i.r(e),i.d(e,{default:()=>D});var s=i(552676),r=i(740453);let t=i.p+"static/image/af42a933c83e24520a87758e2b1631db.3b154261.webp",c=i.p+"static/image/b980478e271e3e104e9ac9d99d0bc52b.168d0e38.gif",a=i.p+"static/image/d04907d54b78168b10833826eb0c40ef.01068598.webp",l=i.p+"static/image/8c195b9875ae44adee37324d14e3d9fd.bb586b2f.gif",d=i.p+"static/image/cda87f03a4de38718ab77e9d3c3ad5bc.f78d0d20.webp",p=i.p+"static/image/4f0f20a571f29125068358075dc8e461.de50b5f0.gif",o=i.p+"static/image/4e081ca45d2e739bf8d057b9211f6975.aaa16c1f.webp",x=i.p+"static/image/97b9c72771d6e286fd86b272a5d1f18a.b875bfee.webp",h=i.p+"static/image/6ba4ee140e96f8c3c31405bd9c153418.23536e8a.webp",j=i.p+"static/image/966b1f3f36bc4cc09947f656b9761f8a.a94a9f87.gif",m=i.p+"static/image/4f5105aa119d2f7d13e96f01cb21800a.1db2f4bd.webp",b=i.p+"static/image/76e604ec04df64cf13bf57505c34a503.f6b7818c.webp",f=i.p+"static/image/6207aa9a011a0e6048079e31593bd391.320e7a61.webp",g=i.p+"static/image/75ce3ad9e78942fb870d09ce9b22bc2c.def5904e.gif",u=i.p+"static/image/5dbe601fd9abd7529f29d75d7f086b95.c70716a2.webp",v=i.p+"static/image/51f77f1f663ee096edbf2551893ec193.75bb19c6.webp",E=i.p+"static/image/6307c8290dd2f602e5cc4d4de85ff104.b240a3c9.webp",w=i.p+"static/image/96e15ab914da55ce622bdf19a755f82e.ae81f58b.gif",y=i.p+"static/image/0c7ff28cc511655d793eaaa8250f54f7.b5ca7400.gif",A=i.p+"static/image/0eda34ad0d0a54176399eb4ecd22e277.1b0ab943.gif",O=i.p+"static/image/d78504d6fd9b7d297955158766eaf7ee.255b9d8b.webp",S=i.p+"static/image/b9ef9382d113b7d9956078e80824e281.a41b668f.webp",N=i.p+"static/image/3612a7f9207ce12fbaed301a427bdce8.5163b035.webp",R=i.p+"static/image/2571f00b51432c308c75987497d8835d.066b14b9.webp",V=i.p+"static/image/978c87e6af658b8ac99d13acf26996d1.a72413fb.webp",T=i.p+"static/image/9c89b286834301bae573e96f9e8b188c.93fadcf5.webp",I=i.p+"static/image/ef66037760f38bcd74f05cb58c1149a0.636ef38d.gif",C=i.p+"static/image/99e6115c4e8a5562632a3ab4b035b73f.3cf54105.webp",_=i.p+"static/image/6481707fa8c686d9be80a51e8f8b8c33.37358427.webp",k=i.p+"static/image/9c03b464bd7e3d348088ae28c88fcfb7.2f69ed64.webp";function B(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第29章react-spring实现滑入滑出的转场动画",children:["第29章—react-spring实现滑入滑出的转场动画",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第29章react-spring实现滑入滑出的转场动画",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF有的时候，直接展示一个组件会过于突兀，需要一些过渡效果。"}),"\n",(0,s.jsx)(e.p,{children:"比如这样："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"点击结算的时候，展示结算页面的组件，点击返回的时候隐藏。"}),"\n",(0,s.jsx)(e.p,{children:"这里是通过滑入滑出的动画来实现的过渡。"}),"\n",(0,s.jsx)(e.p,{children:"这个效果是我公司的项目里真实在用的，这节我们来一起实现下。"}),"\n",(0,s.jsx)(e.p,{children:"我们说的转场动画、过渡动画是一个东西，你看下英文翻译就知道了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这里的过渡动画很明显可以用我们学过的 react-transition-group 或者 react-spring 来做。"}),"\n",(0,s.jsx)(e.p,{children:"我们就用 reac-spring 结合上节学的 styled-components 来实现下。"}),"\n",(0,s.jsx)(e.p,{children:"创建个 vite 项目："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"npx create-vite slide-in-out-transition\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"安装用到的包："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"npm install\n\nnpm install --save @react-spring/web\n\nnpm install --save styled-components\n"})}),"\n",(0,s.jsx)(e.p,{children:"要实现这样的效果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"首先，我们需要一个 div 包裹它。"}),"\n",(0,s.jsx)(e.p,{children:"创建 src/Overlay.tsx"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import styled from "styled-components";\n\nconst Overlay = styled.div`\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: rgba(0, 0, 0, 0.3);\n  z-index: 10;\n`;\n\nexport default Overlay;\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后在 src/SlideInOverlay.tsx 里用一下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import React, { FC, PropsWithChildren } from "react";\nimport { useTransition, animated } from "@react-spring/web";\nimport Overlay from "./Overlay";\n\nconst DURATION = 300;\n\ninterface SlideInOverlayProps extends PropsWithChildren {\n  isVisible: boolean;\n  from?: "right" | "bottom";\n}\n\nconst SlideInOverlay: FC<SlideInOverlayProps> = (props) => {\n  const { isVisible, from = "right", children } = props;\n\n  const x = React.useMemo(\n    () => (from === "right" ? window.screen.width : window.screen.height),\n    [from]\n  );\n\n  const transitions = useTransition(isVisible, {\n    x,\n    opacity: 1,\n    from: {\n      x,\n      opacity: 1,\n    },\n    enter: { x: 0, opacity: 1 },\n    leave: { x, opacity: 0 },\n    config: { duration: DURATION },\n  });\n\n  const translate = React.useCallback(\n    (x: number) => {\n      switch (from) {\n        case "right":\n          return `translateX(${x}px)`;\n        case "bottom":\n          return `translateY(${x}px)`;\n      }\n    },\n    [from]\n  );\n\n  return (\n    <>\n      {transitions(\n        (props, isVisible) =>\n          isVisible && (\n            <Overlay\n              as={animated.div}\n              style={{\n                transform: props.x.to((x) => (x === 0 ? "none" : translate(x))),\n                opacity: props.opacity,\n              }}\n            >\n              {children}\n            </Overlay>\n          )\n      )}\n    </>\n  );\n};\n\nexport { SlideInOverlay, DURATION };\n'})}),"\n",(0,s.jsx)(e.p,{children:"代码比较多，我们一部分一部分来看下："}),"\n",(0,s.jsx)(e.p,{children:"首先，这个 SlideInOverlay 组件有 3 个 props："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"isVisible 是是否展示。"}),"\n",(0,s.jsx)(e.p,{children:"from 是从右向左还是从下向上来运动，取值为 right 或 bottom。"}),"\n",(0,s.jsx)(e.p,{children:"children 传入具体的内容。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:V,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"用 react-spring 的 useTransition 来做动画，改变 x、opcity 属性。"}),"\n",(0,s.jsx)(e.p,{children:"设置初始值、from 的值、enter 的值，以及 leave 的值。"}),"\n",(0,s.jsx)(e.p,{children:"也就是进入动画开始、进入动画结束、离开动画结束的值。"}),"\n",(0,s.jsx)(e.p,{children:"然后下面的 div 使用 react-spring 传入的 x、opcity 来设置样式就好了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"Overlay 是样式组件，用 as 转为用 animated.div 渲染。"}),"\n",(0,s.jsx)(e.p,{children:"初始值 x 根据 from 参数是 right 还是 bottom 来设置 window.screen.width 或者 height。"}),"\n",(0,s.jsx)(e.p,{children:"这里用 useMemo 的好处是只要 from 参数没变，就直接用之前的值。"}),"\n",(0,s.jsx)(e.p,{children:"然后 react-spring 传入的 x 还需要根据 from 来转为 translateX 或者 translateY 的样式。"}),"\n",(0,s.jsx)(e.p,{children:"这样，转场动画就完成了。"}),"\n",(0,s.jsx)(e.p,{children:"我们来试一下："}),"\n",(0,s.jsx)(e.p,{children:"去掉 main.tsx 的 StrictMode 和 index.css。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"在 App.tsx 里用一下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { useState } from "react";\nimport reactLogo from "./assets/react.svg";\nimport viteLogo from "/vite.svg";\nimport "./App.css";\nimport { SlideInOverlay } from "./SlideInOverlay";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [show, setShow] = useState(false);\n\n  return (\n    <>\n      <button\n        onClick={() => {\n          setShow(true);\n        }}\n      >\n        开启\n      </button>\n      <SlideInOverlay\n        isVisible={show}\n        from="right"\n        className={"guangguang"}\n        style={{\n          border: "2px solid #000",\n        }}\n      >\n        <div>\n          <button\n            onClick={() => {\n              setShow(false);\n            }}\n          >\n            关闭\n          </button>\n          <a href="https://vitejs.dev" target="_blank">\n            <img src={viteLogo} className="logo" alt="Vite logo" />\n          </a>\n          <a href="https://react.dev" target="_blank">\n            <img src={reactLogo} className="logo react" alt="React logo" />\n          </a>\n        </div>\n        <h1>Vite + React</h1>\n        <div className="card">\n          <button onClick={() => setCount((count) => count + 1)}>\n            count is {count}\n          </button>\n          <p>\n            Edit <code>src/App.tsx</code> and save to test HMR\n          </p>\n        </div>\n        <p className="read-the-docs">\n          Click on the Vite and React logos to learn more\n        </p>\n      </SlideInOverlay>\n    </>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(e.p,{children:"我们加了一个 state 来保存显示隐藏状态，加了两个 button，点击的时候切换。"}),"\n",(0,s.jsx)(e.p,{children:"跑一下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"npm run dev\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，滑入滑出的转场动画（或者叫过渡动画）生效了。"}),"\n",(0,s.jsx)(e.p,{children:"而且因为只是改变了 translate，组件不会销毁，所以状态也可以保留。"}),"\n",(0,s.jsx)(e.p,{children:"再来试下另一种效果，把 from 改为 bottom："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"完美！"}),"\n",(0,s.jsx)(e.p,{children:"用在真实项目里就是这样的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"然后我们再完善一下细节："}),"\n",(0,s.jsx)(e.p,{children:"加上 className 和 style 两个 props。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'interface SlideInOverlayProps extends PropsWithChildren {\n  isVisible: boolean;\n  from?: "right" | "bottom";\n  className?: string | string[];\n  style?: CSSProperties;\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"传入样式组件："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"安装用到的 classnames 包"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"npm install --save classnames\n"})}),"\n",(0,s.jsx)(e.p,{children:"测试下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:u,alt:"d-14.png"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可以看到 style 生效了，className 也加上了。"}),"\n",(0,s.jsx)(e.p,{children:"我们继续完善，添加 onEnter 参数："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"然后加一下处理逻辑："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"useEffect(() => {\n  let timer = null;\n\n  if (isVisible === true && onEnter != null) {\n    timer = setTimeout(onEnter, DURATION);\n  }\n\n  return () => {\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n  };\n}, [isVisible, onEnter]);\n"})}),"\n",(0,s.jsx)(e.p,{children:"因为我们设置了动画的时长是 DURATION 常量，所以这里用一个 setTimeout 就可以实现 onEnter"}),"\n",(0,s.jsx)(e.p,{children:"判断下 isVisible 是 true 的时候再执行 onEnter 的定时器。"}),"\n",(0,s.jsx)(e.p,{children:"并且当 isVisible、onEnter 变化的时候，销毁上次的定时器，重新跑。"}),"\n",(0,s.jsx)(e.p,{children:"测试下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"没啥问题。"}),"\n",(0,s.jsx)(e.p,{children:"接下来继续实现 onExit。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"添加参数，然后加上 useEffect 通过 setTimeout 触发："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"useEffect(() => {\n  let timer = null;\n\n  if (isVisible === false && onExit != null) {\n    timer = setTimeout(onExit, DURATION);\n  }\n\n  return () => {\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n  };\n}, [isVisible, onExit]);\n"})}),"\n",(0,s.jsx)(e.p,{children:"跑一下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，滑入滑出时的回调没问题，但是最开始多回调了一次 onExit。"}),"\n",(0,s.jsx)(e.p,{children:"如何判断出最开始那一次呢？"}),"\n",(0,s.jsx)(e.p,{children:"记录下 isVisible 参数就可以了，如果是从 true 变为 false 才触发。"}),"\n",(0,s.jsx)(e.p,{children:"用 useRef 保存上次的 isVisible 参数的值，如果上次的是 true 而当前 isVisible 是 false 就触发。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const visibleRef = useRef(isVisible);\n\nuseEffect(() => {\n    let timer = null;\n\n    if (isVisible === false && visibleRef.current === true && onExit != null) {\n      timer = setTimeout(onExit, DURATION);\n    }\n\n    visibleRef.current = isVisible;\n\n    return () => {\n      if (timer != null) {\n        clearTimeout(timer);\n      }\n    };\n}, [isVisible, onExit]);\n"})}),"\n",(0,s.jsx)(e.p,{children:"测试下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，现在最开始多的一次调用就没有了。"}),"\n",(0,s.jsx)(e.p,{children:"这样，这个 SlideInOverlay 组件就完成了。"}),"\n",(0,s.jsx)(e.p,{children:"当然，你还可以做更多的扩展，比如点击商品的时候从下面滑入商品详情："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这里是距离顶部有一段距离的，这个距离也可以作为参数传入。"}),"\n",(0,s.jsx)(e.p,{children:"如果想实现这种和手势结合的动画呢？"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这个我们做过了呀，可以回去看看手势库那节。"}),"\n",(0,s.jsx)(e.p,{children:"拖动速度、方向、距离这类需求都可以用手势库搞定。"}),"\n",(0,s.jsxs)(e.p,{children:["案例代码上传了",(0,s.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/slide-in-out-transition",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"很多场景下，加上转场动画会使交互体验更好。"}),"\n",(0,s.jsx)(e.p,{children:"这节我们用 react-spring 实现了滑入滑出的转场动画（或者叫过渡动画）。"}),"\n",(0,s.jsx)(e.p,{children:"支持了 isVisible、from、children、onExit、onEnter、className、style 参数。"}),"\n",(0,s.jsx)(e.p,{children:"from 可以设置 right 或 bottom，然后根据它来设置 x 参数初始值为 window.screen.width 或者 window.screen.height。"}),"\n",(0,s.jsx)(e.p,{children:"改变 x、opacity 就可以实现滑入滑出的动画。"}),"\n",(0,s.jsx)(e.p,{children:"我们通过 useRef 记录之前的参数来实现了 onExit 的回调。"}),"\n",(0,s.jsx)(e.p,{children:"用 styled-components 写了外层 div 的样式。"}),"\n",(0,s.jsx)(e.p,{children:"这样的 SlideInOverlay 组件就比较完善了，可以直接用在项目里。"})]})}function P(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(B,{...n})}):B(n)}let D=P;P.__RSPRESS_PAGE_META={},P.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC29%E7%AB%A0%E2%80%94react-spring%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%85%A5%E6%BB%91%E5%87%BA%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第29章—react-spring实现滑入滑出的转场动画",headingTitle:"第29章—react-spring实现滑入滑出的转场动画",frontmatter:{}}}}]);