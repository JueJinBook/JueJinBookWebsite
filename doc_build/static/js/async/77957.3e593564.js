"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77957"],{675428:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(552676),t=r(740453);let i=r.p+"static/image/8-1.d7a46c16.png";function a(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",img:"img",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsxs)(n.h1,{id:"8案例七视频流转-mp3-工具---node-数据流和管道---streampipe",children:["8案例七：[视频流转 MP3 工具] - Node 数据流和管道 - Stream、pipe",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8案例七视频流转-mp3-工具---node-数据流和管道---streampipe",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-!",children:"本节目标：【实现一个视频流转 MP3 工具】 - 数据界的顺丰，把一个一个数据包运往九州各地。\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"stream-流",children:["Stream 流",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stream-流",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["流是 UNIX 系统中的一个标准概念，很多场景都用到了流，比如标准输入输出，比如管道符命令 ",(0,s.jsx)(n.code,{children:"cat *.js | grep fs"}),"，来打印出所有的 js 文件，然后交给 grep 来过滤出包含 fs 的文件内容，这个竖线就是 unix 的管道。"]}),"\n",(0,s.jsx)(n.p,{children:"我们已经知道，Buffer 是一个临时的内存缓冲区，用来保存原始二进制数据，而流就是移动数据，它俩通常结合起来用，我们要拷贝一份文件，比如上面例子里面，拷贝一个小的 logo 图片，这种方式是把文件内容全部读入内存中，然后再写入到文件，对于小体积的文件是 ok 的，但是对于体积较大的文件，比如视频，如果使用这种方法，内存可能就不够用了，如果此时有多个请求都在请求和文件，服务器需要不断的读取某个文件，每个请求都会有一份内存保存文件，内存也很容易爆掉，所以最好是能做到边读边写，读一部分写一部分而不是一口吃成大胖子，这就要借助流来完成。"}),"\n",(0,s.jsx)(n.p,{children:"流是一个抽象接口，在 Nodejs 有很多模块都用到流，比如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fs 文件系统模块：可读可写流，如 createReadStream/createWriteStream"}),"\n",(0,s.jsx)(n.li,{children:"net 底层的网络通信模块：处理通信的双工流 如 connect/tcp/socket"}),"\n",(0,s.jsx)(n.li,{children:"crypto 加密解密模块：各种算法类的加密流，如 Hmac/Cipher/Hash"}),"\n",(0,s.jsx)(n.li,{children:"http 网络模块：请求响应流，如 request/response"}),"\n",(0,s.jsx)(n.li,{children:"process 进程模块：输入输出流，如 stdin/stuout/stderr"}),"\n",(0,s.jsx)(n.li,{children:"zlib 压缩模块：各种压缩解压流，如 createGzip/createGunzip/createDeflate/createInflate"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"流的应用范围这么广，所以我们有必要了解流的概念以及使用，这对于我们理解 HTTP，以及运用 Nodejs 很有帮助。"}),"\n",(0,s.jsxs)(n.h3,{id:"四大流王",children:["四大流王",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四大流王",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"流里面也有不同的分工，我们先看下四大流王都是什么和能做什么？"}),"\n",(0,s.jsx)(n.p,{children:"Node 里面的流有四种，分别是 readable/writable/duplextransform，它们的意义如下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Readable Stream 是可读流，用来提供数据，外部来源的数据会被存储到内部的 Buffer 数组内缓存起来，可读流有两个模式，分别是 pause（暂停）和 resume（流动），顾名思义，流动模式会源源不断把数据读进来缓存，暂停则按兵不动，不去获取数据也不会积累缓存。"}),"\n",(0,s.jsx)(n.li,{children:"Writeable Stream 是可写流，用来消费数据，从可读流中获取数据，对拿到的 Buffer 数据进行处理消耗，把它写入目标对象，它有一个 drain 事件，来判定是否当前的缓存数据写入完毕。"}),"\n",(0,s.jsx)(n.li,{children:"Duplex streams 也叫双工流，文武双全可直可弯，即是 Readable 也是 Writable，比如 Tcp socket 是可读可写的双工流，另外 zlib/crypto 也都实现了双工流。"}),"\n",(0,s.jsx)(n.li,{children:"Transform streams 是转换流，它本身也是双工流，只是输出和输入有一定的关联关系，它通常不保存数据，只负责处理和加工流经它的数据，可以把它想象成一个水管的阀门控制器或者消毒器这样的中间件，在 Node 里面，zlib/crypto 实现了转换流。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"四大流都有各自不同的能力，但总体上的特征类似，都是对缓冲的数据进行进出处理，他们结合起来使用会非常编写，而把他们结合起来，我们通常的做法是通过 pipe 管道来连接或者反转，管道的部分我们得会来讲，先看下流本身具备的一些状态，也就是跟事件的结合。"}),"\n",(0,s.jsxs)(n.h3,{id:"流与事件",children:["流与事件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流与事件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们上一节有尝试借助 Buffer 来复制图片的代码，再用同步的方式改造一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const source = fs.readFileSync('img.png')\n\nfs.writeFileSync('img_copy.png', source)\n"})}),"\n",(0,s.jsx)(n.p,{children:"当然也可以通过 fs.copyFile 来实现，只不过这样过于简单粗暴，实际上数据在流动过程中，应该有一些精细的传输阶段或者状态的，这些状态呢，是通过 EventEmitter 控制，而流 Stream 是 EventEmitter 的实例，它是基于事件机制运作的，也就是说在流对象上，可以监听事件可以触发事件，流在各个阶段的变化我们都可以实时监听到，从而实现更精细的控制，比如暂停和恢复，我们再来上一段读取 mp3 的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs')\n// 创建一个可读流，把内容从目标文件里一块一块抠出来缓存\nconst rs = fs.createReadStream('./myfile.mp3')\nlet n = 0\nrs\n  // 数据正在传递时，触发该事件（以 chunk 数据块为对象）\n  // 每次 chunk 块最大是 64kb，如果凑不够 64kb，会缩小为 32kb\n  .on('data', (chunk) => {\n    // 记录一共获取到了多少次 chunk\n    n++\n    console.log(chunk.byteLength)\n    console.log(Buffer.isBuffer(chunk))\n    // console.log('data emits')\n    // console.log(chunk.toString('utf8'))\n    // 我们可以每次都暂停数据读取，做一些数据中间处理（比如压缩）后再继续读取数据\n    rs.pause()\n    console.log('暂停获取....')\n    setTimeout(() => {\n      console.log('继续获取....', n + 1)\n      rs.resume()\n    }, 100)\n  })\n  // 数据传递完成后，会触发 'end' 事件\n  .on('end', () => {\n    console.log(`传输结束，共收到 ${n} 个 Buffer 块`)\n  })\n  // 整个流传输结束关闭的时候会触发 close\n  .on('close', () => {\n    console.log('传输关闭')\n  })\n  // 异常中断或者出错时的回调处理\n  .on('error', (e) => {\n     console.log('传输出错' + e)\n  })\n"})}),"\n",(0,s.jsx)(n.p,{children:"打印的结果类似这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"65536\ntrue\n暂停获取....\n继续获取.... 2\n65536\ntrue\n...\n暂停获取....\n继续获取.... 107\n65536\ntrue\n暂停获取....\n继续获取.... 108\n23428\ntrue\n暂停获取....\n传输结束，共收到 108 个 Buffer 块\n传输关闭\n继续获取.... 109\n"})}),"\n",(0,s.jsx)(n.p,{children:"发现我本地的这个 mp3 文件，读取过程中，一共读取到 109 块缓冲，一开始每次都是 64kb，最后一次剩余了不到 20kb 的数据，每次读进来的都是 Buffer，而且读取过程中可以暂停也可以再恢复。"}),"\n",(0,s.jsxs)(n.h3,{id:"流速控制",children:["流速控制",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流速控制",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"了解了 stream 的暂停能力和事件特征，我们可以再次重构下复制图片的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const rs = fs.createReadStream('./logo.png')\nconst ws = fs.createWriteStream('./logo_write.png')\n\nrs.on('data', (chunk) => {\n  // 当有数据流出时，写入数据\n  ws.write(chunk)\n})\nrs.on('end', () => {\n  // 当没有数据时，关闭数据流\n  ws.end()\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"这是基于流机制实现的文件拷贝，它存在这样一个问题，如果读的快，写的慢，因为磁盘 IO 的读写速度并不是一致的，如果读的快，写得慢，积压的内存缓冲越来越多，内存可能会爆仓，那应该怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"幸运的是，在 stream 里面，流的 write 方法会有一个返回值，它告诉我们传入的数据是否依然停留在缓存区，再根据 drain 事件判断是否缓存数据写入目标了，就可以继续恢复，来写入下一个数据缓存了，这样来改造下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs')\nconst rs = fs.createReadStream('./logo.png')\nconst ws = fs.createWriteStream('./logo_write_safe.png')\n\nrs.on('data', (chunk) => {\n  // 看看是否缓冲数据被写入，写入是 true，未写入是 false\n  if (ws.write(chunk) === false) {\n    console.log('still cached')\n    rs.pause()\n  }\n})\nrs.on('end', () => {\n  // 当没有数据再消耗后，关闭数据流\n  ws.end()\n})\nws.on('drain', () => {\n  console.log('数据被消耗后，继续启动读数据')\n  rs.resume()\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样就简陋的实现了防爆仓，越是大的文件越需要优雅的处理。"}),"\n",(0,s.jsxs)(n.h3,{id:"流的数据管道---pipe",children:["流的数据管道 - pipe",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流的数据管道---pipe",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"无论是哪一种流，都会使用 pipe() 方法来实现输入和输出，pipe 的左边是是流，右边也是流，左边读出的数据，经过 pipe 输送给右边的目标流，目标流经过处理后，可以继续往下不断的 pipe，从而形成一个 pipe 链条，小水管就全部串起来了。"}),"\n",(0,s.jsx)(n.p,{children:"对于 pipe 方法，我们来举两个例子，第一个例子是依然是复制图片，我们可以这样做："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fs.createReadStream('./logo.png')\n  .pipe(fs.createWriteStream('./logo-pipe.png'))\n"})}),"\n",(0,s.jsx)(n.p,{children:"一句代码就能搞定复制，非常强大，再来看第二个例子，从浏览器向服务器请求一个非常大的文本文件，大家可以在本地存一个大于 5MB 的文本文件，然后跑如下代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// request-txt.js\nconst fs = require('fs')\nconst http = require('http')\n\nhttp.createServer((req, res) => {\n  res.writeHeader(200, {'Context-Type': 'text/html'})\n  // 1. 把文件内容全部读入内存\n  fs.readFile('./big.txt', (err, data) => {\n    // 2. 通过 res 批量返回\n    res.end(data)\n  })\n}).listen(5000)\n"})}),"\n",(0,s.jsx)(n.p,{children:"会发现客户端需要等待一段时间才能看到数据，我们用 pipe 改写下再观察下页面内容呈现的速度："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs')\nconst http = require('http')\n\nhttp.createServer((req, res) => {\n  res.writeHeader(200, {'Context-Type': 'text/html'})\n  fs.createReadStream('./big.txt').pipe(res)\n}).listen(5000)\n"})}),"\n",(0,s.jsx)(n.p,{children:"明显这个展现速度加快许多，内容是一片片出来的，原因就在于 pipe 会自动监听 data 和 end 事件，文件中的每一小段数据都会源源不断的发送给客户端，pipe 方法 还可以自动控制后端压力，在客户端连接缓慢的时候 Node 可以将尽可能少的缓存放到内存中，通过对内存空间的调度，就能自动控制流量从而避免目标被快速读取的可读流所淹没，并且，数据在 pipe 的时候，只有 pipe 链末端的目标流真正需要数据的时候，数据才会从源头被取出来，然后顺着管子一路走下去，属于被动消费，那么整体表现就会更优异一些。"}),"\n",(0,s.jsx)(n.p,{children:"OK, 关于 pipe，有许多有趣的玩法，我们对流和 pipe 简单总结一下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"可读流负责获取外部数据，并把外部数据缓存到内部 Buffer 数组"}),"\n",(0,s.jsx)(n.li,{children:"可写流负责消费数据，从可读流中获取到数据，然后对得到的 chunk"}),"\n",(0,s.jsx)(n.li,{children:"数据块进行处理，至于如何处理，就取决于于这个可写流内部 write 方法如何实现"}),"\n",(0,s.jsx)(n.li,{children:"pipe 会自动控制数据的读取速度，来帮助数据以一种比较合理的速度，源源不断的输送给目的地"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"定制流",children:["定制流",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定制流",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Node 除了提供各种流，还提供了流的接口，来定制我们自己的流方案，这些接口实例也拥有各种和流交互的方法，比如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 获取流很简单，require 即可\nconst Readable = require('stream').Readable\nconst Writeble = require('stream').Writable\n// require 后，可以来创建流实例\nconst rs = new Readable()\nconst ws = new Writeble()\n\n// 流实例创建后，比如是 stream\n// 可以往流里面推送一个 chunk 数据\nstream.push()\n// 推送 null 来告诉流可以 close 了\nstream.push(null)          \n// 流异常时候发出一个异常事件 \nstream.emit('error', error)\n\n// 告诉流可以继续消费数据了\nstream.resume()\n// 告诉流先暂停\nstream.pause()\n// 每次有数据过来，都会流经这个回调函数\nstream.on('data', data => {})\n\n// 监听流异常事件，调用回调函数\nstream.on('error', (err) => {})\n// 监听流关闭事件，调用回调函数\nstream.on('close', () => {})\n// 监听流完成事件，调用回调函数\nstream.on('finish', () => {})\n"})}),"\n",(0,s.jsx)(n.p,{children:"流实例的交互能力很完整了，我们来实现一个搬运字符串的小例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// 拿到 stream 里面的可读可写流接口\nconst Readable = require('stream').Readable\nconst Writeble = require('stream').Writable\nconst rs = new Readable()\nconst ws = new Writeble()\nlet n = 0\n\n// 一次次往流里面推数据\nrs.push('I ')\nrs.push('Love ')\nrs.push('Juejin!\\n')\nrs.push(null)\n\n// 每一次 push 的内容在 pipe 的时候\n// 都会走到 _write 方法，在 _write 里面可以再做处理\nws._write = function(chunk, ev, cb) {\n  n++\n  console.log('chunk' + n + ': ' + chunk.toString())\n  // chunk1: I\n  // chunk2: Love\n  // chunk3: Juejin!\n  cb()\n}\n\n// pipe 将两者连接起来，实现数据的持续传递，我们可以不去关心内部数据如何流动\nrs.pipe(ws)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个案例可以改的再复杂一些，来加深印象，我们把转换流也加进去，实现它的内置接口 ",(0,s.jsx)(n.code,{children:"_transform"})," 和 ",(0,s.jsx)(n.code,{children:"_flush"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const stream = require('stream')\n\nclass ReadStream extends stream.Readable {\n  constructor() {\n    super()\n  }\n\n  _read () {\n    this.push('I ')\n    this.push('Love ')\n    this.push('Juejin!\\n')\n    this.push(null)\n  }\n}\n\nclass WriteStream extends stream.Writable {\n  constructor() {\n    super()\n    this._storage = Buffer.from('')\n  }\n\n  _write (chunk, encode, cb) {\n    console.log(chunk.toString())\n    cb()\n  }\n}\n\nclass TransformStream extends stream.Transform {\n  constructor() {\n    super()\n    this._storage = Buffer.from('')\n  }\n\n  _transform (chunk, encode, cb) {\n    this.push(chunk)\n    cb()\n  }\n\n  _flush (cb) {\n    this.push('Oh Yeah!')\n    cb()\n  }\n}\n\nconst rs = new ReadStream()\nconst ws = new WriteStream()\nconst ts = new TransformStream()\n\nrs.pipe(ts).pipe(ws)\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"编程练习---实现一个-mp4-转-mp3-工具",children:["编程练习 - 实现一个 MP4 转 MP3 工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---实现一个-mp4-转-mp3-工具",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["最后，我们来基于对流的理解，在本地实现一个下载 MP4 和从 MP4 里面导出 MP3 的小工具，本地操作视频流，我们可以借助于 ",(0,s.jsx)(n.a,{href:"http://ffmpeg.org/",target:"_blank",rel:"noopener noreferrer",children:"FFMPEG"})," , ffmpeg 是一个跨平台的流媒体库，可以记录和转换音视频，有非常强大的多媒体处理能力，大家可以前往看文档，结合自己的操作系统来安装，在 Mac 上安装特别简单，首先保证已经安装过 ",(0,s.jsx)(n.a,{href:"https://brew.sh/",target:"_blank",rel:"noopener noreferrer",children:"homebrew"}),"，可能安装需要梯子，安装后，直接执行："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"brew install ffmpeg\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后代码实现上，我们通过 ffmpeg 的流来把一个远端的 MP4 文件中的音频流存储为 mp3，或者干脆下载这个 mp4，源文件我们就使用一个豆瓣预告片视频好了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs')\n//const https = require('https')\nconst http = require('http')\nconst request = require('request')\nconst child_process = require('child_process')\nconst EventEmitter = require('events').EventEmitter\n\nconst spawn = child_process.spawn\nconst mp3Args = ['-i', 'pipe:0', '-f', 'mp3', '-ac', '2', '-ab', '128k', '-acodec', 'libmp3lame', 'pipe:1']\nconst mp4Args = ['-i', 'pipe:0', '-c', 'copy', '-bsf:a', 'aac_adtstoasc', 'pipe:1']\n\nclass VideoTool extends EventEmitter {\n  constructor (url, filename) {\n    super()\n    this.url = url\n    this.filename = filename\n  }\n\n  mp3 () {\n    // 创建 FFMPEG 进程\n    this.ffmpeg = spawn('ffmpeg', mp3Args)\n    \n    // 拿到 Stream 流\n    http.get(this.url, (res) => {\n      res.pipe(this.ffmpeg.stdin)\n    })\n    \n    // 把拿到的流 pipe 到文件中\n    this.ffmpeg.stdout.pipe(fs.createWriteStream(this.filename))\n    \n    this.ffmpeg.on('exit', () => {\n      console.log('Finished:', this.filename)\n    })\n  }\n\n  mp4 () {\n    let stream = fs.createWriteStream(this.filename)\n    request\n      .get(this.url, {\n        headers: {\n          'Content-Type': 'video/mpeg4',\n          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'\n        }\n      })\n      .pipe(stream)\n      .on('open', () => {\n        console.log('start download')\n      })\n      .on('close', () => {\n        console.log('download finished')\n      })\n  }\n}\n\nconst video = 'http://vt1.doubanio.com/201810291353/4d7bcf6af730df6d9b4da321aa6d7faa/view/movie/M/402380210.mp4'\nconst m1 = new VideoTool(video, 'audio.mp3')\nconst m2 = new VideoTool(video, __dirname + '/video.mp4')\n\nm1.mp3()\nm2.mp4()\n"})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F8%E6%A1%88%E4%BE%8B%E4%B8%83%EF%BC%9A%5B%E8%A7%86%E9%A2%91%E6%B5%81%E8%BD%AC%20MP3%20%E5%B7%A5%E5%85%B7%5D%20-%20Node%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E7%AE%A1%E9%81%93%20-%20Stream%E3%80%81pipe.md"]={toc:[{text:"",id:"",depth:3},{text:"Stream 流",id:"stream-流",depth:3},{text:"四大流王",id:"四大流王",depth:3},{text:"流与事件",id:"流与事件",depth:3},{text:"流速控制",id:"流速控制",depth:3},{text:"流的数据管道 - pipe",id:"流的数据管道---pipe",depth:3},{text:"定制流",id:"定制流",depth:3},{text:"编程练习 - 实现一个 MP4 转 MP3 工具",id:"编程练习---实现一个-mp4-转-mp3-工具",depth:3}],title:"8案例七：[视频流转 MP3 工具] - Node 数据流和管道 - Stream、pipe",headingTitle:"8案例七：[视频流转 MP3 工具] - Node 数据流和管道 - Stream、pipe",frontmatter:{}}}}]);