"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80256"],{50283:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var r=s(552676),c=s(740453);let o=s.p+"static/image/8555343a3bdc6b970c4b967eef97a143.001dd837.webp",t=s.p+"static/image/75ef0738594213952337d0d722402e7e.8ec2e1c4.webp",l=s.p+"static/image/6e8b487e18e41709abdc5cbb8a704bbf.62bc672a.webp",d=s.p+"static/image/2504468dbf07a67490fa31fc3d69deba.7f946dac.webp",i=s.p+"static/image/cb97e44054b49e0d77c84cbf40622843.9c95d921.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",ol:"ol",li:"li",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",strong:"strong",tbody:"tbody",td:"td",h3:"h3",pre:"pre",h4:"h4",img:"img",ul:"ul"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"19-sveltekit--hooks",children:["19-SvelteKit ❘ hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19-sveltekit--hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"推荐学习指数：⭐️️，了解即可"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Hooks 是应用级别的函数，可以响应特定事件，从而对框架行为进行更精确的控制。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注：Hooks 在不同框架下有不同的含义。在 SvelteKit 下，hooks 的作用类似于中间件。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"有 3 个 hooks 文件，皆是可选（可以有这个文件，也可以没有这个文件）："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/hooks.server.js"}),"：Server hooks，用于监听服务端事件"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/hooks.client.js"}),"：Client hooks，用于监听客户端事件"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"src/hooks.js"}),"：Universal hooks，在服务端和客户端运行的 hooks"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"每个 hooks 文件可以定义的 hook 如下："}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"hooks.server.js"})}),"\n",(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"hooks.client.js"})}),"\n",(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"hooks.js"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsxs)(n.td,{children:["1. ",(0,r.jsx)(n.code,{children:"handle"}),"2. ",(0,r.jsx)(n.code,{children:"handleFetch"}),"3. ",(0,r.jsx)(n.code,{children:"handleError"})]}),"\n",(0,r.jsxs)(n.td,{children:["1. ",(0,r.jsx)(n.code,{children:"handleError"})]}),"\n",(0,r.jsxs)(n.td,{children:["1. ",(0,r.jsx)(n.code,{children:"reroute"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"通过定义 hook 函数，可以全局控制应用的服务端请求、数据获取、错误处理等。这些模块的代码会在应用程序启动的时候运行，因此也可用于初始化数据库客户端等。"}),"\n",(0,r.jsx)(n.p,{children:"接下来我们开始详细介绍这些 hooks。"}),"\n",(0,r.jsxs)(n.h2,{id:"2-server-hooks",children:["2. Server hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-server-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"src/hooks.server.js"}),"可以添加这两个 hook："]}),"\n",(0,r.jsxs)(n.h3,{id:"21-handle",children:["2.1. handle",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-handle",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"每当 SveteKit 服务端收到请求（无论请求是在运行时还是预渲染过程中），该函数就会运行并决定响应。"}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/hooks.server.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function handle({ event, resolve }) {\n  return resolve(event);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时不会有任何行为，因为这就是默认行为。让我们具体看下 handle 函数。"}),"\n",(0,r.jsxs)(n.h4,{id:"211-基础使用",children:["2.1.1. 基础使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#211-基础使用",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["handle 函数接收一个",(0,r.jsx)(n.code,{children:"input"})," 对象，该对象有 2 个属性 —— ",(0,r.jsx)(n.code,{children:"event"})," 和 ",(0,r.jsx)(n.code,{children:"resolve"}),"。 其中 ",(0,r.jsx)(n.code,{children:"event"})," 是",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-requestevent",title:"https://kit.svelte.dev/docs/types#public-types-requestevent",target:"_blank",rel:"noopener noreferrer",children:"RequestEvent"})," 类型，存储着本次请求的相关信息。",(0,r.jsx)(n.code,{children:"resolve"})," 是函数，该函数会渲染路由并创建 Response。"]}),"\n",(0,r.jsx)(n.p,{children:"我们看个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.server.js\nexport async function handle({ event, resolve }) {\n  if (event.url.pathname.startsWith("/custom")) {\n    return new Response("custom response");\n  }\n\n  const response = await resolve(event);\n  return response;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时访问 ",(0,r.jsx)(n.code,{children:"/custom"}),"开头的路由（哪怕没有定义），都会返回："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.h4,{id:"212-自定义数据",children:["2.1.2. 自定义数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#212-自定义数据",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"handle"})," 返回的数据会传递给 ",(0,r.jsx)(n.code,{children:"+server.js"}),"和 server load 函数（",(0,r.jsx)(n.code,{children:"+[page|layout].server.js"}),"），如果要添加自定义数据，可以填充到 ",(0,r.jsx)(n.code,{children:"event.locals"})," 对象（这个对象就是专门用来自定义数据的）："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.server.js\nexport async function handle({ event, resolve }) {\n  // event.locals.user = await getUserInformation(event.cookies.get(\'sessionid\'));\n  event.locals.user = "YaYu";\n\n  const response = await resolve(event);\n  response.headers.set("x-custom-header", "potato");\n\n  return response;\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面这段代码是一个身份验证的简单例子，通过 cookies 中的 sessionid 获取用户信息，然后将数据放到 ",(0,r.jsx)(n.code,{children:"event.locals"})," 中，server load 函数可以获取到该自定义信息。"]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/routes/+layout.server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load({ locals }) {\n  return { user: locals.user };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时页面 ",(0,r.jsx)(n.code,{children:"+page.svelte"}),"就可以通过 ",(0,r.jsx)(n.code,{children:"data"}),"或者 ",(0,r.jsx)(n.code,{children:"$page.data"}),"获取："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  let { data } = $props();\n  import { page } from '$app/stores';\n<\/script>\n\n{#if data.user}\n  Welcome {data.user}!\n{/if}\n\n{#if $page.data.user}\n  Welcome {$page.data.user}!\n{/if}\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["注意：",(0,r.jsx)(n.code,{children:"handle"})," 会在 action 调用之前运行，并且不会在 load 函数之前重新运行。所以如果使用 handle 基于 cookie 修改了 event.locals，记得在设置或删除 cookie 的 action 中更新 event.locals："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.server.js\nexport async function handle({ event, resolve }) {\n  event.locals.user = await getUser(event.cookies.get("sessionid"));\n  return resolve(event);\n}\n\n// src/routes/account/+page.server.js\nexport function load(event) {\n  return {\n    user: event.locals.user,\n  };\n}\n\nexport const actions = {\n  logout: async (event) => {\n    event.cookies.delete("sessionid", { path: "/" });\n    event.locals.user = null;\n  },\n};\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"213-resolve-函数",children:["2.1.3. resolve 函数",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#213-resolve-函数",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"resolve"})," 还支持第二个可选参数，可以对响应的渲染方式进行更多控制，该参数是一个对象："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transformPageChunk"}),"：其语法如下："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"transformPageChunk(opts: { html: string, done: boolean }): MaybePromise<string | undefined>\n"})}),"\n",(0,r.jsx)(n.p,{children:"用于自定义 HTML 转换。如果 done 为 true，表示是最终的块，之所以分成 chunk，是考虑到流式渲染。"}),"\n",(0,r.jsxs)(n.p,{children:["我们举个例子，修改 ",(0,r.jsx)(n.code,{children:"src/app.html"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="%lang%">\n  // ...\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们给 HTML 添加了 lang 属性，希望将 ",(0,r.jsx)(n.code,{children:"%lang%"}),"替换为 cookies 中设置的 locale 值："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/hooks.server.js\nexport async function handle({ event, resolve }) {\n  let page = '';\n  // 从 event.cookies 中获取 locale，假设为 zh\n  const locale = 'zh'\n\n  return resolve(event, {\n    transformPageChunk: ({ html, done }) => {\n      page += html;\n      if (done) {\n        return html.replace('%lang%', locale)\n      }\n    }\n  });\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"filterSerializedResponseHeaders"}),"：其语法如下："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"filterSerializedResponseHeaders(name: string, value: string): boolean\n"})}),"\n",(0,r.jsxs)(n.p,{children:["用于决定当 ",(0,r.jsx)(n.code,{children:"load"})," 函数使用 ",(0,r.jsx)(n.code,{children:"fetch"})," 加载资源时，序列化响应中应包含哪些标头。默认不包含任何标头信息。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"export async function handle({ event, resolve }) {\n  const response = await resolve(event, {\n    filterSerializedResponseHeaders: (name) => name.startsWith('x-'),\n  });\n\n  return response;\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"preload"}),"：其语法如下："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"preload(input: { type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean\n"})}),"\n",(0,r.jsxs)(n.p,{children:["用于确定将哪些文件添加到 ",(0,r.jsx)(n.code,{children:"<head>"}),"标签中以进行预加载。在构建代码块时，该方法会与构建时发现的文件一起运行。比如 ",(0,r.jsx)(n.code,{children:"+page.svelte"}),"中 ",(0,r.jsx)(n.code,{children:"import './styles.css'"}),"，那么在访问该页面时，preload 将与该 css 文件的解析地址一起调用。"]}),"\n",(0,r.jsx)(n.p,{children:"注意开发模式下不会调用 preload，它取决于构建时进行的分析。默认情况下，js 和 css 文件会被预加载。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export async function handle({ event, resolve }) {\n  const response = await resolve(event, {\n    preload: ({ type, path }) => type === "js" || path.includes("/important/"),\n  });\n\n  return response;\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"214-定义多个函数",children:["2.1.4. 定义多个函数",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#214-定义多个函数",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["实际项目开发中，handle 的处理可能会很复杂，有的处理国际化，有的处理身份验证，当代码混淆在一起的时候，很快就会积重难返，此时可以定义多个 handle 函数将逻辑分离，然后借助 ",(0,r.jsx)(n.code,{children:"sequence"}),"工具函数帮助执行。"]}),"\n",(0,r.jsx)(n.p,{children:"一个简单的例子如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { sequence } from "@sveltejs/kit/hooks";\n\nasync function first({ event, resolve }) {\n  console.log("first pre-processing");\n  event.locals.user = "YaYu";\n  const response = await resolve(event);\n  console.log("first post-processing");\n  return response;\n}\n\nasync function second({ event, resolve }) {\n  console.log("second pre-processing");\n  const response = await resolve(event);\n  response.headers.set("x-custom-header", "potato");\n  console.log("second post-processing");\n  return response;\n}\n\nexport const handle = sequence(first, second);\n'})}),"\n",(0,r.jsx)(n.p,{children:"打印顺序如中间件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"handle"})," 选项的行为如下："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"transformPageChunk"})," 以相反的顺序合并应用"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"preload"})," 按正向顺序应用，只会使用第一个选项（意思是只能设置一次）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"filterSerializedResponseHeaders"})," 同 ",(0,r.jsx)(n.code,{children:"preload"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"让我们再看个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { sequence } from "@sveltejs/kit/hooks";\n\n/// type: import(\'@sveltejs/kit\').Handle\nasync function first({ event, resolve }) {\n  console.log("first pre-processing");\n  const result = await resolve(event, {\n    transformPageChunk: ({ html }) => {\n      // transforms are applied in reverse order\n      console.log("first transform");\n      return html;\n    },\n    preload: () => {\n      // this one wins as it\'s the first defined in the chain\n      console.log("first preload");\n    },\n  });\n  console.log("first post-processing");\n  return result;\n}\n\n/// type: import(\'@sveltejs/kit\').Handle\nasync function second({ event, resolve }) {\n  console.log("second pre-processing");\n  const result = await resolve(event, {\n    transformPageChunk: ({ html }) => {\n      console.log("second transform");\n      return html;\n    },\n    preload: () => {\n      console.log("second preload");\n    },\n    filterSerializedResponseHeaders: () => {\n      // this one wins as it\'s the first defined in the chain\n      console.log("second filterSerializedResponseHeaders");\n    },\n  });\n  console.log("second post-processing");\n  return result;\n}\n\nexport const handle = sequence(first, second);\n'})}),"\n",(0,r.jsx)(n.p,{children:"打印顺序是："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"first pre-processing\nfirst preload\nsecond pre-processing\nsecond filterSerializedResponseHeaders\nsecond transform\nfirst transform\nsecond post-processing\nfirst post-processing\n"})}),"\n",(0,r.jsx)(n.p,{children:"按照上面的规则很容易就推得此结果。"}),"\n",(0,r.jsxs)(n.h3,{id:"22-handlefetch",children:["2.2. handleFetch",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-handlefetch",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过该函数，可以修改（或替换）服务端（或预渲染）",(0,r.jsx)(n.code,{children:"load"})," 或 ",(0,r.jsx)(n.code,{children:"action"})," 函数内部发起的 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求。默认行为类似于："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/hooks.server.js\nexport async function handleFetch({ event, request, fetch }) {\n  return await fetch(request);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["比如我们将请求统一改为 ",(0,r.jsx)(n.code,{children:"https"})," 请求："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.server.js\nexport async function handleFetch({ request, fetch }) {\n  if (request.url.startsWith("http")) {\n    const url = request.url.replace("http", "https");\n    request = new Request(url, request);\n  }\n\n  return fetch(request);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"比如当用户导航至自己应用的页面，与其使用公共互联网访问，不如直接访问本机 API："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export async function handleFetch({ request, fetch }) {\n  if (request.url.startsWith("https://api.yourapp.com/")) {\n    // 克隆原生请求，但是修改地址\n    request = new Request(\n      request.url.replace("https://api.yourapp.com/", "http://localhost:9999/"),\n      request\n    );\n  }\n\n  return fetch(request);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["注意上面这段代码，需要请求运行在服务端的时候，比如 ",(0,r.jsx)(n.code,{children:"+page.server.js"})]}),"\n",(0,r.jsxs)(n.h4,{id:"221-credentials",children:["2.2.1. Credentials",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#221-credentials",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于同源请求，SvelteKit 的 ",(0,r.jsx)(n.code,{children:"fetch"})," 将转发 ",(0,r.jsx)(n.code,{children:"cookie"})," 和 ",(0,r.jsx)(n.code,{children:"authorization"})," 标头，除非 ",(0,r.jsx)(n.code,{children:"credentials"})," 选项设置为 ",(0,r.jsx)(n.code,{children:'"omit"'}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["对于跨源请求，如果请求 URL 属于应用程序的子域，则会包含 cookie，比如应用是 ",(0,r.jsx)(n.code,{children:"my-domain.com"})," 上，而 API 位于 ",(0,r.jsx)(n.code,{children:"api.my-domain.com"})," 上，则会在请求中包含 cookie。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果应用程序和 API 位于同级子域上（例如 ",(0,r.jsx)(n.code,{children:"www.my-domain.com"})," 和 ",(0,r.jsx)(n.code,{children:"api.my-domain.com"}),"），那么属于共同父域（例如 ",(0,r.jsx)(n.code,{children:"my-domain.com"})," ）的 cookie 将不会被包含在内，因为 SvelteKit 无法知道 cookie 属于哪个域。在这种情况下，需要使用 handleFetch 手动包含 cookie："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export async function handleFetch({ event, request, fetch }) {\n  if (request.url.startsWith("https://api.my-domain.com/")) {\n    request.headers.set("cookie", event.request.headers.get("cookie"));\n  }\n\n  return fetch(request);\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"3-server-hooks-和-client-hooks",children:["3. Server hooks 和 Client hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-server-hooks-和-client-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["可在 ",(0,r.jsx)(n.code,{children:"src/hooks.server.js"})," 和 ",(0,r.jsx)(n.code,{children:"src/hooks.client.js"})," 中添加以下内容："]}),"\n",(0,r.jsxs)(n.h3,{id:"31-handleerror",children:["3.1. handleError",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-handleerror",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果在加载或渲染过程中出现意外错误，将调用该函数，并传递 ",(0,r.jsx)(n.code,{children:"error"}),"、",(0,r.jsx)(n.code,{children:"event"}),"、",(0,r.jsx)(n.code,{children:"status"}),"状态码和 ",(0,r.jsx)(n.code,{children:"message"}),"。开发者可以："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"记录错误日志"}),"\n",(0,r.jsx)(n.li,{children:"生成一个可安全显示的自定义错误，省略堆栈等敏感信息"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["其中，",(0,r.jsx)(n.code,{children:"error"}),"是错误信息，",(0,r.jsx)(n.code,{children:"event"}),"是请求信息。如果是开发者代码引发的错误，一般状态码 ",(0,r.jsx)(n.code,{children:"status"}),"为 500，消息 ",(0,r.jsx)(n.code,{children:"message"})," 为 ",(0,r.jsx)(n.code,{children:'"Internal Error"'})," 。这个错误信息初学的时候经常遇到："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"handleError 可以搭配错误监控系统如 Sentry 一起工作："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.server.js\nimport * as Sentry from "@sentry/sveltekit";\n\nSentry.init({\n  /*...*/\n});\n\nexport async function handleError({ error, event, status, message }) {\n  const errorId = crypto.randomUUID();\n\n  // example integration with https://sentry.io/\n  Sentry.captureException(error, {\n    extra: { event, errorId, status },\n  });\n\n  return {\n    message: "Whoops!",\n    errorId,\n  };\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.client.js\nimport * as Sentry from "@sentry/sveltekit";\n\nSentry.init({\n  /*...*/\n});\n\nexport async function handleError({ error, event, status, message }) {\n  const errorId = crypto.randomUUID();\n\n  // example integration with https://sentry.io/\n  Sentry.captureException(error, {\n    extra: { event, errorId, status },\n  });\n\n  return {\n    message: "Whoops!",\n    errorId,\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["注意：预期之内的错误并不会调用该函数，比如使用 ",(0,r.jsx)(n.code,{children:"@sveltejs/kit"}),"的 ",(0,r.jsx)(n.code,{children:"error"}),"函数引发的错误。"]}),"\n",(0,r.jsxs)(n.h2,{id:"4-universal-hooks",children:["4. Universal hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-universal-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["以下内容添加到 ",(0,r.jsx)(n.code,{children:"src/hooks.js"}),"中，通用 hooks 会在服务端和客户端上运行："]}),"\n",(0,r.jsxs)(n.h3,{id:"41-reroute",children:["4.1. reroute",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-reroute",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["此函数会在 ",(0,r.jsx)(n.code,{children:"handle"}),"之前运行，用于定义 URL 如何转换为路由，功能类似于 Next.js 的 rewrite。比如将 ",(0,r.jsx)(n.code,{children:"/about"}),"通过 ",(0,r.jsx)(n.code,{children:"reroute"})," 重写为 ",(0,r.jsx)(n.code,{children:"/company"}),"后，将使用 ",(0,r.jsx)(n.code,{children:"/company"}),"对应的路由文件进行处理。"]}),"\n",(0,r.jsxs)(n.p,{children:["该函数返回路径名（默认是 ",(0,r.jsx)(n.code,{children:"url.pathname"}),"），用于选择路由及其参数。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如有一个 ",(0,r.jsx)(n.code,{children:"src/routes/[[lang]]/about/+page.svelte"}),"页面，你希望 ",(0,r.jsx)(n.code,{children:"/en/about"}),"、",(0,r.jsx)(n.code,{children:"/de/ueber-uns"})," 、",(0,r.jsx)(n.code,{children:"/fr/a-propos"}),"都指向该页面，那就可以使用 ",(0,r.jsx)(n.code,{children:"reroute"})," 来实现："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/hooks.js\n\nconst translated = {\n  "/en/about": "/en/about",\n  "/de/ueber-uns": "/de/about",\n  "/fr/a-propos": "/fr/about",\n};\n\nexport function reroute({ url }) {\n  if (url.pathname in translated) {\n    return translated[url.pathname];\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"注意："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"lang"}),"参数将从返回的路径名中派生"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"reroute"})," 不会更改浏览器地址栏中的内容（跟重定向不同）或 ",(0,r.jsx)(n.code,{children:"event.url"})," 的值"]}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let j=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F19-SvelteKit%20%E2%9D%98%20hooks.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Server hooks",id:"2-server-hooks",depth:2},{text:"2.1. handle",id:"21-handle",depth:3},{text:"2.1.1. 基础使用",id:"211-基础使用",depth:4},{text:"2.1.2. 自定义数据",id:"212-自定义数据",depth:4},{text:"2.1.3. resolve 函数",id:"213-resolve-函数",depth:4},{text:"2.1.4. 定义多个函数",id:"214-定义多个函数",depth:4},{text:"2.2. handleFetch",id:"22-handlefetch",depth:3},{text:"2.2.1. Credentials",id:"221-credentials",depth:4},{text:"3. Server hooks 和 Client hooks",id:"3-server-hooks-和-client-hooks",depth:2},{text:"3.1. handleError",id:"31-handleerror",depth:3},{text:"4. Universal hooks",id:"4-universal-hooks",depth:2},{text:"4.1. reroute",id:"41-reroute",depth:3}],title:"19-SvelteKit ❘ hooks",headingTitle:"19-SvelteKit ❘ hooks",frontmatter:{}}}}]);