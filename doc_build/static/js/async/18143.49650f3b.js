"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18143"],{664448:function(e,n,d){e.exports=d.p+"static/image/4101095859f9692c2064f220c9f49a49.740b6f55.webp"},492208:function(e,n,d){d.r(n),d.d(n,{default:()=>b});var r=d(552676),c=d(740453);let t=d.p+"static/image/e8d76bd8401149d71dd9c8dcf897f5ad.129cd9f4.webp",i=d.p+"static/image/991d46e8ad780bac3106e82b132c5fa2.b1678fc0.webp",s=d.p+"static/image/d417a15bb0b6f0f4486b8a624d7f11ae.34c69ddd.webp",a=d.p+"static/image/068c6a63e3df2902e91d295f4fdbcece.fbb931ea.webp",l=d.p+"static/image/bfacb0f40733e156fa6f9c7132022e79.740b6f55.webp";var o=d(664448);let h=d.p+"static/image/84b021ddebe4af315d64e3e434fa3d59.94355784.webp",x=d.p+"static/image/9eb239edeae40916fd1ddbbe53134f6d.8bd93492.webp",p=d.p+"static/image/05f0feb24da9fef10dd66b6417800f0b.47749864.webp",j=d.p+"static/image/08c026e12da44fb988dd657a9db74cce.153a01e2.webp",m=d.p+"static/image/8cfd3b9766006911fe01b7880e0566f6.30e97683.webp",u=d.p+"static/image/adaac4716cffbb15ebd3c0831176ae65.12dbb0f2.webp";function f(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",img:"img",pre:"pre",h3:"h3",ul:"ul",li:"li",h4:"h4"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"13hmr-api-及原理代码改动后如何进行毫秒级别的局部更新",children:["13.HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13hmr-api-及原理代码改动后如何进行毫秒级别的局部更新",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在开始今天的课程之前，我想先问你一个日常开发中的问题：在代码变更之后，如何实时看到更新后的页面效果呢？"}),"\n",(0,r.jsxs)(n.p,{children:["很久之前，我们是通过 live reload 也就是自动刷新页面的方式来解决的。不过随着前端工程的日益庞大，开发场景也越来越复杂，这种",(0,r.jsx)(n.code,{children:"live reload"}),"的方式在诸多的场景下却显得十分鸡肋，简单来说就是",(0,r.jsx)(n.code,{children:"模块局部更新"}),"+",(0,r.jsx)(n.code,{children:"状态保存"}),"的需求在",(0,r.jsx)(n.code,{children:"live reload"}),"的方案没有得到满足，从而导致开发体验欠佳。当然，针对部分场景也有一些临时的解决方案，比如状态存储到浏览器的本地缓存(localStorage 对象)中，或者直接 mock 一些数据。但这些方式未免过于粗糙，无法满足通用的开发场景，且实现上也不够优雅。"]}),"\n",(0,r.jsx)(n.p,{children:"那么，如果在改动代码后，想要进行模块级别的局部更新该怎么做呢？业界一般使用 HMR 技术来解决这个问题，像 Webpack、Parcel 这些传统的打包工具底层都实现了一套 HMR API，而我们今天要讲的就是 Vite 自己所实现的 HMR API。相比于传统的打包工具，Vite 的 HMR API 基于 ESM 模块规范来实现，可以达到毫秒级别的更新速度，性能非常强悍。"}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们就一起来谈谈，Vite 中这一套 HMR 相关的 API 是如何设计的，以及我们可以通过这些 API 实现哪些功能。"}),"\n",(0,r.jsxs)(n.h2,{id:"hmr-简介",children:["HMR 简介",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hmr-简介",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["HMR 的全称叫做",(0,r.jsx)(n.code,{children:"Hot Module Replacement"}),"，即",(0,r.jsx)(n.code,{children:"模块热替换"}),"或者",(0,r.jsx)(n.code,{children:"模块热更新"}),"。在计算机领域当中也有一个类似的概念叫",(0,r.jsx)(n.code,{children:"热插拔"}),"，我们经常使用的 USB 设备就是一个典型的代表，当我们插入 U 盘的时候，系统驱动会加载在新增的 U 盘内容，不会重启系统，也不会修改系统其它模块的内容。HMR 的作用其实一样，就是在页面模块更新的时候，直接把",(0,r.jsx)(n.strong,{children:"页面中发生变化的模块替换为新的模块"}),"，同时不会影响其它模块的正常运作。具体来说，你可以观察下面这个实现 HMR 的例子。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["在这里，我改变了页面的一个状态",(0,r.jsx)(n.code,{children:"count"}),"，当我对页面再次进行调整的时候，比如把最上面的 Logo 图片去掉，这个时候大家可以实时地看到图片消失了，但其他的部分并没有发生改变，包括组件此时的一些数据。"]}),"\n",(0,r.jsxs)(n.p,{children:["如此一来，通过 HMR 的技术我们就可以实现",(0,r.jsx)(n.code,{children:"局部刷新"}),"和",(0,r.jsx)(n.code,{children:"状态保存"}),"，从而解决之前提到的种种问题。"]}),"\n",(0,r.jsxs)(n.h2,{id:"深入-hmr-api",children:["深入 HMR API",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深入-hmr-api",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Vite 作为一个完整的构建工具，本身实现了一套 HMR 系统，值得注意的是，这套 HMR 系统基于原生的 ESM 模块规范来实现，在文件发生改变时 Vite 会侦测到相应 ES 模块的变化，从而触发相应的 API，实现局部的更新。"}),"\n",(0,r.jsxs)(n.p,{children:["Vite 的 HMR API 设计也并非空穴来风，它基于一套完整的 ",(0,r.jsx)(n.a,{href:"https://github.com/withastro/esm-hmr",target:"_blank",rel:"noopener noreferrer",children:"ESM HMR 规范"}),"来实现，这个规范由同时期的 no-bundle 构建工具 Snowpack、WMR 与 Vite 一起制定，是一个比较通用的规范。"]}),"\n",(0,r.jsx)(n.p,{children:"我们可以直观地来看一看 HMR API 的类型定义:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface ImportMeta {\n  readonly hot?: {\n    readonly data: any\n    accept(): void\n    accept(cb: (mod: any) => void): void\n    accept(dep: string, cb: (mod: any) => void): void\n    accept(deps: string[], cb: (mods: any[]) => void): void\n    prune(cb: () => void): void\n    dispose(cb: (data: any) => void): void\n    decline(): void\n    invalidate(): void\n    on(event: string, cb: (...args: any[]) => void): void\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里稍微解释一下，",(0,r.jsx)(n.code,{children:"import.meta"}),"对象为现代浏览器原生的一个内置对象，Vite 所做的事情就是在这个对象上的 ",(0,r.jsx)(n.code,{children:"hot"})," 属性中定义了一套完整的属性和方法。因此，在 Vite 当中，你就可以通过",(0,r.jsx)(n.code,{children:"import.meta.hot"}),"来访问关于 HMR 的这些属性和方法，比如",(0,r.jsx)(n.code,{children:"import.meta.hot.accept()"}),"。接下来，我们就来一一熟悉这些 API 的使用方式。"]}),"\n",(0,r.jsxs)(n.h3,{id:"模块更新时逻辑-hotaccept",children:["模块更新时逻辑: hot.accept",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块更新时逻辑-hotaccept",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"import.meta.hot"})," 对象上有一个非常关键的方法",(0,r.jsx)(n.code,{children:"accept"}),"，因为它决定了 Vite 进行热更新的边界，那么如何来理解这个",(0,r.jsx)(n.code,{children:"accept"}),"的含义呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["从字面上来看，它表示接受的意思。没错，它就是用来",(0,r.jsx)(n.strong,{children:"接受模块更新"}),"的。 一旦 Vite 接受了这个更新，当前模块就会被认为是 HMR 的边界。那么，Vite 接受谁的更新呢？这里会有三种情况："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["接受",(0,r.jsx)(n.strong,{children:"自身模块"}),"的更新"]}),"\n",(0,r.jsxs)(n.li,{children:["接受",(0,r.jsx)(n.strong,{children:"某个子模块"}),"的更新"]}),"\n",(0,r.jsxs)(n.li,{children:["接受",(0,r.jsx)(n.strong,{children:"多个子模块"}),"的更新"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这三种情况分别对应 accept 方法三种不同的使用方式，下面我们就一起来分析一下。"}),"\n",(0,r.jsxs)(n.h4,{id:"1-接受自身更新",children:[(0,r.jsx)(n.strong,{children:"1. 接受自身更新"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-接受自身更新",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当模块接受自身的更新时，则当前模块会被认为 HMR 的边界。也就是说，除了当前模块，其他的模块均未受到任何影响。下面是我准备的一张示例图，你可以参考一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["为了加深你的理解，这里我们以一个实际的例子来操练一下。这个例子已经放到了 ",(0,r.jsx)(n.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/13-hmr-api",target:"_blank",rel:"noopener noreferrer",children:"Github 仓库"})," 中，你可以把这个链接克隆到本地，然后跟着我一步步添加内容。首先展示一下整体的目录结构:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:".\n├── favicon.svg\n├── index.html\n├── node_modules\n│   └── ...\n├── package.json\n├── src\n│   ├── main.ts\n│   ├── render.ts\n│   ├── state.ts\n│   ├── style.css\n│   └── vite-env.d.ts\n└── tsconfig.json\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里我放出一些关键文件的内容，如下面的 ",(0,r.jsx)(n.code,{children:"index.html"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="favicon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <p>\n      count: <span id="count">0</span>\n    </p>\n    <script type="module" src="/src/main.ts"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["里面的 DOM 结构比较简单，同时引入了 ",(0,r.jsx)(n.code,{children:"/src/main.ts"})," 这个文件，内容如下:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { render } from './render';\nimport { initState } from './state';\nrender();\ninitState();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["文件依赖了",(0,r.jsx)(n.code,{children:"render.ts"}),"和",(0,r.jsx)(n.code,{children:"state.ts"}),"，前者负责渲染文本内容，而后者负责记录当前的页面状态:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// src/render.ts\n// 负责渲染文本内容\nimport './style.css'\nexport const render = () => {\n  const app = document.querySelector<HTMLDivElement>('#app')!\n  app.innerHTML = `\n    <h1>Hello Vite!</h1>\n    <p target=\"_blank\">This is hmr test.123</p>\n  `\n}\n// src/state.ts\n// 负责记录当前的页面状态\nexport function initState() {\n  let count = 0;\n  setInterval(() => {\n    let countEle = document.getElementById('count');\n    countEle!.innerText =  ++count + '';\n  }, 1000);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["好了，仓库当中关键的代码就目前这些了。现在，你可以执行",(0,r.jsx)(n.code,{children:"pnpm i"}),"安装依赖，然后",(0,r.jsx)(n.code,{children:"npm run dev"}),"启动项目，在浏览器访问可以看到这样的内容:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["同时，每隔一秒钟，你可以看到这里的",(0,r.jsx)(n.code,{children:"count"}),"值会加一。OK，现在你可以试着改动一下 ",(0,r.jsx)(n.code,{children:"render.ts"})," 的渲染内容，比如增加一些文本:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"// render.ts\nexport const render = () => {\n  const app = document.querySelector<HTMLDivElement>('#app')!\n  app.innerHTML = `\n    <h1>Hello Vite!</h1>\n+   <p target=\"_blank\">This is hmr test.123 这是增加的文本</p>\n  `\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果如下所示:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["页面的渲染内容是更新了，但不知道你有没有注意到最下面的",(0,r.jsx)(n.code,{children:"count"}),"值瞬间被置零了，并且查看控制台，也有这样的 log："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[vite] page reload src/render.ts\n"})}),"\n",(0,r.jsxs)(n.p,{children:["很明显，当 ",(0,r.jsx)(n.code,{children:"render.ts"})," 模块发生变更时，Vite 发现并没有 HMR 相关的处理，然后直接刷新页面了。"]}),"\n",(0,r.jsxs)(n.p,{children:["现在让我们在",(0,r.jsx)(n.code,{children:"render.ts"}),"中加上如下的代码:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"// 条件守卫\n+ if (import.meta.hot) {\n+  import.meta.hot.accept((mod) => mod.render())\n+ }\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"import.meta.hot"}),"对象只有在开发阶段才会被注入到全局，生产环境是访问不到的，另外增加条件守卫之后，打包时识别到 if 条件不成立，会自动把这部分代码从打包产物中移除，来优化资源体积。因此，我们需要增加这个条件守卫语句。"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来，可以注意到我们对于 ",(0,r.jsx)(n.code,{children:"import.meta.hot.accept"}),"的使用:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import.meta.hot.accept((mod) => mod.render())\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里我们传入了一个回调函数作为参数，入参即为 Vite 给我们提供的更新后的模块内容，在浏览器中打印",(0,r.jsx)(n.code,{children:"mod"}),"内容如下，正好是",(0,r.jsx)(n.code,{children:"render"}),"模块最新的内容:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们在回调中调用了一下 ",(0,r.jsx)(n.code,{children:"mod.render"})," 方法，也就是当模块变动后，每次都重新渲染一遍内容。这时你可以试着改动一下渲染的内容，然后到浏览器中注意一下",(0,r.jsx)(n.code,{children:"count"}),"的情况，并没有被重新置零，而是保留了原有的状态:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["没错，现在 ",(0,r.jsx)(n.code,{children:"render"})," 模块更新后，只会重新渲染这个模块的内容，而对于 state 模块的内容并没有影响，并且控制台的 log 也发生了变化:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[vite] hmr update /src/render.ts\n"})}),"\n",(0,r.jsxs)(n.p,{children:["现在我们算是实现了初步的 HMR，也在实际的代码中体会到了 accept 方法的用途。当然，在这个例子中我们传入了一个回调函数来手动调用 render 逻辑，但事实上你也可以什么参数都不传，这样 Vite 只会把 ",(0,r.jsx)(n.code,{children:"render"}),"模块的最新内容执行一遍，但 ",(0,r.jsx)(n.code,{children:"render"})," 模块内部只声明了一个函数，因此直接调用",(0,r.jsx)(n.code,{children:"import.meta.hot.accept()"}),"并不会重新渲染页面。"]}),"\n",(0,r.jsxs)(n.h4,{id:"2-接受依赖模块的更新",children:[(0,r.jsx)(n.strong,{children:"2. 接受依赖模块的更新"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-接受依赖模块的更新",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上面介绍了",(0,r.jsx)(n.code,{children:"接受自身模块更新"}),"的情况，现在来分析一下",(0,r.jsx)(n.code,{children:"接受依赖模块更新"}),"是如何做到的。先给大家放一张原理图，直观地感受一下:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["还是拿示例项目来举例，",(0,r.jsx)(n.code,{children:"main"}),"模块依赖",(0,r.jsx)(n.code,{children:"render"})," 模块，也就是说，",(0,r.jsx)(n.code,{children:"main"}),"模块是",(0,r.jsx)(n.code,{children:"render"}),"父模块，那么我们也可以在 ",(0,r.jsx)(n.code,{children:"main"})," 模块中接受",(0,r.jsx)(n.code,{children:"render"}),"模块的更新，此时 HMR 边界就是",(0,r.jsx)(n.code,{children:"main"}),"模块了。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们将 ",(0,r.jsx)(n.code,{children:"render"}),"模块的 accept 相关代码先删除:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"// render.ts\n- if (import.meta.hot) {\n-   import.meta.hot.accept((mod) => mod.render())\n- }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后再",(0,r.jsx)(n.code,{children:"main"}),"模块增加如下代码:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"// main.ts\nimport { render } from './render';\nimport './state';\nrender();\n+if (import.meta.hot) {\n+  import.meta.hot.accept('./render.ts', (newModule) => {\n+    newModule.render();\n+  })\n+}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这里我们同样是调用 accept 方法，与之前不同的是，第一个参数传入一个依赖的路径，也就是",(0,r.jsx)(n.code,{children:"render"}),"模块的路径，这就相当于告诉 Vite: 我监听了 ",(0,r.jsx)(n.code,{children:"render"})," 模块的更新，当它的内容更新的时候，请把最新的内容传给我。同样的，第二个参数中定义了模块变化后的回调函数，这里拿到了 ",(0,r.jsx)(n.code,{children:"render"})," 模块最新的内容，然后执行其中的渲染逻辑，让页面展示最新的内容。"]}),"\n",(0,r.jsxs)(n.p,{children:["通过接受一个依赖模块的更新，我们同样又实现了 HMR 功能，你可以试着改动 ",(0,r.jsx)(n.code,{children:"render"}),"模块的内容，可以发现页面内容正常更新，并且状态依然保持着原样。"]}),"\n",(0,r.jsxs)(n.h4,{id:"3-接受多个子模块的更新",children:[(0,r.jsx)(n.strong,{children:"3. 接受多个子模块的更新"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-接受多个子模块的更新",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来是最后一种 accept 的情况——接受多个子模块的更新。有了上面两种情况的铺垫，这里再来理解第三种情况就容易多了，我依然先给出原理示意图:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这里的意思是",(0,r.jsx)(n.strong,{children:"父模块可以接受多个子模块的更新，当其中任何一个子模块更新之后，父模块会成为 HMR 边界"}),"。还是拿之前的例子来演示，现在我们更改",(0,r.jsx)(n.code,{children:"main"}),"模块代码:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// main.ts\nimport { render } from './render';\nimport { initState } from './state';\nrender();\ninitState();\n+if (import.meta.hot) {\n+  import.meta.hot.accept(['./render.ts', './state.ts'], (modules) => {\n+    console.log(modules);\n+  })\n+}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在代码中我们通过 accept 方法接受了",(0,r.jsx)(n.code,{children:"render"}),"和",(0,r.jsx)(n.code,{children:"state"}),"两个模块的更新，接着让我们手动改动一下某一个模块的代码，观察一下回调中",(0,r.jsx)(n.code,{children:"modules"}),"的打印内容。例如当我改动 ",(0,r.jsx)(n.code,{children:"state"}),"模块的内容时，回调中拿到的 modules 是这样的:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到 Vite 给我们的回调传来的参数",(0,r.jsx)(n.code,{children:"modules"}),"其实是一个数组，和我们第一个参数声明的子模块数组一一对应。因此",(0,r.jsx)(n.code,{children:"modules"}),"数组第一个元素是 ",(0,r.jsx)(n.code,{children:"undefined"}),"，表示",(0,r.jsx)(n.code,{children:"render"}),"模块并没有发生变化，第二个元素为一个 Module 对象，也就是经过变动后",(0,r.jsx)(n.code,{children:"state"}),"模块的最新内容。于是在这里，我们根据 ",(0,r.jsx)(n.code,{children:"modules"})," 进行自定义的更新，修改 ",(0,r.jsx)(n.code,{children:"main.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// main.ts\nimport { render } from './render';\nimport { initState } from './state';\nrender();\ninitState();\nif (import.meta.hot) {\n  import.meta.hot.accept(['./render.ts', './state.ts'], (modules) => {\n    // 自定义更新\n    const [renderModule, stateModule] = modules;\n    if (renderModule) {\n      renderModule.render();\n    }\n    if (stateModule) {\n      stateModule.initState();\n    }\n  })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["现在，你可以改动两个模块的内容，可以发现，页面的相应模块会更新，并且对其它的模块没有影响。但实际上你会发现另外一个问题，当改动了",(0,r.jsx)(n.code,{children:"state"}),"模块的内容之后，页面的内容会变得错乱:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这是为什么呢？"}),"\n",(0,r.jsxs)(n.p,{children:["我们快速回顾一下 ",(0,r.jsx)(n.code,{children:"state"}),"模块的内容:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// state.ts\nexport function initState() {\n  let count = 0;\n  setInterval(() => {\n    let countEle = document.getElementById('count');\n    countEle!.innerText =  ++count + '';\n  }, 1000);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中设置了一个定时器，但当模块更改之后，这个定时器并没有被销毁，紧接着我们在 accept 方法调用 ",(0,r.jsx)(n.code,{children:"initState"})," 方法又创建了一个新的定时器，导致 count 的值错乱。那如何来解决这个问题呢？这就涉及到新的 HMR 方法——",(0,r.jsx)(n.code,{children:"dispose"}),"方法了。"]}),"\n",(0,r.jsxs)(n.h3,{id:"模块销毁时逻辑-hotdispose",children:["模块销毁时逻辑: hot.dispose",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块销毁时逻辑-hotdispose",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这个方法相较而言就好理解多了，代表在模块更新、旧模块需要销毁时需要做的一些事情，拿刚刚的场景来说，我们可以通过在",(0,r.jsx)(n.code,{children:"state"}),"模块中调用 dispose 方法来轻松解决定时器共存的问题，代码改动如下:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// state.ts\nlet timer: number | undefined;\nif (import.meta.hot) {\n  import.meta.hot.dispose(() => {\n    if (timer) {\n      clearInterval(timer);\n    }\n  })\n}\nexport function initState() {\n  let count = 0;\n  timer = setInterval(() => {\n    let countEle = document.getElementById('count');\n    countEle!.innerText =  ++count + '';\n  }, 1000);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时，我们再来到浏览器观察一下 HMR 的效果:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，当我稍稍改动一下",(0,r.jsx)(n.code,{children:"state"}),"模块的内容(比如加个空格)，页面确实会更新，而且也没有状态错乱的问题，说明我们在模块销毁前清除定时器的操作是生效的。但你又可以很明显地看到一个新的问题: 原来的状态丢失了，",(0,r.jsx)(n.code,{children:"count"}),"的内容从",(0,r.jsx)(n.code,{children:"64"}),"突然变成",(0,r.jsx)(n.code,{children:"1"}),"。这又是为什么呢？"]}),"\n",(0,r.jsx)(n.p,{children:"让我们来重新梳理一遍热更新的逻辑:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["当我们改动了",(0,r.jsx)(n.code,{children:"state"}),"模块的代码，",(0,r.jsx)(n.code,{children:"main"}),"模块接受更新，执行 accept 方法中的回调，接着会执行 ",(0,r.jsx)(n.code,{children:"state"})," 模块的",(0,r.jsx)(n.code,{children:"initState"}),"方法。注意了，此时新建的 ",(0,r.jsx)(n.code,{children:"initState"})," 方法的确会初始化定时器，但同时也会初始化 count 变量，也就是",(0,r.jsx)(n.code,{children:"count"}),"从 0 开始计数了！"]}),"\n",(0,r.jsxs)(n.p,{children:["这显然是不符合预期的，我们期望的是每次改动",(0,r.jsx)(n.code,{children:"state"}),"模块，之前的状态都保存下来。怎么来实现呢？"]}),"\n",(0,r.jsxs)(n.h3,{id:"共享数据-hotdata-属性",children:["共享数据: hot.data 属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#共享数据-hotdata-属性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这就不得不提到 hot 对象上的 data 属性了，这个属性用来在不同的模块实例间共享一些数据。使用上也非常简单，让我们来重构一下 ",(0,r.jsx)(n.code,{children:"state"})," 模块:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"let timer: number | undefined;\nif (import.meta.hot) {\n+  // 初始化 count\n+  if (!import.meta.hot.data.count) {\n+    import.meta.hot.data.count = 0;\n+  }\n  import.meta.hot.dispose(() => {\n    if (timer) {\n      clearInterval(timer);\n    }\n  })\n}\nexport function initState() {\n+  const getAndIncCount = () => {\n+    const data = import.meta.hot?.data || {\n+      count: 0\n+    };\n+    data.count = data.count + 1;\n+    return data.count;\n+  };\n  timer = setInterval(() => {\n    let countEle = document.getElementById('count');\n+    countEle!.innerText =  getAndIncCount() + '';\n  }, 1000);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们在 ",(0,r.jsx)(n.code,{children:"import.meta.hot.data"})," 对象上挂载了一个",(0,r.jsx)(n.code,{children:"count"})," 属性，在二次执行",(0,r.jsx)(n.code,{children:"initState"}),"的时候便会复用 ",(0,r.jsx)(n.code,{children:"import.meta.hot.data"})," 上记录的 count 值，从而实现状态的保存。"]}),"\n",(0,r.jsxs)(n.p,{children:["此时，我们终于大功告成，基本实现了这个示例应用的 HMR 的功能。在这个过程中，我们用到了核心的",(0,r.jsx)(n.code,{children:"accept"}),"、",(0,r.jsx)(n.code,{children:"dispose"})," 和",(0,r.jsx)(n.code,{children:"data"}),"属性和方法。当然还有一些方法将会给大家进行介绍，但相较而言就比较简单了，而且用的也不多，大家只需要留下初步的印象，知道这些方法的用途是什么，需要用到的时候再来查阅即可。"]}),"\n",(0,r.jsxs)(n.h3,{id:"其它方法",children:["其它方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其它方法",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. import.meta.hot.decline()"})}),"\n",(0,r.jsx)(n.p,{children:"这个方法调用之后，相当于表示此模块不可热更新，当模块更新时会强制进行页面刷新。感兴趣的同学可以继续拿上面的例子来尝试一下。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. import.meta.hot.invalidate()"})}),"\n",(0,r.jsx)(n.p,{children:"这个方法就更简单了，只是用来强制刷新页面。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. 自定义事件"})}),"\n",(0,r.jsxs)(n.p,{children:["你还可以通过 ",(0,r.jsx)(n.code,{children:"import.meta.hot.on"})," 来监听 HMR 的自定义事件，内部有这么几个事件会自动触发:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vite:beforeUpdate"})," 当模块更新时触发；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vite:beforeFullReload"})," 当即将重新刷新页面时触发；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vite:beforePrune"})," 当不再需要的模块即将被剔除时触发；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vite:error"})," 当发生错误时（例如，语法错误）触发。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["如果你想自定义事件可以通过上节中提到的 ",(0,r.jsx)(n.code,{children:"handleHotUpdate"})," 这个插件 Hook 来进行触发:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 插件 Hook\nhandleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'custom-update',\n    data: {}\n  })\n  return []\n}\n// 前端代码\nimport.meta.hot.on('custom-update', (data) => {\n  // 自定义更新逻辑\n})\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本篇的正文内容到这里就接近尾声了，在这一节中，你需要重点掌握 ",(0,r.jsx)(n.strong,{children:"HMR 的概念"}),"、",(0,r.jsx)(n.strong,{children:"Vite HMR API 的使用"}),"以及",(0,r.jsx)(n.strong,{children:"HMR 的更新原理"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先，我们认识了 HMR 这个概念，了解它相比于传统的 live reload 所解决的问题：",(0,r.jsx)(n.code,{children:"模块局部更新"}),"和",(0,r.jsx)(n.code,{children:"状态保存"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["然后，我带你熟悉了 Vite HMR 中的各种 API，尤其是 accept 方法，根据 accept 的不同用法，我们分了三种情况来讨论 Vite 接受更新的策略: ",(0,r.jsx)(n.code,{children:"接受自身更新"}),"、",(0,r.jsx)(n.code,{children:"接受依赖模块的更新"}),"和",(0,r.jsx)(n.code,{children:"接受多个子模块的更新"}),"，并通过具体的示例演示了这三种情况的代码。可以看到，在代码发生变动的时候，Vite 会定位到发生变化的局部模块，也就是找到对应的 HMR 边界，然后基于这个边界进行更新，其他的模块并没有受到影响，这也是 Vite 中热更新的时间能达到毫秒级别的重要原因。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 Vite 中，HMR 是一套比较复杂的系统，不过一旦理解了本文提到的",(0,r.jsx)(n.code,{children:"HMR 边界"}),"的作用原理，后面解读 Vite HMR 源码的时候将会倍感轻松。大家加油吧！"]})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}let b=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F13.HMR%20API%20%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%94%B9%E5%8A%A8%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%88%AB%E7%9A%84%E5%B1%80%E9%83%A8%E6%9B%B4%E6%96%B0%EF%BC%9F.md"]={toc:[{text:"HMR 简介",id:"hmr-简介",depth:2},{text:"深入 HMR API",id:"深入-hmr-api",depth:2},{text:"模块更新时逻辑: hot.accept",id:"模块更新时逻辑-hotaccept",depth:3},{text:"**1. 接受自身更新**",id:"1-接受自身更新",depth:4},{text:"**2. 接受依赖模块的更新**",id:"2-接受依赖模块的更新",depth:4},{text:"**3. 接受多个子模块的更新**",id:"3-接受多个子模块的更新",depth:4},{text:"模块销毁时逻辑: hot.dispose",id:"模块销毁时逻辑-hotdispose",depth:3},{text:"共享数据: hot.data 属性",id:"共享数据-hotdata-属性",depth:3},{text:"其它方法",id:"其它方法",depth:3},{text:"小结",id:"小结",depth:2}],title:"13.HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？",headingTitle:"13.HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？",frontmatter:{}}}}]);