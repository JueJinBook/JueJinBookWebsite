"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58165"],{378372:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var r=s(552676),t=s(740453);let c=s.p+"static/image/799bd8d9108afddc4147d7d7bd724fba.f62af005.webp",i=s.p+"static/image/cc630d6ac065c2d3958d1d7c87030cfd.e8bb39a1.webp",a=s.p+"static/image/8d946cc4a020efabced1e190739bb480.0e42a4b5.webp",d=s.p+"static/image/1b1d1194ea4a10e9bc257609588cb58f.a4f18b0a.webp",l=s.p+"static/image/8a1709db328edcf16dc1d8ffaae3341f.23cf78f8.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",em:"em",h3:"h3",pre:"pre",img:"img",ol:"ol",li:"li",ul:"ul"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"17-sveltekit--form-actions",children:["17-SvelteKit ❘ Form actions",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17-sveltekit--form-actions",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"推荐学习指数：⭐️⭐⭐️，必学内容️"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+page.server.js"}),"可以导出 ",(0,r.jsx)(n.em,{children:"actions"}),"，所谓 actions，本质是一个异步函数。开发者使用 ",(0,r.jsx)(n.code,{children:"<form>"})," 元素将数据以 POST 请求的方式发送给服务端，服务端使用 actions 进行处理。"]}),"\n",(0,r.jsx)(n.p,{children:"为了展现使用 Form actions 的优势，我们先看下传统的实现方式。"}),"\n",(0,r.jsxs)(n.h3,{id:"11-传统实现方式",children:["1.1. 传统实现方式",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-传统实现方式",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"/src/routes/signin/+page.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  let username = $state(\'\');\n  let password = $state(\'\');\n  let result = $state({});\n\n  async function submit() {\n    const response = await fetch(\'/api/add\', {\n      method: \'POST\',\n      body: JSON.stringify({ username, password }),\n      headers: {\n        \'content-type\': \'application/json\'\n      }\n    });\n\n    result = await response.json();\n  }\n<\/script>\n\n<label class="block text-sm text-gray-900 mb-2">\n  UserName\n  <input\n    type="text"\n    bind:value={username}\n    class="block w-full rounded-md border-0 p-1.5 mt-2 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400"\n  />\n</label>\n\n<label class="block text-sm text-gray-900 mb-2">\n  Password\n  <input\n    type="password"\n    bind:value={password}\n    class="block w-full rounded-md border-0 p-1.5 mt-2 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400"\n  />\n</label>\n\n<button\n  onclick={submit}\n  class="flex w-full justify-center rounded-md bg-indigo-600 px-3 py-1.5 text-sm text-white shadow-sm"\n  >提交</button\n>\n\n{#if result?.success}\n  <p class="text-sm text-gray-900 mt-2">登录成功!</p>\n{/if}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/routes/api/add/+server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { json } from "@sveltejs/kit";\n\nexport async function POST({ request }) {\n  const data = await request.json();\n  return json({\n    success: true,\n    data,\n  });\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["先通过 ",(0,r.jsx)(n.code,{children:"+server.js"}),"声明一个 API 接口，然后点击提交按钮，获取表单数据，调用接口，根据接口响应进行处理。这就是最常见的前后端交互方式。"]}),"\n",(0,r.jsxs)(n.h3,{id:"12-actions-实现方式",children:["1.2. Actions 实现方式",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-actions-实现方式",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在我们使用 Form actions 来实现一遍。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"src/routes/signin/+page.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  import { enhance } from \'$app/forms\';\n  const { form } = $props();\n<\/script>\n\n<form method="POST" use:enhance>\n  <label class="block text-sm text-gray-900 mb-2">\n    UserName\n    <input\n      type="text"\n      name="username"\n      class="block w-full rounded-md border-0 p-1.5 mt-2 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400"\n    />\n  </label>\n\n  <label class="block text-sm text-gray-900 mb-2">\n    Password\n    <input\n      type="password"\n      name="password"\n      class="block w-full rounded-md border-0 p-1.5 mt-2 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400"\n    />\n  </label>\n\n  <button\n    type="submit"\n    class="flex w-full justify-center rounded-md bg-indigo-600 px-3 py-1.5 text-sm text-white shadow-sm"\n    >提交</button\n  >\n</form>\n\n{#if form?.success}\n  <p class="text-sm text-gray-900 mt-2">登录成功!</p>\n{/if}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/routes/signin/+page.server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export const actions = {\n  default: async ({ request }) => {\n    const formData = await request.formData();\n    const data = Object.fromEntries(formData);\n    return {\n      success: true,\n      data,\n    };\n  },\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果与上节一致："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["不需要提前声明一个接口，也不需要 ",(0,r.jsx)(n.code,{children:"await fetch(xxx)"})," 这样的样板代码，只需要在 ",(0,r.jsx)(n.code,{children:"+page.server.js"}),"导出一个异步函数即可。当提交表单的时候，会发送一个 POST 请求到当前页面，由 action 函数进行处理。"]}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:'<form action="xxx">'})," 的一大好处在于即便禁用 JavaScript，表单也是可以正常提交的，效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"注意禁用和不禁用时的差别：禁用 JavaScript 时，表单提交后页面会刷新，不禁用 JavaScript 时，表单提交后页面并无刷新行为。"}),"\n",(0,r.jsx)(n.p,{children:"现在让我们来看下 action 的具体用法和注意事项。"}),"\n",(0,r.jsxs)(n.h2,{id:"2-默认-action",children:["2. 默认 action",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-默认-action",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用 action，最简单的方法是在 ",(0,r.jsx)(n.code,{children:"+page.server.js"})," 声明一个 ",(0,r.jsx)(n.code,{children:"default"})," action："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/routes/login/+page.server.js\nexport const actions = {\n  default: async (event) => {\n    // ...\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时 action 对应的路由是 ",(0,r.jsx)(n.code,{children:"/login"}),"。如果从 ",(0,r.jsx)(n.code,{children:"/login"})," 页面调用此 action，只需添加 ",(0,r.jsx)(n.code,{children:"<form>"}),"元素："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- src/routes/login/+page.svelte --\x3e\n<form method="POST">\n  <label>\n    Email\n    <input name="email" type="email">\n  </label>\n  <label>\n    Password\n    <input name="password" type="password">\n  </label>\n  <button>Log in</button>\n</form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如果有人点击按钮，浏览器就会将数据以 POST 请求的方式发送给服务端，并运行 ",(0,r.jsx)(n.code,{children:"default"})," action。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：此时提交表单，页面会刷新，因为表单默认不会渐进式增强。参考本篇的“渐进式增强”章节。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["当 ",(0,r.jsx)(n.code,{children:"<form>"})," 的 ",(0,r.jsx)(n.code,{children:"action"})," 属性为空时，数据默认会提交给当前页面，所以在上面的例子中我们不写 ",(0,r.jsx)(n.code,{children:"action"})," 属性也没有关系。但如果从其他页面调用此 ",(0,r.jsx)(n.code,{children:"action"}),"，则需要指定 ",(0,r.jsx)(n.code,{children:"action"})," 属性："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- src/routes/+layout.svelte --\x3e\n<form method="POST" action="/login">\n  \x3c!-- content --\x3e\n</form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在这个例子中，当前布局的路由地址是 ",(0,r.jsx)(n.code,{children:"/"}),"，调用 ",(0,r.jsx)(n.code,{children:"/login"})," 路由下的 action，需要通过 ",(0,r.jsx)(n.code,{children:"<form>"})," action 属性指定调用的 action 所在的路由位置"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：actions 将始终使用 POST 请求，因为 GET 请求不应该有副作用"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"3-命名-action",children:["3. 命名 action",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-命名-action",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"一个页面可以拥有多个命名 action："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/routes/login/+page.server.js\nexport const actions = {\n  login: async (event) => {\n    // TODO log the user in\n  },\n  register: async (event) => {\n    // TODO register the user\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["要调用命名 action，需要添加一个以 ",(0,r.jsx)(n.code,{children:"/"}),"作为前缀字符的查询参数。举两个例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- src/routes/login/+page.svelte --\x3e\n<form method="POST" action="?/register">\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- src/routes/+layout.svelte --\x3e\n<form method="POST" action="/login?/register">\n'})}),"\n",(0,r.jsxs)(n.p,{children:["选择 ",(0,r.jsx)(n.code,{children:"/"}),"作为前缀稍微有些奇怪，第一次接触的时候可能有些不明所以。以 ",(0,r.jsx)(n.code,{children:"/login?/register"}),"为例，",(0,r.jsx)(n.code,{children:"/login"}),"是路由地址，",(0,r.jsx)(n.code,{children:"?"})," 表示后面的都是查询参数，",(0,r.jsx)(n.code,{children:"/register"}),"是查询参数，其中 ",(0,r.jsx)(n.code,{children:"/"}),"是 action 约定的前缀字符，",(0,r.jsx)(n.code,{children:"/register"}),"表示请求该路由下的 ",(0,r.jsx)(n.code,{children:"register"})," 命名 action。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"action"})," 除了用在 ",(0,r.jsx)(n.code,{children:"<form>"})," 元素的 ",(0,r.jsx)(n.code,{children:"action"})," 属性，也可以用在 ",(0,r.jsx)(n.code,{children:"formaction"})," 属性："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<form method="POST" action="?/login">\n  <label>\n    Email\n    <input name="email" type="email">\n  </label>\n  <label>\n    Password\n    <input name="password" type="password">\n  </label>\n  <button>Log in</button>\n  <button formaction="?/register">Register</button>\n</form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这是一个很好的例子，借助 ",(0,r.jsx)(n.code,{children:"formaction"}),"属性，相同的表单数据可以提交给不同的 action 进行处理。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：命名 action 和默认 action 不能同时设置，否则会有报错：When using named actions, the default action cannot be used."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"4-action-函数",children:["4. action 函数",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-action-函数",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在让我们具体看下 action 函数的用法。"}),"\n",(0,r.jsxs)(n.h3,{id:"41-输入输出",children:["4.1. 输入输出",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-输入输出",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["action 接收一个 ",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-requestevent",title:"https://kit.svelte.dev/docs/types#public-types-requestevent",target:"_blank",rel:"noopener noreferrer",children:"RequestEvent"})," 对象作为参数，RequestEvent 对象之前讲过，",(0,r.jsx)(n.code,{children:"+server.js"}),"导出的函数接收的正是 RequestEvent 对象，server load 函数接收的是一个继承自 RequestEvent 的对象。有这些属性："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  cookies: {\n    get: [Function: get],\n    getAll: [Function: getAll],\n    set: [Function: set],\n    delete: [Function: delete],\n    serialize: [Function: serialize]\n  },\n  fetch: [Function (anonymous)],\n  getClientAddress: [Function: getClientAddress],\n  locals: {},\n  params: {},\n  platform: undefined,\n  request: Request,\n  route: { id: '/sign' },\n  setHeaders: [Function: setHeaders],\n  url: URL,\n  isDataRequest: false,\n  isSubRequest: false\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["action 返回的数据可以在对应的页面通过 ",(0,r.jsx)(n.code,{children:"form"})," 属性或 ",(0,r.jsx)(n.code,{children:"$page.form"})," 获取。我们展示下用法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/routes/login/+page.server.js\nexport async function load({ cookies }) {\n  const user = await db.getUserFromSession(cookies.get("sessionid"));\n  return { user };\n}\n\nexport const actions = {\n  login: async ({ cookies, request }) => {\n    // 通过 request.formData() 获取数据\n    const data = await request.formData();\n    const email = data.get("email");\n    const password = data.get("password");\n\n    const user = await db.getUser(email);\n    // 设置 sessionid\n    cookies.set("sessionid", await db.createSession(user), { path: "/" });\n\n    return { success: true };\n  },\n  register: async (event) => {\n    // TODO register the user\n  },\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- src/routes/login/+page.svelte --\x3e\n<script>\n  import { page } from \'$app/stores\';\n  const { form, data } = $props();\n<\/script>\n\n\x3c!-- 第一种方式获取 action 返回数据 --\x3e\n{#if form?.success}\n  <p class="text-sm text-gray-900 mt-2">登录成功! {data.user.name}</p>\n{/if}\n\n\x3c!-- 第二种方式获取 action 返回数据 --\x3e\n{#if $page.form?.success}\n  <p class="text-sm text-gray-900 mt-2">登录成功! {data.user.name}</p>\n{/if}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"42-错误校验",children:["4.2. 错误校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-错误校验",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["action 常需要做数据校验，当数据无效时，需要给与用户错误提示。此时可以借助",(0,r.jsx)(n.code,{children:"@sveltejs/kit"})," 提供的",(0,r.jsx)(n.code,{children:"fail"}),"函数，该函数会返回数据和一个 HTTP 状态码（对于验证错误，通常错误码为 400 或 422）。状态码可通过 ",(0,r.jsx)(n.code,{children:"$page.status"})," 获取，数据可通过 ",(0,r.jsx)(n.code,{children:"form"})," 属性获取："]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"src/routes/signin/+page.server.js"}),"，完整代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { fail } from "@sveltejs/kit";\n\nexport const actions = {\n  login: async ({ request }) => {\n    const formData = await request.formData();\n    const username = formData.get("username");\n\n    if (!username) {\n      return fail(400, { missing: true });\n    }\n\n    return {\n      success: true,\n      data: Object.fromEntries(formData),\n    };\n  },\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"src/routes/signin/+page.svelte"}),"，添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  const { form } = $props();\n  import { page } from '$app/stores';\n<\/script>\n\n{#if $page.status == 400}\n  {#if form?.missing}\n    <p class=\"text-sm text-red-500 mt-2\">字段缺失，请检查！</p>\n  {/if}\n{/if}\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：fail 函数返回的数据必须是可序列化的"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"43-重定向",children:["4.3. 重定向",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-重定向",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果需要重定向，使用 ",(0,r.jsx)(n.code,{children:"@sveltejs/kit"}),"的 ",(0,r.jsx)(n.code,{children:"redirect"})," 函数，用法跟在 load 函数中相同。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"src/routes/signin/+page.server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"+import { fail, redirect } from '@sveltejs/kit';\n\nexport const actions = {\n  login: async ({ request, url }) => {\n    const formData = await request.formData();\n    const username = formData.get('username');\n\n    if (!username) {\n      return fail(400, { missing: true });\n    }\n\n+   if (url.searchParams.has('redirectTo')) {\n+     redirect(303, url.searchParams.get('redirectTo'));\n+   }\n\n    return {\n      success: true,\n      data: Object.fromEntries(formData)\n    };\n  }\n};\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们会获取网址中的 ",(0,r.jsx)(n.code,{children:"redirectTo"})," 查询参数，然后判断完成后是否重定向。但是注意这里的 url 并不是指页面的 url，而是 form action 的 url，所以要想让重定向生效，需要这样写："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<form method="POST" action="?/login&redirectTo=/new" use:enhance>\n  // ...\n</form>\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"44-数据加载",children:["4.4. 数据加载",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#44-数据加载",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["action 运行后，页面会重新渲染（除非发生重定向或预期之外的错误），action 的返回值会以 ",(0,r.jsx)(n.code,{children:"form"})," prop 的形式传给页面，这意味着页面的 load 函数会在 action 完成后运行。"]}),"\n",(0,r.jsxs)(n.h2,{id:"5-渐进式增强",children:["5. 渐进式增强",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-渐进式增强",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果我们直接使用 ",(0,r.jsx)(n.code,{children:"<form>"})," 元素："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<form method="POST">// ...</form>\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时表单提交，页面会刷新，即使没有客户端 JavaScript 也可以正常运行。但是当 JavaScript 可用时，我们可以渐进式增强表单交互，提供更好的用户体验。"}),"\n",(0,r.jsxs)(n.h3,{id:"51-useenhance",children:["5.1. use:enhance",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-useenhance",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["最简单的方法是添加 ",(0,r.jsx)(n.code,{children:"use:enhance"})," Action："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { enhance } from '$app/forms';\n<\/script>\n\n<form method=\"POST\" use:enhance>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use:enhance"})," 将模拟浏览器原生行为："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["更新页面属性 ",(0,r.jsx)(n.code,{children:"form"}),"、",(0,r.jsx)(n.code,{children:"$page.form"}),"、",(0,r.jsx)(n.code,{children:"$page.status"})]}),"\n",(0,r.jsxs)(n.li,{children:["重置 ",(0,r.jsx)(n.code,{children:"<form>"})," 元素"]}),"\n",(0,r.jsxs)(n.li,{children:["成功响应的时候，调用 ",(0,r.jsx)(n.code,{children:"invalidateAll"}),"重新加载数据"]}),"\n",(0,r.jsxs)(n.li,{children:["针对重定向的响应调用 ",(0,r.jsx)(n.code,{children:"$app/navigation"}),"的",(0,r.jsx)(n.code,{children:"goto"}),"方法"]}),"\n",(0,r.jsx)(n.li,{children:"发生错误时渲染最近的错误边界"}),"\n",(0,r.jsx)(n.li,{children:"将焦点重置为合适的元素"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"模拟的好处在于不会重新加载页面，提升性能，且保持页面其他部分状态不变。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use:enhance"})," 支持传入一个函数用于自定义提交逻辑。该函数会在表单提交之前执行，如果返回一个回调函数，该回调函数会在 action 返回之后执行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<form\n  method="POST"\n  use:enhance={({ formElement, formData, action, cancel, submitter }) => {\n    // `formElement` 是 `<form>` 元素\n    // `formData` 是提交的 `FormData`对象\n    // `action` 是 action URL\n    // 调用 `cancel()` 会阻止提交\n    // `submitter` 是导致表单提交的 `HTMLElement`\n\n    // 可选，返回一个回调函数时将阻止默认行为\n    return async ({ result, update }) => {\n      // `result` 是 `ActionResult` 对象\n      // 如果返回一个回调函数，将阻止默认行为，等调用 update 时会继续执行默认逻辑\n    };\n  }}\n>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["其中，",(0,r.jsx)(n.code,{children:"use:enhance"})," 传入的自定义函数是 ",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-submitfunction",title:"https://kit.svelte.dev/docs/types#public-types-submitfunction",target:"_blank",rel:"noopener noreferrer",children:"SubmitFunction"})," 类型，可选返回的回调函数中，result 是 ",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-actionresult",title:"https://kit.svelte.dev/docs/types#public-types-actionresult",target:"_blank",rel:"noopener noreferrer",children:"ActionResult"})," 类型。"]}),"\n",(0,r.jsx)(n.p,{children:"我们可以借助这个函数实现 loading UI 的展示或隐藏等，举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  // ...\n  let loading = $state(false);\n<\/script>\n\n<form\n  method="POST"\n  action="?/login"\n  use:enhance={() => {\n    loading = true;\n    return async ({ update }) => {\n      loading = false;\n      update();\n    };\n  }}\n>\n  // ...\n  <button\n    class="flex w-full justify-center rounded-md bg-indigo-600 px-3 py-1.5 text-sm text-white shadow-sm disabled:bg-indigo-300"\n    disabled={loading}>提交 {loading ? \'...\' : \'\'}</button\n  >\n</form>\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["但是要注意，以上仅发生在表单提交给当前页面的时候，也就是 ",(0,r.jsx)(n.code,{children:"+page.server.js"}),"和 ",(0,r.jsx)(n.code,{children:"+page.svelte"}),"在同一路由。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果 ",(0,r.jsx)(n.code,{children:"<form>"})," action 属性指向其他路由，比如 ",(0,r.jsx)(n.code,{children:"src/routes/signin/+page.svelte"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<form\n  method="POST"\n  action="/sign?/login"\n  use:enhance={() => {\n    return async ({ result, update }) => {\n      // result 会正常返回，但调用 update 不会生效\n      update()\n    };\n  }}\n>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"/signin"}),"调用 ",(0,r.jsx)(n.code,{children:"/sign"})," 下的 action，此时调用 update() 不会生效，当然直接使用 ",(0,r.jsx)(n.code,{children:"use:enhance"}),"也不会生效。所谓不会生效，不是指有报错，而是提交后看起来“没有反应”，也就是不会更新 form 属性、重新加载数据等。"]}),"\n",(0,r.jsxs)(n.p,{children:["这是因为 ",(0,r.jsx)(n.code,{children:"use:enhance"}),"是为了模拟浏览器原生行为，在原生行为中 ，提交到其他地址时，页面会重定向到该地址。为了能够生效，需要调用 ",(0,r.jsx)(n.code,{children:"applyAction"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  import { enhance, applyAction } from \'$app/forms\';\n<\/script>\n\n<form\n  method="POST"\n  action="/sign?/login"\n  use:enhance={() => {\n    loading = true;\n    return async ({ result, update }) => {\n      loading = false;\n      await applyAction(result);\n    };\n  }}\n>\n  // ...\n</form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"applyAction(result)"})," 的具体行为取决于 ",(0,r.jsx)(n.code,{children:"result.type"}),"："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"success"}),", ",(0,r.jsx)(n.code,{children:"failure"}),"：将 ",(0,r.jsx)(n.code,{children:"$page.status"})," 设置为 ",(0,r.jsx)(n.code,{children:"result.status"}),"，并将 ",(0,r.jsx)(n.code,{children:"form"})," 和 ",(0,r.jsx)(n.code,{children:"$page.form"})," 更新为 ",(0,r.jsx)(n.code,{children:"result.data"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"redirect"}),"：调用重定向，本质是运行",(0,r.jsx)(n.code,{children:"goto(result.location, { invalidateAll: true })"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"error"}),"：传递 result.error 数据渲染最近的错误边界"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["开发者也可以根据 ",(0,r.jsx)(n.code,{children:"result.type"})," 自定义后续的逻辑："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"<script>\n  import { goto } from '$app/navigation';\n  import { enhance, applyAction } from '$app/forms';\n<\/script>\n\n<form\n  method=\"POST\"\n  action=\"/sign?/login\"\n  use:enhance={() => {\n    loading = true;\n    return async ({ result, update }) => {\n      loading = false;\n+     if (result.type === 'redirect') {\n+        goto(result.location);\n+     } else {\n+        await applyAction(result);\n+     }\n    };\n  }}\n>\n  // ...\n</form>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["简单总结一下：如果要实现表单的渐进式增强（一个直观的表现是提交时页面无刷新），SvelteKit 提供了 ",(0,r.jsx)(n.code,{children:"use:enhance"})," Action。如果要自定义表单提交逻辑，可以为 ",(0,r.jsx)(n.code,{children:"use:enhance"}),"传入一个 SubmitFunction。如果该 SubmitFunction 返回一个函数，该函数会阻止表单处理响应后的默认行为比如更新页面属性、调用 ",(0,r.jsx)(n.code,{children:"invalidateAll"}),"重新加载数据、根据响应重定向或渲染错误边界等等。为了能够运行这些默认行为，与 action 同一路由下的页面需要调用 ",(0,r.jsx)(n.code,{children:"update"})," 函数，非同一路由下，运行 ",(0,r.jsx)(n.code,{children:"applyAction(result)"}),"函数。"]}),"\n",(0,r.jsxs)(n.h3,{id:"52-自定义实现",children:["5.2. 自定义实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-自定义实现",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们也可以不使用 ",(0,r.jsx)(n.code,{children:"use:enhance"}),"，通过在",(0,r.jsx)(n.code,{children:"<form>"})," 上添加事件监听器的方式自定义实现渐进增强："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- src/routes/login/+page.svelte --\x3e\n\n<script>\n  import { invalidateAll, goto } from '$app/navigation';\n  import { applyAction, deserialize } from '$app/forms';\n\n  export let form;\n\n  let error;\n\n  async function handleSubmit(event) {\n    const data = new FormData(event.currentTarget);\n\n    const response = await fetch(event.currentTarget.action, {\n      method: 'POST',\n      body: data\n    });\n\n    const result = deserialize(await response.text());\n\n    if (result.type === 'success') {\n      // 重新运行所有 `load` 函数\n      await invalidateAll();\n    }\n\n    applyAction(result);\n  }\n<\/script>\n\n<form method=\"POST\" on:submit|preventDefault={handleSubmit}>\n  \x3c!-- content --\x3e\n</form>\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"6-get-请求",children:["6. GET 请求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-get-请求",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用 Form action 必须是 POST 请求，所以要声明 ",(0,r.jsx)(n.code,{children:'<form method="POST">'}),"。但有些情况，表单不需要向服务端 POST 数据，比如搜索。对于这些情况，可以使用 ",(0,r.jsx)(n.code,{children:'method="GET"'})," 或者不声明 ",(0,r.jsx)(n.code,{children:"method"}),"（此时默认为 GET），此时 SvelteKit 会将表单视为 ",(0,r.jsx)(n.code,{children:"<a>"}),"元素："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<form action="/search">\n  <label>\n    Search\n    <input name="q">\n  </label>\n</form>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时表单提交后，会跳转到 ",(0,r.jsx)(n.code,{children:"/search?q=xxx"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["此外，可以通过在 ",(0,r.jsx)(n.code,{children:"<form>"})," 元素上设置 ",(0,r.jsx)(n.code,{children:"data-sveltekit-reload"}),"、 ",(0,r.jsx)(n.code,{children:"data-sveltekit-replacestate"}),"、",(0,r.jsx)(n.code,{children:"data-sveltekit-keepfocus"}),"、",(0,r.jsx)(n.code,{children:"data-sveltekit-noscroll"})," 属性来控制路由行为。这些属性我们会在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7407681878888562723/section/7408068605482860584",title:"https://juejin.cn/book/7407681878888562723/section/7408068605482860584",target:"_blank",rel:"noopener noreferrer",children:"《SvleteKit | 链接选项》"}),"篇介绍。"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F17-SvelteKit%20%E2%9D%98%20Form%20actions.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"1.1. 传统实现方式",id:"11-传统实现方式",depth:3},{text:"1.2. Actions 实现方式",id:"12-actions-实现方式",depth:3},{text:"2. 默认 action",id:"2-默认-action",depth:2},{text:"3. 命名 action",id:"3-命名-action",depth:2},{text:"4. action 函数",id:"4-action-函数",depth:2},{text:"4.1. 输入输出",id:"41-输入输出",depth:3},{text:"4.2. 错误校验",id:"42-错误校验",depth:3},{text:"4.3. 重定向",id:"43-重定向",depth:3},{text:"4.4. 数据加载",id:"44-数据加载",depth:3},{text:"5. 渐进式增强",id:"5-渐进式增强",depth:2},{text:"5.1. use:enhance",id:"51-useenhance",depth:3},{text:"5.2. 自定义实现",id:"52-自定义实现",depth:3},{text:"6. GET 请求",id:"6-get-请求",depth:2}],title:"17-SvelteKit ❘ Form actions",headingTitle:"17-SvelteKit ❘ Form actions",frontmatter:{}}}}]);