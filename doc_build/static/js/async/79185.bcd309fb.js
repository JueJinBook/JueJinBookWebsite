"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79185"],{44173:function(e,n,c){c.r(n),c.d(n,{default:()=>E});var r=c(552676),h=c(740453);let s=c.p+"static/image/40b669b256483dcc1cc40afe50a7f825.eff00705.webp",i=c.p+"static/image/bf9d39b8c262ad2a32e678af542dfeb5.e3e78181.webp",d=c.p+"static/image/e3c61ee3bab3147a45226b7e3b9ec376.c4a2c1a7.webp",l=c.p+"static/image/f78a0be5fa1e03a8bc85537c623be55a.c4771abd.webp",a=c.p+"static/image/05f5a369eb152378b531ae3851e8e413.7840e203.webp",o=c.p+"static/image/0112608b2f7ada55861037737be1b149.7165e395.webp",p=c.p+"static/image/40e4c3fb65288a8aa7b7396b1d4a48e4.7adfd1ae.webp",u=c.p+"static/image/75c1b8d5b50a3e4c0b59d6241b8679c5.78638670.webp",t=c.p+"static/image/d2f1c72464316d319d4e5834a0dc4ba4.2fa9f456.webp",j=c.p+"static/image/3cc16543449174d7df16caf2e157bc26.eb112f2b.webp",x=c.p+"static/image/6db1b51f4ba2fba3f4a2f2a57ce58464.2c5149a0.webp",k=c.p+"static/image/66e86146378a2b121d9d7abec91cb7ec.354ed123.webp",b=c.p+"static/image/30f0e6e149c9aea5f4b3edcde3bf1cc0.d8a872ff.webp",m=c.p+"static/image/6f165a8e8ac05d25fe051bdbdff90ed1.3b232ced.webp",g=c.p+"static/image/6cdd6abf6cfb9e84c7a5c0121486c5aa.014acbbd.webp",C=c.p+"static/image/d6a2ce71c84041bd8144157abda7ce1d.c6c3608c.webp",f=c.p+"static/image/413d22ec81b7f17559ee46b4b7e3f94c.ac418fd1.webp";function G(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",strong:"strong",img:"img",code:"code",pre:"pre",blockquote:"blockquote"},(0,h.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"26chunk三种产物的打包逻辑",children:["26.Chunk：三种产物的打包逻辑",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26chunk三种产物的打包逻辑",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在上一篇文章《",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035705153552419",target:"_blank",rel:"noopener noreferrer",children:"Dependency Graph：如何管理模块间依赖？"}),"》中，我们已经详细讲解了「构建」阶段如何从 Entry 开始逐步递归读入、解析模块内容，并最终构建出模块依赖关系图 —— ModuleGraph 对象。本文我们继续往下，讲解在接下来的「封装」阶段，如何根据 ModuleGraph 内容组织 Chunk，并进一步构建出 ChunkGroup、ChunkGraph 依赖关系对象的主流程。"]}),"\n",(0,r.jsx)(n.p,{children:"主流程之外，我们还会详细讲解几个比较模糊的概念："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Chunk、ChunkGroup、ChunGraph 对象分别是什么？互相之间存在怎样的交互关系？"}),"\n",(0,r.jsx)(n.li,{children:"Webpack 默认分包规则，以及规则中存在的问题。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"chunkgraph-构建过程",children:["ChunkGraph 构建过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#chunkgraph-构建过程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 《",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035873802813475",target:"_blank",rel:"noopener noreferrer",children:"Init、Make、Seal：真正读懂 Webpack 核心流程"}),"》中，我们已经介绍了 Webpack 底层构建逻辑大体上可以划分为：「",(0,r.jsx)(n.strong,{children:"初始化、构建、封装"}),"」三个阶段："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["其中，「",(0,r.jsx)(n.strong,{children:"构建"}),"」阶段负责分析模块间的依赖关系，建立起模块之间的 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/concepts/dependency-graph/#root",target:"_blank",rel:"noopener noreferrer",children:"依赖关系图"}),"（ModuleGraph）；紧接着，在「",(0,r.jsx)(n.strong,{children:"封装"}),"」阶段根据依赖关系图，将模块分开封装进若干 Chunk 对象中，并将 Chunk 之间的父子依赖关系梳理成 ChunkGraph 与若干 ChunkGroup 对象。"]}),"\n",(0,r.jsx)(n.p,{children:"「封装」阶段最重要的目标就是根据「构建」阶段收集到的 ModuleGraph 关系图构建 ChunkGraph 关系图，这个过程的逻辑比较复杂："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"我们简单分析一下这里面几个重要步骤的实现逻辑。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第一步非常关键："})," 调用 ",(0,r.jsx)(n.code,{children:"seal()"})," 函数后，遍历 ",(0,r.jsx)(n.code,{children:"entry"})," 配置，为每个入口创建一个空的 ",(0,r.jsx)(n.code,{children:"Chunk"})," 与 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Entrypoint.js",target:"_blank",rel:"noopener noreferrer",children:"EntryPoint"})," 对象（一种特殊的 ",(0,r.jsx)(n.code,{children:"ChunkGroup"}),"），并初步设置好基本的 ",(0,r.jsx)(n.code,{children:"ChunkGraph"})," 结构关系，为下一步骤做好准备，关键代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class Compilation {\n  seal(callback) {\n    // ...\n    const chunkGraphInit = new Map();\n    // 遍历入口模块列表\n    for (const [name, { dependencies, includeDependencies, options }] of this\n      .entries) {\n      // 为每一个 entry 创建对应的 Chunk 对象\n      const chunk = this.addChunk(name);\n      // 为每一个 entry 创建对应的 ChunkGroup 对象\n      const entrypoint = new Entrypoint(options);\n      // 关联 Chunk 与 ChunkGroup\n      connectChunkGroupAndChunk(entrypoint, chunk);\n\n      // 遍历 entry Dependency 列表\n      for (const dep of [...this.globalEntry.dependencies, ...dependencies]) {\n        // 为每一个 EntryPoint 关联入口依赖对象，以便下一步从入口依赖开始遍历其它模块\n        entrypoint.addOrigin(null, { name }, /** @type {any} */ (dep).request);\n\n        const module = this.moduleGraph.getModule(dep);\n        if (module) {\n          // 在 ChunkGraph 中记录入口模块与 Chunk 关系\n          chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint);\n          // ...\n        }\n      }\n    }\n    // 调用 buildChunkGraph 方法，开始构建 ChunkGraph\n    buildChunkGraph(this, chunkGraphInit);\n    // 触发各种优化钩子\n    // ...\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"执行完成后，形成如下数据结构："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["其次，若此时配置了 ",(0,r.jsx)(n.code,{children:"entry.runtime"}),"，Webpack 还会在这个阶段为运行时代码 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L2933-L2934",target:"_blank",rel:"noopener noreferrer",children:"创建"})," 相应的 Chunk 并直接 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L2937-L2938",target:"_blank",rel:"noopener noreferrer",children:"分配"})," 给 ",(0,r.jsx)(n.code,{children:"entry"})," 对应的 ",(0,r.jsx)(n.code,{children:"ChunkGroup"}),"对象。一切准备就绪后调用 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1347-L1348",target:"_blank",rel:"noopener noreferrer",children:"buildChunkGraph"})," 函数，进入下一步骤。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第二步："})," 在 ",(0,r.jsx)(n.code,{children:"buildChunkGraph"})," 函数内 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1367-L1368",target:"_blank",rel:"noopener noreferrer",children:"调用"})," ",(0,r.jsx)(n.code,{children:"visitModules"})," 函数，遍历 ModuleGraph，将所有 Module 按照依赖关系分配给不同 ",(0,r.jsx)(n.code,{children:"Chunk"})," 对象；这个过程中若遇到 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/blog/2020-10-10-webpack-5-release/#async-modules",target:"_blank",rel:"noopener noreferrer",children:"异步模块"}),"，则为该模块 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L740-L742",target:"_blank",rel:"noopener noreferrer",children:"创建"}),"新的 ",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 与 ",(0,r.jsx)(n.code,{children:"Chunk"})," 对象，最终形成如下数据结构："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第三步："})," 在 ",(0,r.jsx)(n.code,{children:"buildChunkGraph"})," 函数中",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1381-L1382",target:"_blank",rel:"noopener noreferrer",children:"调用"})," ",(0,r.jsx)(n.code,{children:"connectChunkGroups"})," 方法，建立 ",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 之间、",(0,r.jsx)(n.code,{children:"Chunk"})," 之间的依赖关系，生成完整的 ",(0,r.jsx)(n.code,{children:"ChunkGraph"})," 对象，最终形成如下数据结构："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第四步："})," 在 ",(0,r.jsx)(n.code,{children:"buildChunkGraph"})," 函数中",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1397-L1398",target:"_blank",rel:"noopener noreferrer",children:"调用"})," ",(0,r.jsx)(n.code,{children:"cleanupUnconnectedGroups"})," 方法，清理无效 ",(0,r.jsx)(n.code,{children:"ChunkGroup"}),"，主要起到性能优化作用。"]}),"\n",(0,r.jsxs)(n.p,{children:["自上而下经过这四个步骤后，",(0,r.jsx)(n.code,{children:"ModuleGraph"})," 中存储的模块将根据模块本身的性质，被分配到 Entry、Async、Runtime 三种不同的 Chunk 对象，并将 Chunk 之间的依赖关系存储到 ChunkGraph 与 ChunkGroup 集合中，后续可在这些对象基础上继续修改分包策略（例如 ",(0,r.jsx)(n.code,{children:"SplitChunksPlugin"}),"），通过重新组织、分配 Module 与 Chunk 对象的归属实现分包优化。"]}),"\n",(0,r.jsxs)(n.h2,{id:"chunk-vs-chunkgroup-vs-chunkgraph",children:["Chunk vs ChunkGroup vs ChunkGraph",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#chunk-vs-chunkgroup-vs-chunkgraph",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上述构建过程涉及 Chunk、ChunkGroup、ChunkGraph 三种关键对象，我们先总结它们的概念与作用，加深理解："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Chunk"}),"：Module 用于读入模块内容，记录模块间依赖等；而 Chunk 则根据模块依赖关系合并多个 Module，输出成资产文件（合并、输出产物的逻辑，我们放到下一章讲解）："]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ChunkGroup"}),"：一个 ",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 内包含一个或多个 ",(0,r.jsx)(n.code,{children:"Chunk"})," 对象；",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 与 ",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 之间形成父子依赖关系："]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ChunkGraph"}),"：最后，Webpack 会将 Chunk 之间、ChunkGroup 之间的依赖关系存储到 ",(0,r.jsx)(n.code,{children:"compilation.chunkGraph"})," 对象中，形成如下类型关系："]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"默认分包规则",children:["默认分包规则",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#默认分包规则",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["综合上述 ",(0,r.jsx)(n.code,{children:"ChunkGraph"})," 构建流程最终会将 Module 组织成三种不同类型的 Chunk："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Entry Chunk：同一个 ",(0,r.jsx)(n.code,{children:"entry"})," 下触达到的模块组织成一个 Chunk；"]}),"\n",(0,r.jsx)(n.li,{children:"Async Chunk：异步模块单独组织为一个 Chunk；"}),"\n",(0,r.jsxs)(n.li,{children:["Runtime Chunk：",(0,r.jsx)(n.code,{children:"entry.runtime"})," 不为空时，会将运行时模块单独组织成一个 Chunk。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["这是 Webpack 内置的，在不使用 ",(0,r.jsx)(n.code,{children:"splitChunks"})," 或其它插件的情况下，模块输入映射到输出的默认规则，是 Webpack 底层关键原理之一，因此有必要展开介绍每一种 Chunk 的具体规则。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Entry Chunk:"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["先从 Entry Chunk 开始，Webpack 首先会为每一个 ",(0,r.jsx)(n.code,{children:"entry"})," 创建 ",(0,r.jsx)(n.code,{children:"Chunk"})," 对象，例如对于如下配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  entry: {\n    main: "./src/main",\n    home: "./src/home",\n  }\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["遍历 ",(0,r.jsx)(n.code,{children:"entry"})," 对象属性并创建出 ",(0,r.jsx)(n.code,{children:"chunk[main]"})," 、",(0,r.jsx)(n.code,{children:"chunk[home]"})," 两个对象，此时两个 Chunk 分别包含 ",(0,r.jsx)(n.code,{children:"main"})," 、",(0,r.jsx)(n.code,{children:"home"})," 模块："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["初始化完毕后，Webpack 会根据 ",(0,r.jsx)(n.code,{children:"ModuleGraph"})," 的依赖关系数据，将 ",(0,r.jsx)(n.code,{children:"entry"})," 下所触及的所有 Module 塞入 Chunk （发生在 ",(0,r.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L187-L188",target:"_blank",rel:"noopener noreferrer",children:"visitModules"})," 方法），比如对于如下文件依赖："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"main.js"})," 以同步方式直接或间接引用了 a/b/c/d 四个文件，Webpack 会首先为 ",(0,r.jsx)(n.code,{children:"main.js"})," 模块创建 Chunk 与 EntryPoint 对象，之后将 a/b/c/d 模块逐步添加到 ",(0,r.jsx)(n.code,{children:"chunk[main]"})," 中，最终形成："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Async Chunk:"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["其次，Webpack 会将每一个异步导入语句（",(0,r.jsx)(n.code,{children:"import(xxx)"})," 及 ",(0,r.jsx)(n.code,{children:"require.ensure"}),"）处理为一个单独的 Chunk 对象，并将其子模块都加入这个 Chunk 中 —— 我们称之为 Async Chunk。例如对于下面的例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// index.js\nimport './sync-a.js'\nimport './sync-b.js'\n\nimport('./async-a.js')\n\n// async-a.js\nimport './sync-c.js'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在入口模块 ",(0,r.jsx)(n.code,{children:"index.js"})," 中，以同步方式引入 sync-a、sync-b；以异步方式引入 async-a 模块；同时，在 async-a 中以同步方式引入 ",(0,r.jsx)(n.code,{children:"sync-c"})," 模块，形成如下模块依赖关系图："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["此时，Webpack 会为入口 ",(0,r.jsx)(n.code,{children:"index.js"}),"、异步模块 ",(0,r.jsx)(n.code,{children:"async-a.js"})," 分别创建分包，形成如下 Chunk 结构："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["并且 ",(0,r.jsx)(n.code,{children:"chunk[index]"})," 与 ",(0,r.jsx)(n.code,{children:"chunk[async-a]"})," 之间形成了单向依赖关系，Webpack 会将这种依赖关系保存在 ",(0,r.jsx)(n.code,{children:"ChunkGroup._parents"})," 、",(0,r.jsx)(n.code,{children:"ChunkGroup._children"})," 属性中。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Runtime Chunk:"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，除了 ",(0,r.jsx)(n.code,{children:"entry"}),"、异步模块外，Webpack5 还支持将 Runtime 代码单独抽取为 Chunk。这里说的 Runtime 代码是指一些为了确保打包产物能正常运行，而由 Webpack 注入的一系列基础框架代码，举个例子，常见的 Webpack 打包产物结构如："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["上图红框圈出来的一大段代码就是 Webpack 动态生成的运行时代码，编译时，Webpack 会根据业务代码，决定输出哪些支撑特性的运行时代码（基于 ",(0,r.jsx)(n.code,{children:"Dependency"})," 子类），例如："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["需要 ",(0,r.jsx)(n.code,{children:"__webpack_require__.f"}),"、",(0,r.jsx)(n.code,{children:"__webpack_require__.r"})," 等功能实现最起码的模块化支持；"]}),"\n",(0,r.jsxs)(n.li,{children:["如果用到动态加载特性，则需要写入 ",(0,r.jsx)(n.code,{children:"__webpack_require__.e"})," 函数；"]}),"\n",(0,r.jsxs)(n.li,{children:["如果用到 Module Federation 特性，则需要写入 ",(0,r.jsx)(n.code,{children:"__webpack_require__.o"})," 函数；"]}),"\n",(0,r.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时显得有点浪费，为此 Webpack5 提供了 ",(0,r.jsx)(n.code,{children:"entry.runtime"})," 配置项用于声明如何打包运行时代码。用法上只需在 ",(0,r.jsx)(n.code,{children:"entry"})," 项中增加字符串形式的 ",(0,r.jsx)(n.code,{children:"runtime"})," 值，例如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  entry: {\n    index: { import: "./src/index", runtime: "solid-runtime" },\n  }\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"compilation.seal"})," 函数中，Webpack 首先为 ",(0,r.jsx)(n.code,{children:"entry"})," 创建 ",(0,r.jsx)(n.code,{children:"EntryPoint"}),"，之后判断 ",(0,r.jsx)(n.code,{children:"entry"})," 配置中是否带有 ",(0,r.jsx)(n.code,{children:"runtime"})," 属性，有则创建以 ",(0,r.jsx)(n.code,{children:"runtime"})," 值为名的 Chunk，因此，上例配置将生成两个 Chunk：",(0,r.jsx)(n.code,{children:"chunk[index.js]"})," 、",(0,r.jsx)(n.code,{children:"chunk[solid-runtime]"}),"，并据此最终产出两个文件："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["入口 index 对应的 ",(0,r.jsx)(n.code,{children:"index.js"})," 文件；"]}),"\n",(0,r.jsxs)(n.li,{children:["运行时配置对应的 ",(0,r.jsx)(n.code,{children:"solid-runtime.js"})," 文件。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["在多 ",(0,r.jsx)(n.code,{children:"entry"})," 场景中，只要为每个 ",(0,r.jsx)(n.code,{children:"entry"})," 都设定相同的 ",(0,r.jsx)(n.code,{children:"runtime"})," 值，Webpack 运行时代码就会合并写入到同一个 Runtime Chunk 中，最终达成产物性能优化效果。例如对于如下配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  entry: {\n    index: { import: "./src/index", runtime: "solid-runtime" },\n    home: { import: "./src/home", runtime: "solid-runtime" },\n  }\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["入口 ",(0,r.jsx)(n.code,{children:"index"}),"、",(0,r.jsx)(n.code,{children:"home"})," 共享相同的 ",(0,r.jsx)(n.code,{children:"runtime"})," 值，最终生成三个 Chunk，分别为："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["此时入口 ",(0,r.jsx)(n.code,{children:"chunk[index]"}),"、",(0,r.jsx)(n.code,{children:"chunk[home]"})," 与运行时 ",(0,r.jsx)(n.code,{children:"chunk[solid-runtime]"})," 也会形成父子依赖关系。"]}),"\n",(0,r.jsxs)(n.h2,{id:"分包规则的问题",children:["分包规则的问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#分包规则的问题",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"默认分包规则最大的问题是无法解决模块重复，如果多个 Chunk 同时包含同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk。比如假设我们有两个入口 main/index 同时依赖了同一个模块："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"默认情况下，Webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 main/index 两个 Chunk，最终形成："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到 ",(0,r.jsx)(n.code,{children:"chunk"})," 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！"]}),"\n",(0,r.jsxs)(n.p,{children:["为了解决这个问题，Webpack 3 引入 ",(0,r.jsx)(n.code,{children:"CommonChunkPlugin"})," 插件试图将 entry 之间的公共依赖提取成单独的 ",(0,r.jsx)(n.code,{children:"chunk"}),"，但 ",(0,r.jsx)(n.code,{children:"CommonChunkPlugin"})," 本质上还是基于 Chunk 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 ",(0,r.jsx)(n.code,{children:"entry"})," 的父 ",(0,r.jsx)(n.code,{children:"chunk"})," 还是子 ",(0,r.jsx)(n.code,{children:"chunk"}),"，",(0,r.jsx)(n.code,{children:"CommonChunkPlugin"})," 统一处理为父 ",(0,r.jsx)(n.code,{children:"chunk"}),"，某些情况下反而对性能造成了不小的负面影响。"]}),"\n",(0,r.jsxs)(n.p,{children:["为此，在 Webpack4 之后才专门引入了更复杂的数据结构 —— ",(0,r.jsx)(n.code,{children:"ChunkGroup"})," 专门实现关系链管理，配合 ",(0,r.jsx)(n.code,{children:"SplitChunksPlugin"})," 能够更高效、智能地实现",(0,r.jsx)(n.strong,{children:"启发式分包。"})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"综上，「构建」阶段负责根据模块的引用关系构建 ModuleGraph；「封装」阶段则负责根据 ModuleGraph 构建一系列 Chunk 对象，并将 Chunk 之间的依赖关系（异步引用、Runtime）组织为 ChunkGraph —— Chunk 依赖关系图对象。与 ModuleGraph 类似，ChunkGraph 结构的引入也能解耦 Chunk 之间依赖关系的管理逻辑，整体架构逻辑更合理更容易扩展。"}),"\n",(0,r.jsx)(n.p,{children:"不过，虽然看着很复杂，但「封装」阶段最重要的目标还是在于：确定有多少个 Chunk，以及每一个 Chunk 中包含哪些 Module —— 这些才是真正影响最终打包结果的关键因素。"}),"\n",(0,r.jsxs)(n.p,{children:["针对这一点，我们需要理解 Webpack5 内置的三种分包规则：Entry Chunk、Async Chunk 与 Runtime Chunk，这些是最最原始的分包逻辑，其它插件（例如 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer",children:"splitChunksPlugin"}),"）都是在此基础，借助 ",(0,r.jsx)(n.code,{children:"buildChunkGraph"})," 后触发的各种钩子进一步拆分、合并、优化 Chunk 结构，实现扩展分包效果。"]}),"\n",(0,r.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Chunk"})," 一定会且只会生产出一个产物文件吗？为什么？",(0,r.jsx)(n.code,{children:"mini-css-extract-plugin"}),"、",(0,r.jsx)(n.code,{children:"file-loader"})," 这一类能写出额外文件的组件，底层是怎么实现的？"]})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,h.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(G,{...e})}):G(e)}let E=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F26.Chunk%EF%BC%9A%E4%B8%89%E7%A7%8D%E4%BA%A7%E7%89%A9%E7%9A%84%E6%89%93%E5%8C%85%E9%80%BB%E8%BE%91.md"]={toc:[{text:"ChunkGraph 构建过程",id:"chunkgraph-构建过程",depth:2},{text:"Chunk vs ChunkGroup vs ChunkGraph",id:"chunk-vs-chunkgroup-vs-chunkgraph",depth:2},{text:"默认分包规则",id:"默认分包规则",depth:2},{text:"分包规则的问题",id:"分包规则的问题",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"26.Chunk：三种产物的打包逻辑",headingTitle:"26.Chunk：三种产物的打包逻辑",frontmatter:{}}}}]);