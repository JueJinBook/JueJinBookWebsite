"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["82676"],{309799:function(e,n,t){t.r(n),t.d(n,{default:()=>$});var c=t(552676),s=t(740453);let l=t.p+"static/image/47ff70b2d05ad6a8dfcb4557e3111bf4.f5331d8b.webp",r=t.p+"static/image/f9a1506a2c40a0f12553b2765ad7bb6d.c3d83b12.webp",i=t.p+"static/image/0ba3b5ea176b40386dd625d33501926f.f7a01eac.webp",a=t.p+"static/image/0af48a1c9c3b88fb24de475a05308cd1.20a89f14.webp",d=t.p+"static/image/077cba0b979200cddede1df96512738f.c7fdc836.webp",o=t.p+"static/image/c576290746c5c4494e340b4718c5147b.5d338842.webp",h=t.p+"static/image/1b3b335633eddf202b5747bdac3b6b64.32763eca.webp",p=t.p+"static/image/caea0988ac83fb5e19894e2a55f03c17.c1f3bda4.webp",x=t.p+"static/image/ff922a7e28c62c671a0ad62536f46043.5efa04dc.webp",j=t.p+"static/image/dffda1d0e3f192a14a78e3c5606a9a06.38a3c969.webp",u=t.p+"static/image/af47c309016d23c846733b2912158016.bf39803f.webp",v=t.p+"static/image/5fdb39cf6fdbea5dbb4688136dcce8e6.1b8e7ab2.webp",b=t.p+"static/image/d9d4b0ba9b08113d1bea5ec29533b930.c56bfd79.webp",f=t.p+"static/image/bd5c399bb00d43ebdc0fcf6ce26a7aa2.db8ac984.webp",m=t.p+"static/image/5e706c855de474ff0deb5a2e1a37d31b.87342bb3.webp",g=t.p+"static/image/d584973c283044d187f9c488ab892a88.abd99766.webp",S=t.p+"static/image/6fbcb36344ba4e88a161dab1acadfbb3.eef7c3b4.webp",k=t.p+"static/image/3cbab936f8fa024be3e1169e91f4ca9f.8c2a77eb.webp",N=t.p+"static/image/0b5ee6fcb78758f22d065991ef5796d2.d5dfac68.webp",y=t.p+"static/image/478e7f9704c9c702e944839b18c2bc6d.48c9e2d4.webp",w=t.p+"static/image/aad6a5834877244fbb541cacea632b1c.58ddd715.webp";function E(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",strong:"strong",ol:"ol",li:"li",blockquote:"blockquote",code:"code",pre:"pre",h3:"h3"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"2-语法篇--基础用法",children:["2-语法篇 ❘ 基础用法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-语法篇--基础用法",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"要问最好的 Svelte 入门课程是什么？"}),"\n",(0,c.jsxs)(n.p,{children:["毫无疑问是 Svelte 的",(0,c.jsx)(n.a,{href:"https://svelte.dev/tutorial/svelte/welcome-to-svelte",title:"https://svelte.dev/tutorial/svelte/welcome-to-svelte",target:"_blank",rel:"noopener noreferrer",children:"官方入门课程"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"左边是知识讲解、右边是代码演示，学习者可以修改代码，实时查看效果。"}),"\n",(0,c.jsx)(n.p,{children:"此外，课程结构清晰、内容安排合理。每一节都有一个“小作业”，边学边做，是我见过最好的官方教学网站了。"}),"\n",(0,c.jsxs)(n.p,{children:["对于国内的同学，美中不足的可能就是没有中文翻译了。但依然",(0,c.jsx)(n.strong,{children:"建议阅读英文原版"}),"，因为："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"内容最新"})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"国内虽然有一些中文翻译网站，但我看了下，内容都不是最新，且还是机翻……那真不如看英文原版！如果英语不好，可以使用浏览器翻译插件辅助阅读。"}),"\n",(0,c.jsxs)(n.ol,{start:"2",children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"练习英文阅读"})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"阅读英文文档是成为技术大佬的必备素养"}),"，不用觉得难，以后你还会查很多英文规范、浏览国外技术博客、翻看 GitHub Issues、搜索 Stack Overflow 呢……这只是一个开始。而且 Svelte 教程涉及的词汇都比较简单，正是练习的最好时机！"]}),"\n",(0,c.jsxs)(n.ol,{start:"3",children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.strong,{children:"课程内容简单"})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"教程一共分 4 个部分："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"Svelte 基础（Basic Svelte）"}),"\n",(0,c.jsx)(n.li,{children:"Svelte 进阶（Advanced Svelte）"}),"\n",(0,c.jsx)(n.li,{children:"SvelteKit 基础（Basic SvelteKit）"}),"\n",(0,c.jsx)(n.li,{children:"SvelteKit 进阶（Advanced SvelteKit）"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"注：SvelteKit 是 Svelte 的官方脚手架"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"如果把官方教程比喻为教材，那这本小册语法篇的内容相当于“重难点解析”。"})," 你可以在简单浏览一遍文档后，再阅读一遍小册当做复习。也可以边阅读官方教程边对照语法篇的内容，加深理解。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["注：建议",(0,c.jsx)(n.strong,{children:"至少要看完“Svelte 基础”部分，"})," 因为第一部分的内容比较基础，小册再讲一遍显得有些赘述，所以只讲了重难点。第二部分的内容比较进阶，理解上会有一点难度，所以小册做了比较详细的介绍。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"2-hello-world",children:["2. Hello World!",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-hello-world",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"初次接触 Svelte 的时候，你肯定一方面惊讶于 Svelte 代码的简洁，一方面又会觉得有一丝“诡异”。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"这就是框架与库之间的区别。库不会影响你原本的开发方式，你只需要在需要的时间和地点调用即可。而框架则主导了对程序的控制，你需要按照框架指定的方式去写代码。"})}),"\n",(0,c.jsx)(n.p,{children:"既然选择使用了框架，就要接受框架约定的书写方式。其实无论是 React、Vue、Angular 还是 Svelte，初学时都会觉得有些“诡异”的地方，但随着你书写次数的增多、对运行原理的理解加深，很快你就会习以为常，甚至“视若无睹”。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"在 Svelte 中，应用程序由多个组件组成。"}),"\n",(0,c.jsxs)(n.p,{children:["组件是可复用的独立代码块，将 HTML、CSS、JavaScript 文件封装到一起，文件后缀名为 ",(0,c.jsx)(n.code,{children:".svelte"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let name = 'Svelte';\n<\/script>\n\n<style>\n  h1 {\n    color: red\n  }\n</style>\n\n<h1>Hello {name}!</h1>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这个代码有点类似于 Vue，但与 Vue 不同的是，Svelte 的样式默认是 ",(0,c.jsx)(n.code,{children:"scoped"}),"，HTML 也不需要写在 ",(0,c.jsx)(n.code,{children:"<template>"})," 中，也不需要运行 ",(0,c.jsx)(n.code,{children:"new Vue"}),"进行初始化等。整体代码比 React、Vue 都更简洁。声明一个变量，就可以直接在 HTML 中使用。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"3-响应式",children:["3. 响应式",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-响应式",children:"#"})]}),"\n",(0,c.jsxs)(n.h3,{id:"31-svelte-3-赋值",children:["3.1. Svelte 3 赋值",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-svelte-3-赋值",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这个时候 Svelte 看起来还很正常，但当涉及响应式（Reactivity）时："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let count = 0;\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button on:click={increment}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/5be49751b9384c97b0ec7d7a4a5b6c84?version=5.1.9",title:"https://svelte.dev/playground/5be49751b9384c97b0ec7d7a4a5b6c84?version=5.1.9",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:N,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"当 count 值发生修改的时候，DOM 也同步发生了变化。这说明 Svelte 做了响应式。可是 Svelte 是怎么实现响应式的呢？"}),"\n",(0,c.jsxs)(n.p,{children:["这就要说到 Svelte 与 React、Vue 不同的地方了。",(0,c.jsx)(n.strong,{children:"与其说 Svelte 是框架，不如说它是编译器"}),"。React、Vue 都是编译 + 运行时，侧重于运行时。而 Svelte 另辟蹊径，侧重于编译，运行时只有少量代码。"]}),"\n",(0,c.jsx)(n.p,{children:"React 通过 setState 触发更新，Vue3 通过 Proxy 触发更新。实际上 Svelte 2 的时候也使用类似于 React 的 setState 方法触发更新："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const { count } = this.get();\n\nthis.set({\n  count: count + 1,\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["但是 Svelte 想：“为什么一定要用这么麻烦的方法呢？最好的 API 应该是没有 API 呀！",(0,c.jsx)(n.strong,{children:"（the best API is no API）"}),"”。触发更新最简单的方式应该是直接修改，也就是",(0,c.jsx)(n.strong,{children:"赋值运算符"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"count += 1;\n"})}),"\n",(0,c.jsx)(n.p,{children:"可是 ECMAScript 并没有提供监听基础类型值的方法。然而 Svelte 一想，我又不需要听 ECMAScript 的，我是编译器！抱歉，会编译是真的能为所欲为的！"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"于是 Svelte 在编译的时候，如果检测到赋值运算符，就会加上一行代码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'count += 1;\n$$invalidate("count", count);\n'})}),"\n",(0,c.jsx)(n.p,{children:"如此实现了触发更新。当然这是 Svelte 3 的时候，但也正是这一创新的实现，让 Svelte 开始变得流行了起来，也深刻的影响了其他框架。"}),"\n",(0,c.jsx)(n.p,{children:"到了 Svelte 4，编译的代码变成了："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"$$invalidate(0, (count += 1));\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/repl/f6f16dee3fbd4062a2f91dcc0d414fc8?version=4.2.18",title:"https://svelte.dev/repl/f6f16dee3fbd4062a2f91dcc0d414fc8?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"点击链接查看 Svelte 4 的编译结果"}),"。不过 Svelte 3 和 Svelte 4 基本原理是类似的，都是检测赋值运算符。这也就是为什么在 Svelte 4 中，你不能用 ",(0,c.jsx)(n.code,{children:"push"}),"、",(0,c.jsx)(n.code,{children:"splice"})," 等方法更新数组，因为 Svelte 的响应式是由赋值操作来触发的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// ❌ 这样是不行的\nfunction addNumber() {\n  numbers.push(numbers.length + 1);\n}\n\n// ✅ 这样是可以的\nfunction addNumber() {\n  numbers.push(numbers.length + 1);\n  numbers = numbers;\n}\n\n// ✅ 这样也是可以的\nfunction addNumber() {\n  numbers = [...numbers, numbers.length + 1];\n}\n\n// ✅ 这样也是可以的\nfunction addNumber() {\n  numbers[numbers.length] = numbers.length + 1;\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"32-svelte-5-符文",children:["3.2. Svelte 5 符文",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-svelte-5-符文",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"但是你现在学的是 Svelte 5！"})," 到了 Svelte 5，一切又都变了。Svelte 5 基于 ",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7407681878888562723/section/7408069492611219508",title:"https://juejin.cn/book/7407681878888562723/section/7408069492611219508",target:"_blank",rel:"noopener noreferrer",children:"Signals"})," 进行了代码层面的完全重构，但 API 层面改变的不算多，这个升级类似于 Next.js 12 升 Next.js 13，之前的依然可以用，但推荐使用新的开发方式。"]}),"\n",(0,c.jsx)(n.p,{children:"在 Svelte 5 中，刚才的代码虽然可以运行，但为了面向未来，建议写成："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button onclick={increment}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/9262197502ea4444a2e5470bbb9bc037?version=5.1.9",title:"https://svelte.dev/playground/9262197502ea4444a2e5470bbb9bc037?version=5.1.9",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:S,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["最主要的改变是将 ",(0,c.jsx)(n.code,{children:"let count = 0"}),"改成了 ",(0,c.jsx)(n.code,{children:"let count = $state(0)"}),"，",(0,c.jsx)(n.code,{children:"$state"}),"正是 Svelte 5 提供的符文语法。猛一看，你可能想吐槽：“我就是看中你 Svelte 语法的简洁，但你这样一搞，写法更麻烦了一点呀！”"]}),"\n",(0,c.jsxs)(n.p,{children:["确实如此，但使用 Svelte 5 的符文语法有很多好处。比如 Svelte 4 的 ",(0,c.jsx)(n.code,{children:"let"})," 声明必须放在组件顶层，否则 Svelte 不会将其设置为响应式，Svelte 4 不能使用 ",(0,c.jsx)(n.code,{children:"push"})," 等方法操作数组，因为检测的是赋值操作符。但在 Svelte 5 的符文语法下，这些限制统统都得到了解决。"]}),"\n",(0,c.jsxs)(n.p,{children:["让我们看个 Svelte 5 中数组的操作例子，",(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/51bfba76415240909386deada0b44a80?version=5.1.9",title:"https://svelte.dev/playground/51bfba76415240909386deada0b44a80?version=5.1.9",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["简单来说，在 Svelte 4 中，你需要通过一些隐式的规则（比如放在组件顶层，使用 ",(0,c.jsx)(n.code,{children:"let"})," 声明）来告诉 Svelte 我声明的是一个响应式的值，你给我按照响应式进行处理。在 Svelte 5 中，通过 ",(0,c.jsx)(n.code,{children:"$state"}),"符文，开发者显式告诉 Svelte 这是一个响应式的值，所以可以脱离原本的隐式规则限制，另外 Svelte 5 使用了 Proxy 实现了深度响应式，所以才能操作数组。"]}),"\n",(0,c.jsxs)(n.p,{children:["当然使用符文带来的好处远不止这些，对于使用过 Svelte 4 的同学，我会单独写一篇讲解 Svelte 4 中存在的问题，进而说明使用 Svelte 5 符文的优势。而对于一开始就学习 Svelte 5 的同学，则无须了解，现在你只用知道在 Svelte 5 中，需要通过 ",(0,c.jsx)(n.code,{children:"$state"}),"符文来显式声明响应式的值。"]}),"\n",(0,c.jsxs)(n.h3,{id:"33-svelte-5-effect",children:["3.3. Svelte 5 Effect",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-svelte-5-effect",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Effect，有的会翻译为“反应”，有的会翻译为“副作用”，简单来说，在 Svelte 5 中，Effect 就是指通过 ",(0,c.jsx)(n.code,{children:"$state"}),"符文声明的值发生更改时执行的内容。在上面的例子中，当我们声明的值更改的时候，DOM 发生了更新，这就是一个 Effect，当然这是 Svelte 内部实现的，不需要我们去做。但 Svelte 5 提供了 ",(0,c.jsx)(n.code,{children:"$effect"}),"函数用于开发者自定义副作用处理："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let value = $state('a');\n\n  $effect(() => {\n    console.log(value);\n  });\n<\/script>\n\n<input type=\"text\" bind:value />\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/93f0625c416c413893230104262cb449?version=5.1.9",title:"https://svelte.dev/playground/93f0625c416c413893230104262cb449?version=5.1.9",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"$effect"})," 函数会在组件挂载和状态值更新的时候执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["在 Svelte 4 中，同样的功能是通过 ",(0,c.jsx)(n.code,{children:"$:"}),"来实现的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let value = 'a';\n\n   $: {\n     console.log(value)\n   }\n<\/script>\n\n<input type=\"text\" bind:value />\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/b1206689e00f4633bdce22892bc680ce?version=4.2.18",title:"https://svelte.dev/playground/b1206689e00f4633bdce22892bc680ce?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"点击查看浏览器效果。"})}),"\n",(0,c.jsxs)(n.p,{children:["使用 ",(0,c.jsx)(n.code,{children:"$:"})," 虽然看起来有些奇怪，但 ",(0,c.jsx)(n.code,{children:"$:"}),"是标准的 JavaScript 语法，原本的作用是标签声明（",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label",title:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label",target:"_blank",rel:"noopener noreferrer",children:"Labeled statement"}),"），只是在 Svelte 4 中多了 effect 的效果。这也是 Svelte 4 和 Svelte 5 的一个重要差别："]}),"\n",(0,c.jsx)(n.p,{children:"在 Svelte 4 中，虽然你写的是标准的 JavaScript 语法，但实际上因为 Svelte 的编译器影响，表现并不是 JavaScript 语法的效果。在 Svelte 5 中，虽然你写的看起来不像是 JavaScript 语法，但实际表现却是 JavaScript。这听起来有些绕，在接下来的介绍中我们可以慢慢体会。"}),"\n",(0,c.jsxs)(n.h2,{id:"4-props",children:["4. Props",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-props",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 Svelte 5 中，我们可以通过 ",(0,c.jsx)(n.code,{children:"$props"}),"符文获取组件的传值："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Nested from './Nested.svelte';\n<\/script>\n\n<Nested answer={42} />\n\n\x3c!-- Nested.svelte --\x3e\n<script>\n  let { answer } = $props();\n<\/script>\n\n<p>The answer is {answer}</p>\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/8440142d6ece44d08da302e1a8ba0ec4?version=5.1.9",title:"https://svelte.dev/playground/8440142d6ece44d08da302e1a8ba0ec4?version=5.1.9",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["在 Svelte 4 中，同样的效果，我们是通过 ",(0,c.jsx)(n.code,{children:"export"})," 语法来获取的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Nested from './Nested.svelte';\n<\/script>\n\n<Nested answer={42} />\n\n\x3c!-- Nested.svelte --\x3e\n<script>\n  export let answer;\n<\/script>\n\n<p>The answer is {answer}</p>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/a939f76c0afa4710ad47f02dba1f11d7?version=4.2.18",title:"https://svelte.dev/playground/a939f76c0afa4710ad47f02dba1f11d7?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"点击查看浏览器效果。"}),(0,c.jsx)(n.code,{children:"export"})," 在 JavaScript 中原本用于模块导出，但在 Svelte 4 中用于获取组件 props。"]}),"\n",(0,c.jsxs)(n.p,{children:["在 Svelte 5 中，虽然使用了 ",(0,c.jsx)(n.code,{children:"$props"}),"符文，但表现却是标准的 JavaScript，你可以把 ",(0,c.jsx)(n.code,{children:"$props"}),"理解为一个 Svelte 内部的函数，因为编译器，你无须导入该函数就可以直接使用。它会返回一个对象，所以你可以正常使用 ES6 的解构、默认值、剩余参数、重命名等语法："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'// 默认值\nlet { answer = "a mystery" } = $props();\n\n// 剩余参数\nlet { name, ...stuff } = $props();\n\n// 重命名\nlet { catch: theCatch } = $props();\n'})}),"\n",(0,c.jsxs)(n.h2,{id:"5-逻辑区块",children:["5. 逻辑区块",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-逻辑区块",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"逻辑区块算是 Svelte 独特于 React、Vue 的地方，早年的 mustache.js、Handlebars 等模板引擎都有这种语法。Svelte 支持 IF、Each、Await 等语句。"}),"\n",(0,c.jsxs)(n.h3,{id:"51-if-语句",children:["5.1. IF 语句",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-if-语句",children:"#"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n<\/script>\n\n<button onclick={increment}>\n  Clicked {count}\n  {count === 1 ? 'time' : 'times'}\n</button>\n\n{#if count > 10}\n  <p>{count} is greater than 10</p>\n{/if}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/2b987530afb24528839687f8d0be5be0?version=5.1.10",title:"https://svelte.dev/playground/2b987530afb24528839687f8d0be5be0?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"如果需要多个判断："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#if count > 10}\n  <p>{count} is greater than 10</p>\n{:else if count < 5}\n  <p>{count} is less than 5</p>\n{:else}\n  <p>{count} is between 5 and 10</p>\n{/if}\n"})}),"\n",(0,c.jsx)(n.p,{children:"不同于 React，这些逻辑区块不需要包裹元素，直接使用文本或多个同级子元素也是可以的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#if count > 10}\n  <p>{count} is greater than 10</p>\n{:else if count < 5}\n  {count} is less than 5\n{:else}\n  <span>{count}</span>\n  <span>is between 5 and 10</span>\n{/if}\n"})}),"\n",(0,c.jsx)(n.p,{children:"此外这些逻辑区块也支持相互嵌套。"}),"\n",(0,c.jsxs)(n.h3,{id:"52-each-语句",children:["5.2. Each 语句",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-each-语句",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Each 语句用于遍历可迭代对象，比如数组、类数组对象、Map、Set 等："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let tasks = [{\n    id: '1',\n    content: '阅读'\n  }, {\n    id: '2',\n    content: '冥想'\n  }]\n<\/script>\n\n{#each tasks as {content}, index}\n  <p>{index + 1}. {content}</p>\n{/each}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/4da95038f43642c59b32d5aaa4747329?version=5.1.10",title:"https://svelte.dev/playground/4da95038f43642c59b32d5aaa4747329?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"如果涉及到数据的更改或删除 ，则要注意需要像 React 遍历数组一样指定 key，要不然可能会出现性能损失或者展示错误："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let tasks = [{\n    id: '1',\n    content: '阅读'\n  }, {\n    id: '2',\n    content: '冥想'\n  }]\n<\/script>\n\n{#each tasks as {id, content}, index (id)}\n  <p>{index + 1}. {content}</p>\n{/each}\n"})}),"\n",(0,c.jsx)(n.p,{children:"此外，Each 还提供了一个 Else 语句，用可遍历对象为空时使用："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let tasks = []\n<\/script>\n\n{#each tasks as {id, content}, index (id)}\n  <p>{index + 1}. {content}</p>\n{:else}\n  <p>没有任务</p>\n{/each}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"53-await-语句",children:["5.3. Await 语句",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-await-语句",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Await 语句是非常好用的，常用于请求："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  // 随机整数\n  function getRandomIntInclusive(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled); // 包含最小值和最大值\n  }\n\n  let todoId = $state(getRandomIntInclusive(1, 100));\n\n  async function getTodo() {\n    const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${todoId}`);\n    const data = await response.json();\n    return data;\n  }\n<\/script>\n\n<button onclick={() => {\n  todoId = getRandomIntInclusive(1, 100)\n}}>换一批</button>\n\n{#await getTodo(todoId)}\n  loading...\n{:then {title = '' }}\n  {title}\n{:catch error}\n  Error\n{/await}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/a19f6bd656b1456a8d7b2ffb66487a3b?version=5.1.10",title:"https://svelte.dev/playground/a19f6bd656b1456a8d7b2ffb66487a3b?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["Await 语句适合用于处理 Promise，并提供了对 ",(0,c.jsx)(n.code,{children:"pending"}),"、",(0,c.jsx)(n.code,{children:"fulfilled"}),"、",(0,c.jsx)(n.code,{children:"rejected"})," 三种状态的处理："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#await promise}\n  ...\n{:then value}\n  ...\n{:catch error}\n  ...\n{/await}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当然根据你具体使用的情况有很多变种，比如不处理 ",(0,c.jsx)(n.code,{children:"rejected"})," 状态，那就省略 ",(0,c.jsx)(n.code,{children:"catch"})," 语句："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#await promise}\n  ...\n{:then value}\n  ...\n{/await}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["不处理 ",(0,c.jsx)(n.code,{children:"pending"}),"状态和 ",(0,c.jsx)(n.code,{children:"rejected"}),"状态："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#await promise then error}\n  ...\n{/await}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["或只处理 ",(0,c.jsx)(n.code,{children:"rejected"}),"状态："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#await promise catch name}\n  ...\n{/await}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Await 语句的一个特殊用法是懒加载组件："})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"{#await import('./Component.svelte') then { default: Component }}\n  <Component />\n{/await}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"54-key-blocks",children:["5.4. Key Blocks",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#54-key-blocks",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Key Blocks 的用法跟逻辑区块很像，先让我们看个简单的例子："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let count = $state(0);\n<\/script>\n\n{#key count}\n  <input />\n{/key}\n\n<button onclick={() => {\n  count += 1\n}}>Clicked {count}</button>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/e9e9bd7026c94a2c9cf8a9c48f8848c1?version=5.1.10",title:"https://svelte.dev/playground/e9e9bd7026c94a2c9cf8a9c48f8848c1?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"#key count"})," 的作用就在于当 count 值发生改变的时候，其中的内容会被销毁重建。所以当我们点击按钮的时候，因为输入框被销毁重建，所以其中输入的内容和选择的状态都消失了。"]}),"\n",(0,c.jsx)(n.p,{children:"那你可能好奇这有什么用呢？"}),"\n",(0,c.jsx)(n.p,{children:"这就有点像 Next.js 的 template.js，状态不会保持，每次销毁重建。常见的用途是 transition 动画："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { fly } from 'svelte/transition';\n  let count = $state(0);\n<\/script>\n\n{#key count}\n  <h1 in:fly={{ x: 200, duration: 500 }}>{count}</h1>\n\n{/key}\n\n<button onclick={() => {\n  count += 1\n}}>Clicked {count}</button>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/ef8f7c374c6948d7be3b4a3e4bfb2b09?version=5.1.10",title:"https://svelte.dev/playground/ef8f7c374c6948d7be3b4a3e4bfb2b09?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"因为每次销毁重建，所以每次都有进场动画。当然用途肯定不止做动画，在开发 Svelte 项目的时候，如果遇到需要将组件销毁重建的时候，就可以考虑使用 Key Blocks。"}),"\n",(0,c.jsxs)(n.h2,{id:"6-事件",children:["6. ",(0,c.jsx)(n.strong,{children:"事件"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-事件",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Svelte 5 的事件看起来改动很小，在 Svelte 4 中，事件的写法为："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button on:click={increment}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"在 Svelte 5 中改为："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button onclick={increment}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"看似只是少了一个冒号，但相关的影响很大。"}),"\n",(0,c.jsx)(n.p,{children:"首先， Svelte 5 废弃了原本 Svelte 4 中的 createEventDispatcher 组件事件以及事件转发机制，而转为使用类似于 React 的事件传递，这让代码更加清晰易懂，但也让 Svelte 4 中使用组件事件的生态不再兼容 Svelte 5，所以如果生态里有库使用了组件事件，将导致不能在 Svelte 5 中直接使用。"}),"\n",(0,c.jsx)(n.p,{children:"其次，Svelte 4 的这些修饰符到了 Svelte 5 都不能用了："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button on:click|once|preventDefault={handler}>...</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"如果要用，就老老实实自己写："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  function once(fn) {\n    return function (event) {\n      if (fn) fn.call(this, event);\n      fn = null;\n    };\n  }\n\n  function preventDefault(fn) {\n    return function (event) {\n      event.preventDefault();\n      fn.call(this, event);\n    };\n  }\n<\/script>\n\n<button onclick={once(preventDefault(handler))}>...</button>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["事件捕获是一个例外，因为它只能在绑定事件处理程序时设置，Svelte 5 提供了这种方式实现（在事件名称后添加 ",(0,c.jsx)(n.code,{children:"capture"}),"后缀）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button onclickcapture={...}>...</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"此外 ，Svelte 5 不再支持多个事件："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Svelte 4 是可以的： --\x3e\n<button on:click={one} on:click={two}>...</button>\n\n\x3c!-- Svelte 5 需要这些写： --\x3e\n<button\n  onclick={(e) => {\n    one(e);\n    two(e);\n  }}\n>\n  ...\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"但总体而言，我认为这些改动是很好的。"}),"\n",(0,c.jsx)(n.p,{children:"你写事件可以更加简洁："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button onclick={onclick}>\n  Clicked {count}\n</button>\n\n\x3c!-- 简写为 --\x3e\n<div {onclick}>\n  Clicked {count}\n</div>\n"})}),"\n",(0,c.jsx)(n.p,{children:"事件的传递更加方便："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Button from "./Button.svelte"\n<\/script>\n\n<Button onclick={(e) => {\n  console.log(e.target)\n}} />\n\n\x3c!-- Button.svelte --\x3e\n<script>\n  let { onclick } = $props();\n<\/script>\n\n<button {onclick}>\n  Click\n</button>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["不再需要通过 ",(0,c.jsx)(n.code,{children:"<button on:click>"}),"将事件向上转发，而是组件接收 ",(0,c.jsx)(n.code,{children:"onclick"}),"回调函数不断向下传递："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let { children, ...props } = $props();\n<\/script>\n\n<button {...props}>\n  {@render children()}\n</button>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["总体而言：通过弃用 ",(0,c.jsx)(n.code,{children:"createEventDispatcher"}),"和传统的 ",(0,c.jsx)(n.code,{children:"on:"}),"指令，改为使用回调 props，有效降低了学习成本，同时节约了创建 ",(0,c.jsx)(n.code,{children:"CustomEvent"})," 对象的成本，提升了性能。"]}),"\n",(0,c.jsx)(n.p,{children:"此外还要注意一点：可能受 React 的影响 ，写组件事件的时候大家更喜欢将函数提取出来："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  function onclick() { ... }\n<\/script>\n<button onclick={onclick}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsx)(n.p,{children:"但在 Svelte 中，是提取出来还是写成内联并无特别差别，也不会有什么特别的性能损失："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<button onclick={() => { ... }}>\n  Clicked {count}\n</button>\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"7-生命周期",children:["7. 生命周期",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-生命周期",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 Svelte 4 中，一共提供了 4 个生命周期函数：",(0,c.jsx)(n.code,{children:"onMount"}),"、",(0,c.jsx)(n.code,{children:"onDestroy"}),"、",(0,c.jsx)(n.code,{children:"beforeUpdate"}),"、",(0,c.jsx)(n.code,{children:"afterUpdate"}),"，但在 Svelte 5 中，则只有 2 个：创建和销毁，也就是 ",(0,c.jsx)(n.code,{children:"onMount"}),"和 ",(0,c.jsx)(n.code,{children:"onDestroy"}),"。当状态更新的时候，组件并不会重新渲染，所以不会涉及到组件的生命周期，只是会通知需要对状态变化做出反应的部分（得益于 Signals 机制）。"]}),"\n",(0,c.jsxs)(n.h3,{id:"71-onmount",children:["7.1. onMount",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-onmount",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"之所以 onMount 函数要单独讲一下，因为它类似于 React 的 useEffect，可以返回一个清理函数，它会在组件销毁的时候调用。"}),"\n",(0,c.jsxs)(n.p,{children:["常见的例子就两种情况，",(0,c.jsx)(n.strong,{children:"一种是清理定时器"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Child from './Child.svelte';\n  let condition = $state();\n<\/script>\n\n<input bind:checked={condition} type=\"checkbox\" />\n\n{#if condition}\n  <Child />\n{/if}\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import { onMount } from 'svelte';\n  let count = $state(0);\n  onMount(() => {\n    let intervalId = setInterval(() => {\n      console.log('count', ++count);\n    }, 1000);\n\n    return () => {\n      clearInterval(intervalId);\n    }\n  });\n<\/script>\n\n{count}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/15dc8a8fb2e246ad9628527538a6dde4?version=5.1.10",title:"https://svelte.dev/playground/15dc8a8fb2e246ad9628527538a6dde4?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"如果不设置清理函数，当组件注销后，定时器依然会执行，这就造成了内存泄漏。"}),"\n",(0,c.jsx)(n.p,{children:"另外一种是取消请求："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Child from \'./Child.svelte\';\n  let condition = $state();\n<\/script>\n\n<input bind:checked={condition} type="checkbox" />\n\n{#if condition}\n  <Child />\n{/if}\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import { onMount } from \'svelte\';\n  let src = $state("https://placehold.co/200");\n\n  onMount(() => {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetch(`https://api.thecatapi.com/v1/images/search`, { signal })\n      .then(response => response.json())\n      .then(([{url}]) => { src = url });\n\n    return () => {\n      controller.abort();\n    }\n  });\n<\/script>\n\n<img {src} alt="cat" style="width: 200px;" />\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/8c1fbfa0f8b4457587c99673c47325a2?version=5.1.10",title:"https://svelte.dev/playground/8c1fbfa0f8b4457587c99673c47325a2?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"此时查看网络请求，当组件销毁的时候，会触发取消请求（如果你网速太快，不好测试这个效果，那就设置网速为 3G 之类的）："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"72-ondestroy",children:["7.2. onDestroy",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-ondestroy",children:"#"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { onDestroy } from 'svelte';\n\n  onDestroy(() => {\n    console.log('the component is being destroyed');\n  });\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"该回调会在组件卸载之前立即执行。"}),"\n",(0,c.jsxs)(n.h3,{id:"73-tick",children:["7.3. tick",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#73-tick",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"tick() 函数大家第一遍看的时候可能并不理解其作用，于是就跳过去了。（至少当时我是这样的，后来开发项目时才发现其作用）。所以我们来重点讲解一下。"}),"\n",(0,c.jsx)(n.p,{children:"这是一个输入框，用户输入的字符会变成大写："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let value = $state('');\n  function oninput() {\n    value = this.value.toUpperCase();\n  }\n<\/script>\n\n<input {oninput} {value} >\n"})}),"\n",(0,c.jsxs)(n.p,{children:["看起来没有什么问题，但其实有一个小问题。因为我们修改了 value 的值，会让输入框的内部状态发生重置。我们先输入一堆字符，然后选择中间的一些字符修改为其他字符试试。",(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/526e07e9f0b549ce9b813b358340c8ad?version=5.1.10",title:"https://svelte.dev/playground/526e07e9f0b549ce9b813b358340c8ad?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"在上图中，我们首先输入了一堆字符 A，然后选择中间的一些字符 A 修改为字符 B，字符确实修改了，但光标的位置突然来到了末尾！虽然这不是什么大问题，但如果被测试发现了让你修改，你可能就会感到头疼无助了……"}),"\n",(0,c.jsx)(n.p,{children:"为了解决这个问题，我们需要手动设置输入框的选择区域："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  let value = $state('');\n  function oninput(event) {\n    const { selectionStart, selectionEnd } = this;\n    value = this.value.toUpperCase();\n\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n  }\n<\/script>\n\n<input {oninput} {value} >\n"})}),"\n",(0,c.jsx)(n.p,{children:"但这样做是没有效果的！为什么呢？这就要说到 Svelte 的更新机制了。"}),"\n",(0,c.jsx)(n.p,{children:"简单来说，Svelte 的更新类似于 React 的 setState，它不会立刻更新 DOM，而会在下一个微任务的时候统一修改，这样就可以避免一些不必要的重复操作。"}),"\n",(0,c.jsx)(n.p,{children:"所以虽然你在修改输入框的 value 值后，立刻设置了 selectionStart 和 selectionEnd，但因为 Svelte 因为不会立刻更新，所以执行顺序是先设置 selectionStart、selectionEnd，然后 DOM 才更新，DOM 更新后，状态重置，于是光标又回到了末尾。"}),"\n",(0,c.jsx)(n.p,{children:"这个时候就需要 tick 函数了，tick 会返回一个 Promise，在挂起状态（pending state）应用于 DOM 后 resolve（也就是 DOM 更新后调用）。我们将代码修改为："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { tick } from 'svelte';\n\n  let value = $state('');\n  async function oninput(event) {\n    const { selectionStart, selectionEnd } = this;\n    value = this.value.toUpperCase();\n\n    await tick()\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n  }\n<\/script>\n\n<input {oninput} {value} >\n"})}),"\n",(0,c.jsxs)(n.p,{children:["此时的执行顺序是先修改输入框的值，然后 DOM 更新，状态重置，光标回到末尾，最后再设置输入框的 selectionStart 和 selectionEnd，光标回到正常位置。所以",(0,c.jsx)(n.a,{href:"https://svelte.dev/playground/0f2aa9251136492d8fde9c5178e6fc26?version=5.1.10",title:"https://svelte.dev/playground/0f2aa9251136492d8fde9c5178e6fc26?version=5.1.10",target:"_blank",rel:"noopener noreferrer",children:"此时浏览器效果正常："})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"8-最后",children:["8. 最后",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-最后",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"恭喜您完成了第一篇内容的学习！本篇的内容比较零碎，基本都是 Tutorial 中第一部分的知识，目的在于让您学习基础的时候，能够理解其背景和原理，加深认知。"}),"\n",(0,c.jsx)(n.p,{children:"对于 Svelte 的初学者，你可能会好奇：“我学最新的 Svelte 5 就好了，你为什么非要扯点 Svelte 4？”，这一方面是因为考虑到有些同学使用过 Svelte 4，需要帮助大家将思维过渡到 Svelte 5。"}),"\n",(0,c.jsx)(n.p,{children:"另一方面，对于完全的初学者，做项目必然要搜索 Svelte 相关的问题、接触 Svelte 的周边生态，Svelte 5 刚刚发布，很多内容还没有跟上，你必然会接触到很多 Svelte 4 的内容，你要清楚的知道这些是 Svelte 4 的内容，否则直接套用可能会出问题，为此你需要了解一点 Svelte 4 的内容，哪怕只是随便看看。"}),"\n",(0,c.jsx)(n.p,{children:"此外，Svelte 初学的时候可能会有些不习惯，但再学几天，你就习惯了。当你写习惯了，真不想再回去写 React、Vue 了……"}),"\n",(0,c.jsx)(n.p,{children:"接下来的几篇是专题讲解，都是 Svelte 中的重点内容。让我们继续学习吧！"})]})}function C(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(E,{...e})}):E(e)}let $=C;C.__RSPRESS_PAGE_META={},C.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F2-%E8%AF%AD%E6%B3%95%E7%AF%87%20%E2%9D%98%20%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Hello World!",id:"2-hello-world",depth:2},{text:"3. 响应式",id:"3-响应式",depth:2},{text:"3.1. Svelte 3 赋值",id:"31-svelte-3-赋值",depth:3},{text:"3.2. Svelte 5 符文",id:"32-svelte-5-符文",depth:3},{text:"3.3. Svelte 5 Effect",id:"33-svelte-5-effect",depth:3},{text:"4. Props",id:"4-props",depth:2},{text:"5. 逻辑区块",id:"5-逻辑区块",depth:2},{text:"5.1. IF 语句",id:"51-if-语句",depth:3},{text:"5.2. Each 语句",id:"52-each-语句",depth:3},{text:"5.3. Await 语句",id:"53-await-语句",depth:3},{text:"5.4. Key Blocks",id:"54-key-blocks",depth:3},{text:"6. **事件**",id:"6-事件",depth:2},{text:"7. 生命周期",id:"7-生命周期",depth:2},{text:"7.1. onMount",id:"71-onmount",depth:3},{text:"7.2. onDestroy",id:"72-ondestroy",depth:3},{text:"7.3. tick",id:"73-tick",depth:3},{text:"8. 最后",id:"8-最后",depth:2}],title:"2-语法篇 ❘ 基础用法",headingTitle:"2-语法篇 ❘ 基础用法",frontmatter:{}}}}]);